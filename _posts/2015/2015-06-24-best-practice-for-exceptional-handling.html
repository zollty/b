---
layout: ue
title: 异常处理最佳实践
category: Java编程与JVM
tags: 异常处理
keywords: "异常处理最佳实践"
---

<p><br/></p><p><strong>一、异常的分类</strong></p><p>常规分类：</p><p>&nbsp; 1、运行时异常（RuntimeException）；</p><p>&nbsp; 2、编译时异常（CheckedException）</p><p>用途分类：</p><p>&nbsp; 1、<span style="color: rgb(0, 112, 192); ">打断（终止）程序继续往下运行</span>；</p><p>&nbsp; 2、打断程序继续往下运行，并<span style="color: rgb(0, 112, 192); ">将异常原因和信息送往上层</span>。<br/></p><p>特点分类：</p><p>&nbsp; 1、可以获得异常的<span style="color: rgb(0, 112, 192); ">原因</span>；</p><p>&nbsp; 2、可以获得异常的<span style="color: rgb(0, 112, 192); ">代号</span>；</p><p>&nbsp; 3、可以获得异常的错误<span style="color: rgb(0, 112, 192); ">行号</span>；</p><p>&nbsp; 4、可以获得异常的<span style="color: rgb(0, 112, 192); ">堆栈信息</span>（程序运行轨迹）；</p><p>&nbsp; 5、可以获得异常的<span style="color: rgb(0, 112, 192); ">类型</span>；</p><p>&nbsp; &nbsp; ……等。</p><p>判断分类：</p><p>&nbsp; 1、可以<span style="color: rgb(0, 112, 192); ">预判（预先判断）、自主定义</span>的异常，比如我们自己写程序，在Service中，<span style="color: rgb(0, 112, 192); ">当 (id==null &amp;&amp; type==2) 时，抛出一个AbcException异常</span>；</p><p>&nbsp; 2、<span style="color: rgb(0, 112, 192); ">不可预判、不透明</span>的异常，比如工具库<span style="color: rgb(0, 112, 192); ">内部的异常</span>（SQLException、IBEException）等。</p><p><br/></p><p>针对这些不同类型的异常，他们的使用方式 和 处理方式，是不一样的，详见下面的分析。</p><p><br/></p><p><strong>二、异常的常见使用场景分析</strong></p><p>1、举例1：假设有web、service、dao三层，但是在dao层报错，抛出SQLException或者其他DAO工具库内部的Exception。<br/></p><p>对于这种情况，我们通常需要日志记录异常信息；而在web层反馈到view<span style="color: rgb(0, 112, 192); ">页面</span>上，则不会告诉用户<span style="color: rgb(0, 112, 192); ">底层的</span>错误原因，只是告诉用户出现了未知异常，或者大概是什么原因出错。</p><p>&nbsp; &nbsp; 分析：1）工具库内部的错误，比如SQLException，对我们来说，是不可预知的，我们不知道何时、在什么情况下会出现错误，也就是说无法预先判断。2）dao层报错，需要通知上层，也需要记录日志，这个日志是在dao层记录，还是让上层决定 是否记录？ 其实这是个普遍问题，放到service层或者通用工具类中，也有这个选择：到底是自己记录日志并且把异常信息往上层抛，还是自己不记录日志，只把完整的异常信息传递给上层，让上层决定是否记录日志。我赞成的是后者，通常情况，我们统一的在中间层都不记录日志信息，有异常直接往外层throw抛出，对开发者而言非常方便（这才是重点）。</p><p><br/></p><p>2、举例2：接上例，假设我们在service层中，做了一个判断：<span style="line-height: 32.4000015258789px;">当 (<span style="line-height: 32.4000015258789px;">password</span>不正确) 时，往外抛出一个自定义的异常，异常信息为 “密码错误！！”。对于这种情况，通常情况下，我们不需要记录日志，因为这个错误是我们自己定义的，而且是可以预料的，错误信息的作用是告诉用户，而不是作为日志分析作用。</span></p><p><span style="line-height: 32.4000015258789px;">&nbsp; &nbsp; 分析：1）明确一点，对于这种类型的错误，我们不需要记录日志，但是仍然要向上层返回错误信息，并且注意到一点，我们只需要错误信息message，不需要异常的行号、运行时的堆栈信息等。</span></p><p><br/></p><p><strong><span style="font-size: 20px;">三、Java异常处理分析</span></strong><br/><span style="line-height: 32.4000015258789px;"></span></p><p><span class="note-title-text"></span></p><div><p><strong><br/></strong></p><p><strong>找准异常处理的出口。</strong></p></div><div>1）通常，异常的出口为：</div><div>web层（action、controller），最终其实归结到 Servlet 和 Filter。</div><div><br/></div><div>所以，在我们编写程序的最外层，比如action中，是不应该再出现“未捕获的异常”的，因为这样我们就没办法控制了。</div><div>因此，我们要在最外层，做好应有的异常处理。</div><div><br/></div><div>特别提醒，不只是action、controller，一些对外提供服务的Servlet或者Webservice，都算是异常的最终出口。</div><div><br/></div><div>2）自定义的异常出口</div><div>除了web层外，其他地方也可以成为“自定义”的异常出口。</div><div>比如，一个utils抛出了异常，我在service里面就捕获了，然后“就地解决”掉，不再继续传播这个异常。</div><div>这种情况，就是所谓的“自定义的异常出口”。</div><div><br/></div><div><strong>异常的处理方式</strong></div><div>根据异常的出口分类，有“web层出口的异常”和“自定义出口的异常”。</div><div><br/></div><div>1、web层出口的异常</div><div>又可以分类如下：</div><div>1）需要实现异常消息的“国际化”（多语言版本）。</div><div>2）不需要“国际化”。</div><div><br/></div><div><div>a）异常出口直接面向的是用户或者浏览器。</div><div>b）异常出口面向的是其他系统。</div></div><div><br/></div><div>&nbsp; &nbsp; 对于1），经典的解决方案就是：定义所有可以预知的错误信息（用errorCode和errorMsg），errorCode对应多个语言版本的errorMsg。</div><div>&nbsp; &nbsp; 对于2），则可以不用errorCode和errorMsg，直接往外抛出错误信息即可。但是不推荐这么做。原因如下：</div><div>&nbsp; &nbsp; - 异常信息可能很简陋，如果用堆栈信息，那么堆栈信息又不方便在客户端展示。</div><div>&nbsp; &nbsp; - 异常信息也可能很大，例如一个sql错误，仅errorMessage就可能几千个字符，不便于web端展示。</div><div>&nbsp; &nbsp; - 原生的异常信息，通常是给开发人员看的，对于用户来讲，可能不好理解。</div><div><br/></div><div>&nbsp; &nbsp; 对于a），可以直接返回异常的具体信息，如果要支持国际化，也是可行的。</div><div>&nbsp; &nbsp; 对于b），把异常信息直接返回给其他系统，不是一种好的做法，因为有可能其他系统需要，对异常类型做判断或加工。</div><div>&nbsp; &nbsp; 故，最好是，返回errorCode和errorMsg，其他系统可以根据errorCode去做判断或加工。</div><div><br/></div><div>总结：</div><div>&nbsp; &nbsp; 综合考虑 1）2）a）b），一种较好的异常处理方式是： 定义所以可以预知的错误信息，用errorCode和errorMsg表示。必要是可以增加errorMsg的语言版本。</div><div>&nbsp; &nbsp; 这就要求我们，在编写异常处理的代码时，不要用中文。要么把错误信息定义成errorCode，要么用简洁的英文描述错误信息。 &nbsp; &nbsp;</div><div>&nbsp; &nbsp; 例如，</div><div>&nbsp; &nbsp; try{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.........</div><div>&nbsp; &nbsp; }catch(Excpetion e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new MyException(ErrorCode.C0001, e.getMessage());</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; 或者</div><div><div>&nbsp; &nbsp; try{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;........</div><div>&nbsp; &nbsp; }catch(Excpetion e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new MyRuntimeException(&quot; encode failure! n must big than 0.&quot;);</div><div>&nbsp; &nbsp; }</div></div><div><div>&nbsp; &nbsp;或者</div><div><div>&nbsp; &nbsp; try{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;........</div><div>&nbsp; &nbsp; }catch(IOExcpetion e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ExceptionWrapper(e); //用ExceptionWrapper这个工具类，包装原始的错误信息</div><div>&nbsp; &nbsp; }</div></div></div><div>&nbsp; &nbsp; 这三种写法，都是符合上面的规范的。但是使用场景不同。</div><div>&nbsp; &nbsp; 第一种，面向的是较高层次的代码，比如service层、dao层，它可以直接传递到web层去。所以就地定义了ErrorCode。</div><div>&nbsp; &nbsp; 第二种和第三种写法，面向的是较底层的代码，比如最底层的工具类。</div><div><br/></div><div>&nbsp; &nbsp; 在面向客户的项目中，建议只用第一种写法。第二、三种写法，更多的是用于那些面向服务的项目中。</div><div><br/></div><div>2、自定义出口的异常</div><div>&nbsp; &nbsp;有时候，我们不需要把异常再通知外部，在自己内部处理就行了。</div><div>&nbsp; &nbsp; 比如：</div><div>&nbsp; &nbsp; try{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InputStream in = IOUtils.getInputStream(filePath);</div><div>&nbsp; &nbsp; }catch(IOException e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log.warn(e);</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; 出错时，直接记录日志就OK了，不需要再把这个错误往外抛出。</div><div>&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; 有时候，也可以这么做：</div><div><br/></div><div>public void doParse(){</div><div>&nbsp; &nbsp; .......</div><div>&nbsp; &nbsp; try{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;........</div><div>&nbsp; &nbsp; }catch(IOExcpetion e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ExceptionWrapper(e); //用ExceptionWrapper这个工具类，包装原始的错误信息</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; ......</div><div>}</div><div><br/></div><div>public void doServiceAA(){</div><div>&nbsp; &nbsp; try{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;doParse();</div><div>&nbsp; &nbsp; }catch(Excpetion e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw new MyException(ErrorCode.C0001, e.getMessage());</div><div>&nbsp; &nbsp; }</div><div>}</div><div><div>public void doServiceAA(){</div><div>&nbsp; &nbsp; try{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;doParse();</div><div>&nbsp; &nbsp; }catch(Excpetion e){</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// ignore this error</div><div>&nbsp; &nbsp; }</div><div>}</div></div><div>&nbsp; &nbsp; 就是说，错误时，在这个地方不做处理，把错误往外抛出，交给上层去决定怎么来处理这个错误。</div><div>&nbsp; &nbsp; 但这种用法还是比较少的。不建议滥用。</div><p><span style="line-height: 32.4000015258789px;"><br/></span></p><p><strong><span style="line-height: 32.4000015258789px;">四、异常处理最佳实践</span></strong></p><p><span style="line-height: 32.4000015258789px;">1、以 STC票控项目 为例，</span><span style="line-height: 1.8;">整个项目的异常，分为三层：</span></p><p><span style="line-height: 1.8;"><br/></span></p><p>&nbsp; 第一层：最基础的父类</p><p>&nbsp; BasicCheckedException （继承于Exception）</p><p>&nbsp; BasicRuntimeException （继承于RuntimeException）</p><p><span style="line-height: 32.4000015258789px;">（注意，整个项目，不要直接new新建 Exception 和 RuntimeException ）</span></p><p>&nbsp;&nbsp;</p><p>&nbsp; 第二层：</p><p>&nbsp; NestedCheckedException （继承于BasicCheckedException）</p><p>&nbsp; NestedRuntimeException （继承于BasicRuntimeException）</p><p>&nbsp;&nbsp;</p><p>&nbsp; 第三层：&nbsp;<span style="line-height: 1.8;">在上面4个异常类的基础上，扩展的异常类型。</span></p><p>&nbsp; 目前有：</p><p>&nbsp; StcOrigException （原始异常，用于代替 Exception）-继承于BasicCheckedException</p><p>&nbsp; StcOrigRuntimeException （原始异常，用于代替 RuntimeException）-继承于BasicRuntimeException</p><p><span style="line-height: 1.8;">&nbsp;&nbsp;</span></p><p>&nbsp; StcNestedException （嵌套包装异常，用于将原始异常包装起来）-继承于NestedCheckedException</p><p>&nbsp; StcNestedRuntimeException （嵌套包装异常，用于将原始异常包装起来）-继承于NestedRuntimeException</p><p><br/></p><p>&nbsp; StcI18nException （I18N国际化异常，包含errorCode和errorMsg，可对应中文、英文、繁体等异常信息）-继承于BasicCheckedException</p><p><br/></p><p>&nbsp; StcNoLogException （打断但是不记录日志的异常，仅用于打断程序执行，但是外面不再记录异常信息）-继承于BasicCheckedException</p><p><br/></p><p>2、最佳实践说明</p><p>说得简单点，其实项目中，用得最多的异常为&nbsp;<span style="line-height: 32.4000015258789px;">StcNestedException、<span style="line-height: 32.4000015258789px;">StcI18nException、</span><span style="line-height: 32.4000015258789px;">BasicCheckedException，前两者用于new创建异常，后者<span style="line-height: 32.4000015258789px;">BasicCheckedException用于声明throws异常。举例如下：</span></span></span></p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;UserDAO&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;pubic&nbsp;User&nbsp;queryById(Long&nbsp;id)&nbsp;throws&nbsp;BasicCheckedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(id&lt;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StcNestedException(&quot;ID小于0的用户不存在！&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;uobj&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uobj&nbsp;=&nbsp;getDao.query(&quot;select&nbsp;from&nbsp;User&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StcNestedException(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;UserTools.toUser(uobj);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><br/></p><p>这样写有几个好处：</p><p>1）对于new StcNestedException(&quot;ID小于0的用户不存在！&quot;)，我们不需要记录异常的堆栈和行号，只需要把错误信息往外抛出即可。此处也可以换成用I18n国际化errorCode代码标识的异常：&nbsp;<span style="line-height: 32.4000015258789px;">new StcI18nException(ErrorCode.USR023, id)。</span></p><p>2）对于getDao.query(&quot;select from User&quot;)可能抛出的SQLException等异常，我们套用了StcNestedException，它可以原封不动的把原始异常的完整信息（比如message、行号和堆栈）保存下来。</p><p><br/></p><p><span style="font-size: 20px; "><strong>四、异常和日志处理的关系</strong></span></p><p><br/></p><p>异常处理 和 日志处理 有密切关系，但是<strong>不能混为一谈</strong>。可以这样说：</p><p>1）出现异常 <span style="color: rgb(0, 112, 192); ">不一定要</span> 记录日志。</p><p>2）记录日志 也不一定 是出现异常的时候。</p><p><br/></p><p>就异常和日志处理的 常见关联点，举例做一个说明：<br/></p><p><br/></p><p>1、例（一）</p><p>&nbsp; &nbsp; Dao层报错，需要通知上层，也需要记录日志，这个日志是在dao层记录，还是让上层（比如Service层）决定 是否记录？</p><p>分析：</p><p>&nbsp; &nbsp; 其实这是个普遍问题，放到service层或者通用工具类中，也有这个选择：到底是<strong>自己记录日志并且把异常信息往上层抛</strong>，还是<strong>自己不记录日志，只把完整的异常信息传递给上层</strong><strong>，让上层决定是否记录日志</strong>。</p><p>&nbsp; &nbsp; 我赞成的是后者，通常情况，我们统一的在<strong>中间层都不记录日志信息</strong>，有异常直接<strong>往外层throw抛出</strong>，对开发者而言非常方便（这才是重点）。</p><p><br/></p><p>2、例（二）</p><p>&nbsp; &nbsp; &nbsp;因为某种业务需要，我们要在某个Prosessor类中记录日志信息，同时也要终止程序执行。</p><p>我们的需求：1）记录错误信息；2）打断程序运行。</p><p>传统做法：<br/></p><pre class="brush:java;toolbar:false">try&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;doService();&nbsp;
}&nbsp;catch(AbeException&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;log.error(e);
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;
}</pre><p>这种做法能满足上面的需求，但是又超过了我们的需求。因为它 throw e 虽然终止了程序的执行，但是它把错误信息和错误堆栈，都抛给了外层，而外层捕获到这个错误后，又可能会再次记录日志信息，这样就造成了<strong>日志信息多出重复</strong>，而且往往日志的<strong>堆栈信息</strong>非常长，看着很吃力。</p><p>&nbsp; &nbsp; 以上问题就在于，我们只想“打断程序运行”，并<strong>不想</strong><strong>把异常堆栈信息</strong>再继续<strong>往外传递</strong>。</p><p>&nbsp; &nbsp; 这个时候，上面提到的“异常处理最佳实践”就提出了一种方案，一种只打断程序执行，不记录堆栈信息的异常——NoLogException。用NoLogException来改造上面的程序，就成了：</p><pre class="brush:java;toolbar:false">try&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;doService();&nbsp;
}&nbsp;catch(AbeException&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;log.error(e);
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NoLogException();
}</pre><p>这样，外层可以判断是否为 NoLogException，如果是则外层不记录日志。退一步讲，即使外层不判断是否为NoLogException，它也可以记录日志信息，但是在NoLogException中没有任何异常的信息（只有一个错误代号），想记录也记录不到。</p><p><br/></p>