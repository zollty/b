---
layout: ue
title: 异常处理最佳实践
category: Java语言程序设计
tags: 异常处理
keywords: "异常处理最佳实践"
---

<p><br/></p><p><strong>一、异常的分类</strong></p><p>常规分类：1、运行时异常（RuntimeException）；2、编译时异常（CheckedException）</p><p>用途分类：1、打断（终止）程序继续往下运行；2、打断程序继续往下运行，并将异常原因和信息送往上层。<br/></p><p>特点分类：1、可以获得异常的原因；2、可以获得异常的编号；3、可以获得异常的错误行号；4、可以获得异常的堆栈信息（程序运行轨迹）；4、可以获得异常的类型；……等。</p><p>判断分类：1、可以预判（预先判断）、自主定义的异常，比如我们自己写程序，当 (id==null &amp;&amp; type==2) 时，抛出一个AbcException异常；2、不可预判、不透明的异常，比如工具库内部的异常（SQLException、IBEException）等。</p><p><br/></p><p><strong>二、异常的常见使用场景分析</strong></p><p>1、举例1：假设有web、service、dao三层，但是在dao层报错，抛出SQLException或者其他DAO工具库内部的Exception。<br/></p><p>对于这种情况，我们通常需要日志记录异常信息，而在web层反馈到view页面上，则不会告诉用户底层的错误原因，只是告诉用户出现了未知异常，或者大概是什么原因出错。</p><p>&nbsp; &nbsp; 分析：1）工具库内部的错误，比如SQLException，对我们来说，是不可预知的，我们不知道何时、在什么情况下会出现错误，也就是说无法预先判断。2）dao层报错，需要通知上层，也需要记录日志，这个日志是在dao层记录，还是让上层决定 是否记录？ 其实这是个普遍问题，放到service层或者通用工具类中，也有这个选择：到底是自己记录日志并且把异常信息往上层抛，还是自己不记录日志，只把完整的异常信息传递给上层，让上层决定是否记录日志。我赞成的是后者，通常情况，我们统一的在中间层都不记录日志信息，有异常直接往外层throw抛出，对开发者而言非常方便（这才是重点）。</p><p><br/></p><p>2、举例2：接上例，假设我们在service层中，做了一个判断：<span style="line-height: 32.4000015258789px;">当 (<span style="line-height: 32.4000015258789px;">password</span>不正确) 时，往外抛出一个自定义的异常，异常信息为 “密码错误！！”。对于这种情况，通常情况下，我们不需要记录日志，因为这个错误是我们自己定义的，而且是可以预料的，错误信息的作用是告诉用户，而不是作为日志分析作用。</span></p><p><span style="line-height: 32.4000015258789px;">&nbsp; &nbsp; 分析：1）明确一点，对于这种类型的错误，我们不需要记录日志，但是仍然要向上层返回错误信息，并且注意到一点，我们只需要错误信息message，不需要异常的行号、运行时的堆栈信息等。</span></p><p><span style="line-height: 32.4000015258789px;"><br/></span></p><p><strong><span style="line-height: 32.4000015258789px;">三、异常处理最佳实践</span></strong></p><p><span style="line-height: 32.4000015258789px;">1、以 STC票控项目 为例，</span><span style="line-height: 1.8;">整个项目的异常，分为三层：</span></p><p><span style="line-height: 1.8;"><br/></span></p><p>&nbsp; 第一层：最基础的父类</p><p>&nbsp; BasicCheckedException （继承于Exception）</p><p>&nbsp; BasicRuntimeException （继承于RuntimeException）</p><p><span style="line-height: 32.4000015258789px;">（注意，整个项目，不要直接new新建 Exception 和 RuntimeException ）</span></p><p>&nbsp;&nbsp;</p><p>&nbsp; 第二层：</p><p>&nbsp; NestedCheckedException （继承于BasicCheckedException）</p><p>&nbsp; NestedRuntimeException （继承于BasicRuntimeException）</p><p>&nbsp;&nbsp;</p><p>&nbsp; 第三层：&nbsp;<span style="line-height: 1.8;">在上面4个异常类的基础上，扩展的异常类型。</span></p><p>&nbsp; 目前有：</p><p>&nbsp; StcOrigException （原始异常，用于代替 Exception）-继承于BasicCheckedException</p><p>&nbsp; StcOrigRuntimeException （原始异常，用于代替 RuntimeException）-继承于BasicRuntimeException</p><p><span style="line-height: 1.8;">&nbsp;&nbsp;</span></p><p>&nbsp; StcNestedException （嵌套包装异常，用于将原始异常包装起来）-继承于NestedCheckedException</p><p>&nbsp; StcNestedRuntimeException （嵌套包装异常，用于将原始异常包装起来）-继承于NestedRuntimeException</p><p><br/></p><p>&nbsp; StcI18nException （I18N国际化异常，包含errorCode和errorMsg，可对应中文、英文、繁体等异常信息）-继承于BasicCheckedException</p><p><br/></p><p>&nbsp; StcNoLogException （打断但是不记录日志的异常，仅用于打断程序执行，但是外面不再记录异常信息）-继承于BasicCheckedException</p><p><br/></p><p>2、最佳实践说明</p><p>说得简单点，其实项目中，用得最多的异常为&nbsp;<span style="line-height: 32.4000015258789px;">StcNestedException、<span style="line-height: 32.4000015258789px;">StcI18nException、</span><span style="line-height: 32.4000015258789px;">BasicCheckedException，前两者用于new创建异常，后者<span style="line-height: 32.4000015258789px;">BasicCheckedException用于声明throws异常。举例如下：</span></span></span></p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;UserDAO&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;pubic&nbsp;User&nbsp;queryById(Long&nbsp;id)&nbsp;throws&nbsp;BasicCheckedException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(id&lt;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StcNestedException(&quot;ID小于0的用户不存在！&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;uobj&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uobj&nbsp;=&nbsp;getDao.query(&quot;select&nbsp;from&nbsp;User&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;StcNestedException(e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;UserTools.toUser(uobj);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><br/></p><p>这样写有几个好处：</p><p>1）对于new StcNestedException(&quot;ID小于0的用户不存在！&quot;)，我们不需要记录异常的堆栈和行号，只需要把错误信息往外抛出即可。此处也可以换成用I18n国际化errorCode代码标识的异常：&nbsp;<span style="line-height: 32.4000015258789px;">new StcI18nException(ErrorCode.USR023, id)。</span></p><p>2）对于getDao.query(&quot;select from User&quot;)可能抛出的SQLException等异常，我们套用了StcNestedException，它可以原封不动的把原始异常的完整信息（比如message、行号和堆栈）保存下来。</p><p><br/></p><p><br/></p><p><br/></p>
