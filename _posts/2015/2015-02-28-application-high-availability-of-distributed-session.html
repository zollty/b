---
layout: ue
title: 实现集群环境下的高可用Session
category: 系统架构和设计
tags: 分布式Session
keywords: "分布式Session"
---

<p><br/></p><p><span style="font-family:宋体">为了支持海量用户的访问，应用服务器集群这种水平扩展的方式是最常用的。在单机环境中，</span>Session<span style="font-family:宋体">的创建和存储都是由同一个应用服务器实例来完成，而存储也仅是内存中，最多会在正常的停止服务器的时候，把当前活动的</span>Session<span style="font-family:宋体">钝化到本地，再次启动时重新加载。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">而多个实例之间，</span>Session<span style="font-family:宋体">数据是完全隔离的。而为了实现</span>Session<span style="font-family:宋体">的高可用，多实例间</span>session<span style="font-family:宋体">数据共享是必然的。具体来说，常用有以下几种方案：</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">会话保持（案例：</span>Nginx<span style="font-family:宋体">、</span>Haproxy<span style="font-family:宋体">）</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">会话复制（案例：</span>Tomcat<span style="font-family:宋体">，</span>WAS<span style="font-family:宋体">）</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">会话共享（案例：</span>Memcached<span style="font-family:宋体">、</span>Redis<span style="font-family:宋体">）</span></p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">一、Session<span style="font-family:黑体">保持（会话保持</span><span style="font-family: 黑体">、</span>Session<span style="font-family:黑体">粘滞</span><span style="font-family:黑体">）</span></p><p>&nbsp;</p><p><span style="font-family:宋体">会话保持方案，在所有的负载均衡中间件上都有对应的实现。通过会话保持，负载均衡<strong>在进行请求分发的时候</strong>，保证每个客户端<strong>固定的访问到后端的同一台应用服务器</strong>。这是在负载均衡这一层就可以解决</span>Session<span style="font-family:宋体">问题。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">先看</span>Nginx<span style="font-family:宋体">的负载均衡的例子，</span>nginx<span style="font-family:宋体">的</span>upstream<span style="font-family:宋体">目前支持</span>5<span style="font-family:宋体">种方式的分配方式，其中有两种比较通用的</span>Session<span style="font-family:宋体">解决方法，</span>ip_hash<span style="font-family:宋体">和</span>url_hash<span style="font-family:宋体">。注意：后者不是官方模块，需要额外安装。</span></p><p>&nbsp;</p><p>ip_hash<span style="font-family: 宋体">，可以叫做</span>IP<span style="font-family:宋体">粘滞，即每个请求按访问</span>ip<span style="font-family:宋体">的</span>hash<span style="font-family:宋体">结果固定分配，很简单，这样每个访客也能固定访问一个后端服务器，达到了</span>Session<span style="font-family:宋体">保持的效果。例：</span></p><p>upstream bakend {</p><p>&nbsp;&nbsp; ip_hash;</p><p>&nbsp;&nbsp; server 192.168.0.11:80;</p><p>&nbsp;&nbsp; server 192.168.0.12:80;</p><p>&nbsp;}</p><p>&nbsp;</p><p><span style="font-family:宋体">再看</span>Haproxy<span style="font-family:宋体">的负载均衡的例子：</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">源地址</span> Hash<span style="font-family:宋体">（</span>balancesource<span style="font-family:宋体">）</span></p><p>haroxy <span style="font-family: 宋体">将用户</span>IP<span style="font-family:宋体">经过</span>hash<span style="font-family:宋体">计算后指定到固定的真实服务器上（类似于</span>nginx <span style="font-family:宋体">的</span>ip hash <span style="font-family:宋体">指令）</span></p><p>&nbsp;</p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">使用</span>cookie <span style="font-family:宋体">进行识别</span> </p><p><span style="font-family:宋体">也就是</span>Haproxy<span style="font-family:宋体">在用户第一次访问的后在用户浏览器插入了一个</span>Cookie<span style="font-family:宋体">，用户下一次访问的时候浏览器就会带上这个</span>Cookie<span style="font-family:宋体">给</span>Haproxy<span style="font-family:宋体">，</span>Haproxy<span style="font-family:宋体">进行识别。</span></p><p><span style="font-family:宋体">配置指令</span>: &nbsp;cookie &nbsp;SESSION_COOKIE&nbsp; insert indirect nocache</p><p><span style="font-family:宋体">配置例子如下：</span></p><p>cookie SERVERID insert indirect nocache</p><p>server web01 192.168.56.11:8080 check cookie web01</p><p>server web02 192.168.56.12:8080 check cookie web02</p><p>&nbsp;</p><p><span style="font-family:宋体">会话保持的缺点：</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">负载不均衡了：由于使用了固定的</span>ip hash<span style="font-family:宋体">，像权重分配这样的动态策略已经无法工作，破坏了负载均衡的灵活性。</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">没有彻底解决问题：如果后端有服务器宕机，负载均衡把请求路由到其他服务器，那用户在其他服务器上无</span>session<span style="font-family:宋体">信息，仍然需要重新登录。</span></p><p>&nbsp;</p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">二、<span style="font-family:黑体">会话复制</span></p><p>&nbsp;</p><p><span style="font-family:宋体">就是把</span>Session<span style="font-family:宋体">信息同步给集群上的所有服务器上，例如</span>tomcat<span style="font-family:宋体">支持的，是基于</span>IP<span style="font-family:宋体">多播（</span>multicast<span style="font-family:宋体">），</span>Tomcat<span style="font-family:宋体">的会话复制分为两种：</span></p><p><span style="font-family:宋体">全局会话复制：利用</span>Delta Manager<span style="font-family:宋体">复制会话中的<strong>变更信息</strong>到集群中的<strong>所有其他节点</strong>。</span></p><p><span style="font-family:宋体">非全局复制：使用</span>Backup Manager<span style="font-family:宋体">进行复制，它会把</span>Session<strong><span style="font-family:宋体">复制给一个指定的备份节点</span></strong><span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">另外，像一些企业级应用服务器，</span>WAS<span style="font-family:宋体">，</span>JBOSS<span style="font-family:宋体">，在集群上的支持会更好一些，</span>session<span style="font-family:宋体">复制也更高效和可靠。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">但是总的来说，会话复制理念，还是不够高效，而且只能用于相同类型的服务器之间，而且</span>session<span style="font-family:宋体">内容是基于</span>java io<span style="font-family:宋体">的序列化方式保存，性能消耗很大。总之，会话复制，不适合大的集群和复杂网络环境，所以不过多介绍。</span></p><p>&nbsp;</p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">三、<span style="font-family:黑体">会话共享</span></p><p>&nbsp;</p><p><span style="font-family:宋体">会话复制的效率，赶不上会话集中单独管理，即集群中所有服务器都在同一个地方去拿</span>Session<span style="font-family:宋体">信息，这样也更专业一些。</span></p><p>&nbsp;</p><p>Session<span style="font-family: 宋体">集中存放到哪里？</span></p><p><span style="font-family:宋体">对于</span>Session<span style="font-family:宋体">来说，肯定是频繁使用的，虽然你可以把它存放在数据库中，但是真正生产环境中一般推荐存放在性能更快的分布式</span>KV<span style="font-family:宋体">数据中，例如：</span>Memcached<span style="font-family:宋体">和</span>Redis<span style="font-family:宋体">。</span></p><p>&nbsp;</p><p>Tomcat<span style="font-family:宋体">等一些服务器，都支持扩展一些插件，自动把</span>session<span style="font-family:宋体">信息保存到</span>Memcached<span style="font-family:宋体">和</span>Redis<span style="font-family:宋体">缓存中。对于</span>Tomcat<span style="font-family:宋体">，我们可以使用</span>MSM<span style="font-family:宋体">（</span>Memcached Session Manager<span style="font-family:宋体">）来实现把</span>Session<span style="font-family:宋体">存放到</span>Memcache<span style="font-family:宋体">中，</span>Github<span style="font-family:宋体">地址如下：</span>https://github.com/magro/memcached-session-manager<span style="font-family:宋体">目前支持</span>Tomcat 6.x7.x<span style="font-family:宋体">和</span>8.x<span style="font-family:宋体">的版本。</span></p><p><span style="font-family:宋体">如果你想使用</span>Redis<span style="font-family:宋体">，刚好也有开源的可以用，但是遗憾的是暂时不支持</span>Tomcat 8.x<span style="font-family:宋体">的版本：</span>https://github.com/jcoleman/tomcat-redis-session-manager</p><p>&nbsp;</p><p>Tomcat<span style="font-family:宋体">保存</span>session<span style="font-family:宋体">到缓存的原理参见：</span></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3MTEwODc5Ng==&mid=2650859165&idx=1&sn=06d5a4f05d1108a8c78ad68963eebc42&scene=21#wechat_redirect" target="_self">详解集群内Session高可用的实现原理</a> </p><p><br/></p><p>&nbsp;</p>