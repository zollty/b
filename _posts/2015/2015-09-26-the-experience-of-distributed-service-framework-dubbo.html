---
layout: ue
title: dubbo分布式服务化框架的使用经验
category: Java框架和组件
tags: Dubbo
keywords: "Dubbo,分布式,SOA"
---

<p><br/></p><p>初学者可以看看如下文章：</p><p>http://shiyanjun.cn/archives/1075.html</p><p><br/></p><p><span style="font-size: 18px;"><strong>Dubbo获取不到IP的问题</strong></span></p><p>如dubbo官方文档所述：</p><p>http://dubbo.io/Host+Binding-zh.htm</p><p>缺省主机IP查找顺序：&nbsp;</p><p>&nbsp;通过LocalHost.getLocalHost()获取本机地址。&nbsp;</p><p>&nbsp; 如果是127.*等loopback地址，则扫描各网卡，获取网卡IP。&nbsp;</p><p>&nbsp; 注册的地址如果获取不正确，比如需要注册公网地址，可以：&nbsp;</p><p>1. 可以在/etc/hosts中加入：机器名 公网IP，比如： test1 205.182.23.201&nbsp;</p><p>2. 在dubbo.xml中加入主机地址的配置： &lt;dubbo:protocol host=&quot;205.182.23.201&quot; /&gt;</p><p>3. 或在dubbo.properties中加入主机地址的配置：</p><p>dubbo.protocol.host=205.182.23.201 或 JAVA_OPTIONS=&quot;-Ddubbo.protocol.host=192.168.1.111</p><p><br/></p><p><span style="color: rgb(0, 32, 96);">如果能自动获取本机IP，肯定是最好的办法。而通过配置去设置IP，是下下策。</span></p><p>但dubbo自动获取本机IP的util写得不好，一些本应该能获取到ip的情况，它却获取不到。</p><p>有关获取IP的util，可以参考我写的一个IPUtils.java</p><p><br/></p><p>有人被dubbo这一点坑过：</p><p>http://blog.csdn.net/chwshuang/article/details/51334180</p><p>另外一个：</p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">今天早上，dubbo服务又出现了问题。</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">A服务启动正常，B服务死活连不上A。</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">无论是广播，还是Zookeeper。</span></p><p><br/></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">调试了100分钟，最终还是逐步分析出了问题。</span></p><p><br/></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">第1种可能：A服务和B服务，在端口号，注册中心配置方面，出现了不一致（平时一直正常，出现问题的可能性很小。）</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">第2种可能：本地DNS出现问题。（排除，本地防火墙一直是关闭的。）</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">第3种可能：防火墙导致。（打算重启WindowsDNS服务的时候，看了下本地IP。）</span></p><p><br/></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">Eclipse控制台，一直提示连不上某个IP，192.168.1.23。</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">之前的IP还是192.168.1.197，按说IP不太可能发生变化的。</span></p><p><br/></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">ipconfig发现有2个 IP-V4的地址。</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">ping 192.168.1.23，确实ping不通。</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">按道理讲，ping本地ip却不通，是不可能的。</span></p><p><br/></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">突然想起来，右下角的QQ电脑管家的wifi热点，还是开着的，但是连不上网。</span></p><p><br/></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">最终确认，就是这个因素导致的。</span></p><p><br/></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">wifi热点启动了，但是没有正常连网，却占了1个ipv4的地址。</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">dubbo恰好又优先使用了这个ip地址，最终坑了！</span></p><p><span style="font-size: 16px; color: rgb(192, 0, 0);">2016年7月13日</span></p><p><br/></p><p><br/></p><p><span style="font-size: 20px;"><strong>Dubbo在Spring下使用的问题</strong></span></p><p><br/></p><p>如果Spring容器还未加载完，就在Dubbo中暴露服务，会导致api出现问题。</p><p>解决方案：设置dubbo延迟到spring容器启动完之后在暴露服务：</p><p>&lt;dubbo:provider delay=&quot;-1&quot; timeout=&quot;10000&quot; retries=&quot;0&quot; /&gt;&nbsp;</p><p>以上设置成10秒超时，可根据情况修改 。</p><p><br/></p><p><br/></p><p><strong>Dubbo怎么样一次访问调用集群中所有节点？</strong></p><p><br/></p><p>配置下消费者端即可。dubbo已经支持广播调用《broadcast》</p><p>&lt;dubbo:referenceid=&quot;testservice&quot;interface=&quot;xxx.TestService&quot;timeout=&quot;8000&quot;cluster=&quot;broadcast&quot;/&gt;</p><p><br/></p><p><br/></p><p><strong>Spring jar包冲突</strong></p><p><br/></p><p>我们现在用的spring是3，而dubbo引用的是2.5.6，会造成jar包冲突，需要排除</p><p>错误信息：WARN:oejuc.AbstractLifeCycle:FAILED ModelViewController: java.lang.NoSuchFieldError: APPLICATION_CONTEXT_ID_PREFIX</p><p>解决办法：</p><p>&lt;dependency&gt;</p><p>&nbsp; &nbsp; &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</p><p>&nbsp; &nbsp; &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</p><p>&nbsp; &nbsp; &lt;version&gt;2.4.9&lt;/version&gt;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;exclusions&gt;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;exclusion&gt;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;groupId&gt;org.springframework&lt;/groupId&gt;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;artifactId&gt;spring&lt;/artifactId&gt;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;/exclusion&gt;</p><p>&nbsp; &nbsp; &lt;/exclusions&gt;</p><p>&lt;/dependency&gt;</p><p><br/></p><p><br/></p><p><strong>开发时使dubbo服务端不注册到中心</strong></p><p><br/></p><p>dubbo服务开发不参加联调的时候，可以不注册到中心</p><p>1.jvm启动参数&nbsp;</p><p>-Ddubbo.registry.address=192.168.1.109:2183?register=false</p><p>或dubbo.xml 配置</p><p>&lt;dubbo:registry address=&quot;10.20.153.10:9090&quot; register=&quot;false&quot; /&gt;</p><p>（上线要改回来）</p><p><br/></p><p><br/></p><p><strong>dubbo-monitor-simple写文件过多问题</strong></p><p>里面有个配置dubbo.statistics.directory=${user.home}/monitor/statistics</p><p><br/></p><p>下面的监控是写文件的，导致服务器的文件过多，几个月下来inode都要满了。</p><p><br/></p><p>定期清理，或者用第三方开源dubbo-monitor：</p><p>http://git.oschina.net/handu/dubbo-monitor</p><p>https://github.com/handuyishe/dubbo-monitor</p><p><br/></p><p><br/></p><p><br/></p><p><span style="font-size: 20px;"><strong>Dubbo异步调用问题</strong></span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">dubbo的异步调用发现个问题</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">A -----[异步]--&gt; &nbsp; &nbsp;B &nbsp; --[同步调用]--&gt;C</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">B同步dubbo调用C，就会直接返回null</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">如果B调用C后，下一步还有同步调用D，D返回的会正确；</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">场景描述：客户端远程异步调用ServiceB，ServiceB在处理客户端请求的过程中需要远程同步调用ServiceC，ServiceB从ServiceC的响应中取数据时，得到的是null，对就是这个坑。</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">2楼 2016/05/08 22:57</span></p><p><span style="color: rgb(192, 0, 0);">那个Dubbo异步调用的问题,,我们也遇到了,,爬了1个星期的坑,开始解决方案是 B如果发现返回值是null,再请求一次,后来发现太多了,而且low,就改成全部同步调用了</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">调皮的程序员</span></p><p><span style="color: rgb(192, 0, 0);">3楼 2016/06/28 10:20</span></p><p><span style="color: rgb(192, 0, 0);">异步这个坑，把我们坑惨了，擦，找了好久才发现异步这个问题</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">原因和解决方法：（转载自http://blog.csdn.net/windrui/article/details/52150345）</span></p><p><span style="color: rgb(192, 0, 0);">使用DEBUG模式，分析Dubbo源码得到问题的起因。</span></p><p><span style="color: rgb(192, 0, 0);">分析过程如下：</span></p><p><span style="color: rgb(192, 0, 0);">客户端和服务端通信，配置使用netty进行网络传输，通过</span></p><p><span style="color: rgb(192, 0, 0);">NettyHandler进行具体的消息收发操作，所以从此入手进行源码分析。</span></p><p><span style="color: rgb(192, 0, 0);">client到ServiceA的远程方法异步调用，会在RpcContext(RpcContext是一个临时状态记录器，当接收到RPC请求，或发起RPC请求时，RpcContext的状态都会变化。比如：A调B，B再调C，则B机器上，在B调C之前，RpcContext记录的是A调B的信息，在B调C之后，RpcContext记录的是B调C的信息)的attachments(Map结构)属性中添加async=true的键值对，同时也会在RpcInvocation的attachments(Map结构)中添加async=true的键值对。</span></p><p><span style="color: rgb(192, 0, 0);">经过一系列的Filter，程序运行到AbstractInvoker的invoke方法，注意该方法中的如下代码段，</span></p><p><span style="color: rgb(192, 0, 0);">Map&lt;String, String&gt; context = RpcContext.getContext().getAttachments();</span></p><p><span style="color: rgb(192, 0, 0);">if (context != null) {</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; invocation.addAttachmentsIfAbsent(context);</span></p><p><span style="color: rgb(192, 0, 0);">}</span></p><p><span style="color: rgb(192, 0, 0);">这里会把当前RpcContext中的attachments添加到调用ServiceB的RpcInvocation中，这时候async=true已经添加了，接着执行如下代码段，</span></p><p><span style="color: rgb(192, 0, 0);">if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)){</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());</span></p><p><span style="color: rgb(192, 0, 0);">}</span></p><p><span style="color: rgb(192, 0, 0);">上面代码判断调用ServiceB的URL中是否含有async=true，如果有将设置async=true到RpcInvocation的attachments中，这时候是不包含的。</span></p><p><span style="color: rgb(192, 0, 0);">继续跟踪代码，运行到DubboInvoker中，调用doInvoke方法，该方法中有如下的代码段，boolean isAsync = RpcUtils.isAsync(getUrl(), invocation)，这个isAsync方法具体声明如下，</span></p><p><span style="color: rgb(192, 0, 0);">public static boolean isAsync(URL url, Invocation inv) {</span></p><p><span style="color: rgb(192, 0, 0);">boolean isAsync ;</span></p><p><span style="color: rgb(192, 0, 0);">//如果Java代码中设置优先.</span></p><p><span style="color: rgb(192, 0, 0);">if (Boolean.TRUE.toString().equals(inv.getAttachment(Constants.ASYNC_KEY))) {</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; isAsync = true;</span></p><p><span style="color: rgb(192, 0, 0);">} else {</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; isAsync = url.getMethodParameter(getMethodName(inv), Constants.ASYNC_KEY, false);</span></p><p><span style="color: rgb(192, 0, 0);">}</span></p><p><span style="color: rgb(192, 0, 0);">return isAsync;</span></p><p><span style="color: rgb(192, 0, 0);">}</span></p><p><span style="color: rgb(192, 0, 0);">上面方法首先判断RpcInvocation的attachments中async=true是否成立，如果成立则这是一次异步调用，否则判断请求URL中async=true是否成立，如果成立则是一次异步调用，否则是一次同步调用，根据上面传递的参数，此时isAsync方法返回的是true，ServiceA同步调用ServiceB变成了异步调用，继续看下面的异步调用，代码段如下，</span></p><p><span style="color: rgb(192, 0, 0);">else if (isAsync) {</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; ResponseFuture future = currentClient.request(inv, timeout) ;</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future));</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; return new RpcResult();</span></p><p><span style="color: rgb(192, 0, 0);">}</span></p><p><span style="color: rgb(192, 0, 0);">这里直接返回了一个RpcResult对象，没有数据内容，所以到这里，这个案子也就破了，ServiceA想从响应中取目标数据得到的当然是null。再延伸一下，如果ServiceB再同步调用ServiceC，这是可以正常同步调用的，因为ServiceA调用完ServiceB后，ConsumerContextFilter的invoke方法会清除attachements，所以ServiceB可以正常同步调用ServiceC了。</span></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">对于上面的问题，解决办法有三个：</span></p><p><span style="color: rgb(192, 0, 0);">1.方法调用两次</span></p><p><span style="color: rgb(192, 0, 0);">ServiceA调用ServiceB的地方写两次一样的调用，这个方法原理就像ServiceB调用ServiceC一样，即清除attachements，这个方法最简单，但是可能对不了解的人来说，这块业务代码写重复了，会不小心删除掉，而且从写代码的角度来说，这个很鸡肋，所以不推荐。</span></p><p><span style="color: rgb(192, 0, 0);">2.修改Dubbo源码</span></p><p><span style="color: rgb(192, 0, 0);">修改AbstractInvoker第137行，改成每次都对async进行实际赋值，</span></p><p><span style="color: rgb(192, 0, 0);">boolean isAsync = getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false);</span></p><p><span style="color: rgb(192, 0, 0);">invocation.setAttachment(Constants.ASYNC_KEY, String.valueOf(isAsync));</span></p><p><span style="color: rgb(192, 0, 0);">3.自定义Filter</span></p><p><span style="color: rgb(192, 0, 0);">实现com.alibaba.dubbo.rpc.Filter，在RpcContext中清除这个async，</span></p><p><span style="color: rgb(192, 0, 0);">@Activate(group = {Constants.PROVIDER})</span></p><p><span style="color: rgb(192, 0, 0);">public class AsyncFilter implements Filter {</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; @Override</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; &nbsp; &nbsp; RpcContext.getContext().getAttachments().remove(Constants.ASYNC_KEY);</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; &nbsp; &nbsp; return invoker.invoke(invocation);</span></p><p><span style="color: rgb(192, 0, 0);">&nbsp; &nbsp; }</span></p><p><span style="color: rgb(192, 0, 0);">}</span></p><p><span style="color: rgb(192, 0, 0);">同时在src/main/resources/META-INF/dubbo/下添加com.alibaba.dubbo.rpc.Filter文件，内容文件如下：</span></p><p><span style="color: rgb(192, 0, 0);">asyncFilter=com.abc.filter.AsyncFilter</span></p><p><br/></p><p><span style="font-size: 20px;"><strong>Dubbo关闭报错和关闭不了问题</strong></span></p><p>解决方案：在容器shutdown的时候，显式调用下面方法：</p><p>import org.apache.zookeeper.server.ZooTrace;</p><p>import com.alibaba.dubbo.config.ProtocolConfig;</p><p><span style="color: rgb(0, 112, 192);">// 防止报zookeeper的类找不到</span></p><p><span style="color: rgb(0, 112, 192);">ZooTrace.logTraceMessage(logger, ZooTrace.getTextTraceLevel(), &quot;Run shutdown now.&quot;);</span></p><p><span style="color: rgb(192, 0, 0);">// 手动关停<span style="line-height: 32.4px;">dubbo</span></span></p><p><span style="color: rgb(192, 0, 0);">ProtocolConfig.destroyAll();</span></p><p><br/></p><p><br/></p><p><br/></p>