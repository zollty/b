---
layout: ue
title: 密码安全解决方案
category: 系统架构和设计
tags: 安全
keywords: "密码安全"
---

<p><br/></p><p><span style="font-size: 20px;">一、密码存储安全</span></p><p>不存储明文密码，也不存储密码的MD5（现在的技术可以破解MD5，不安全）。</p><p><br/></p><p>建议方案：采用加盐、<strong>不可逆</strong>的密码算法，并且使得同一个明文密码，<strong>每次加密结果都不一样</strong>。</p><p><br/></p><p><span style="font-size: 20px;">二、一般安全性措施</span></p><p>1、防止用户无限次尝试密码，暴力登录</p><p>方案举例：某个用户密码输错3次后，锁定该用户1分钟，如果输错10次，锁定2小时。</p><p><br/></p><p>2、日志脱敏</p><p>禁止把用户的明文密码 打印到日志中，或者显示在错误信息中。</p><p><br/></p><p>3、智能防盗分析</p><p>比如，记录用户每次的登录时间、次数、IP和地区等信息，智能分析这些信息，如果有异常及时采取措施。</p><p><br/></p><p><span style="font-size: 20px;">三、密码传输安全——使用HTTPS</span></p><p>通过HTTPS传输的数据，可以认为是安全的。</p><p><br/></p><p><span style="font-size: 20px;">四、密码传输安全——不使用HTTPS</span></p><p>由于网络传输不安全，数据容易被截取到，故应做好以下两方面的措施：<br/></p><p>1、防止密码明文传输；</p><p>2、防止加密后的密码，被轻易破解；</p><p><br/></p><p>假设攻击者可以进行网络抓包。它可以拿到加密后的密码、加密算法和加密的密钥。</p><p>但是，这个密码是一次性使用的，如果它再次访问，就无效。（具体来说，每次的密匙从后端获取，后端有记录、有过期时间，如果使用过一次，就不允许再用）</p><p><br/></p><p>由于攻击者不知道真实密码，而且每次加密后的密码不一样，没有规则，故攻击者无法猜测。</p><p>前端做成非对称加密，只有服务器端才能解密，攻击者即使知道算法也无法解密。</p><p><br/></p><p style="white-space: normal;">3、防重放攻击和中间人攻击</p><p style="white-space: normal;">至于防重放，关键是时间戳与签名。可以由后端发盐和时间戳和公钥，然后由js计算与服务器的时间差，等提交的时候提交一个与后端当前时间误差极小的时间戳和盐的公钥签名，后端验证时间戳误差在安全范围之内且当前时间戳大于上次请求的时间戳，然后签名一致即可。</p><p style="white-space: normal;"><br/></p><p style="white-space: normal;">http防中间人在理论上不可行，主要是http协议是无状态，中间人很容易就能伪造请求，并且前端想知道这个请求来自可信的后端是不可能。据我目前所了解的知识来说，ssl可以实现相对安全，前提是由人来确保根证书的可信列表以及识别浏览器给出的证书警告信息。</p><p style="white-space: normal;"><br/></p><p style="white-space: normal;">如果只是预防http协议下网络嗅探等直接暴露明文密码，只要实现了用户密码加密与防重放，其实就够了。</p><p><br/></p><p>参考资料：</p><p><a href="https://www.zhihu.com/question/20306241">https://www.zhihu.com/question/20306241</a> </p><p>1、对于敏感post，客户端首先发一个预备请求，这时服务器回应一个随机的token。客户端拿到后，用一种对称加密<span style="color: rgb(192, 0, 0);">（应该是非对称，zollty更正）</span>方式将(密码+token)加密，然后提交。服务器处理完后丢弃这个token。现在让我们看看监听者的情况。监听总是滞后的，由于服务器会在处理完后立即丢弃token，因此滞后的重复提交是无效的。假设监听者模拟这整个拿到token+提交的过程，由于他不知道加密算法，因此也无法成功。</p><p><br/></p><p><br/></p><p><br/></p>