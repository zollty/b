---
layout: ue
title: 高吞吐、高可用MQ对比分析
category: 中间件技术
tags: MQ,Kafka,RocketMQ
keywords: "MQ,Kafka,RocketMQ,RabbitMQ"
---

<p><strong>基本对比信息</strong><br/></p><table><tbody><tr class="firstRow"><td width="142" valign="top" style="word-break: break-all;"><br/></td><td width="142" valign="top" style="word-break: break-all;">ActiveMQ</td><td width="142" valign="top" style="word-break: break-all;">RabbitMQ</td><td width="142" valign="top" style="word-break: break-all;">RocketMQ</td><td width="142" valign="top" style="word-break: break-all;">Kafka</td><td width="142" valign="top" style="word-break: break-all;">ZeroMQ</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">吞吐量</td><td width="142" valign="top" style="word-break: break-all;">比RabbitMQ低</td><td width="142" valign="top" style="word-break: break-all;">2.6w/s（消息做持久化）</td><td width="142" valign="top" style="word-break: break-all;">11.6w/s</td><td width="142" valign="top" style="word-break: break-all;">17.3w/s</td><td width="142" valign="top" style="word-break: break-all;">29w/s</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">开发语言</td><td width="142" valign="top" style="word-break: break-all;">Java</td><td width="142" valign="top" style="word-break: break-all;">Erlang</td><td width="142" valign="top" style="word-break: break-all;">Java</td><td width="142" valign="top" style="word-break: break-all;">Scala/Java</td><td width="142" valign="top" style="word-break: break-all;">C</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">主要维护者</td><td width="142" valign="top" style="word-break: break-all;">Apache</td><td width="142" valign="top" style="word-break: break-all;">Mozilla/Spring</td><td width="142" valign="top" style="word-break: break-all;">Alibaba</td><td width="142" valign="top" style="word-break: break-all;">Apache</td><td width="142" valign="top" style="word-break: break-all;">iMatix，创始人已去世</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">成熟度</td><td width="142" valign="top" style="word-break: break-all;">成熟</td><td width="142" valign="top" style="word-break: break-all;">成熟</td><td width="142" valign="top" style="word-break: break-all;">开源版本不够成熟</td><td width="142" valign="top" style="word-break: break-all;">比较成熟</td><td width="142" valign="top" style="word-break: break-all;">只有C、PHP等版本成熟</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">文档和注释</td><td width="142" valign="top" style="word-break: break-all;">多</td><td width="142" valign="top" style="word-break: break-all;">多</td><td width="142" valign="top" style="word-break: break-all;">很少</td><td width="142" valign="top" style="word-break: break-all;">较少</td><td width="142" valign="top" style="word-break: break-all;">很少</td></tr><tr><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">订阅形式</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;"><span style="font-size: 16px; line-height: 28.8px; background-color: rgb(255, 255, 255);"></span>点对点(p2p)、广播（发布-订阅）</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;"><p>提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式</p><p><br/></p></td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">基于topic以及按照topic进行正则匹配的发布订阅模式</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">点对点(p2p)</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">持久化</td><td width="142" valign="top" style="word-break: break-all;">支持少量堆积</td><td width="142" valign="top" style="word-break: break-all;">支持少量堆积</td><td width="142" valign="top" style="word-break: break-all;">支持大量堆积</td><td width="142" valign="top" style="word-break: break-all;">支持大量堆积</td><td width="142" valign="top" style="word-break: break-all;">不支持</td></tr><tr><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">顺序消息</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">不支持<br/></td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">不支持</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">支持</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">支持</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">不支持</td></tr><tr><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">消息回溯</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">不支持</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">不支持</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">支持指定时间点的回溯</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">支持指定分区offset位置的回溯</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">不支持<br/></td></tr><tr><td width="142" valign="top" style="word-break: break-all;">性能稳定性</td><td width="142" valign="top" style="word-break: break-all;">好</td><td width="142" valign="top" style="word-break: break-all;">好</td><td width="142" valign="top" style="word-break: break-all;">一般</td><td width="142" valign="top" style="word-break: break-all;">较差</td><td width="142" valign="top" style="word-break: break-all;">很好</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">负载均衡</td><td width="142" valign="top" style="word-break: break-all;">可以支持</td><td width="142" valign="top" style="word-break: break-all;">可以支持</td><td width="142" valign="top" style="word-break: break-all;">支持较好</td><td width="142" valign="top" style="word-break: break-all;">支持很好</td><td width="142" valign="top" style="word-break: break-all;">不支持</td></tr><tr><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">集群方式</td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;"><span style="line-height: 1.8;">支持简单集群模式，比如&#39;主-备&#39;，</span><span style="line-height: 1.8;">对高级集群模式支持不好。</span></td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;"><p>支持简单集群，&#39;复制&#39;模式，<span style="line-height: 1.8;">对高级集群模式支持不好。</span></p></td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;"><p>常用 多对&#39;Master-Slave&#39; 模式，<span style="line-height: 1.8;">开源版本需手动切换Slave变成Master</span></p></td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;"><p>天然的‘Leader-Slave’无状态集群，<span style="line-height: 1.8;">每台服务器既是Master也是Slave</span></p></td><td valign="top" colspan="1" rowspan="1" style="word-break: break-all;">不支持</td></tr><tr><td width="142" valign="top" style="word-break: break-all;">管理界面</td><td width="142" valign="top" style="word-break: break-all;"><span style="font-size: 16px; line-height: 28.8px; background-color: rgb(255, 255, 255);">一般</span></td><td width="142" valign="top" style="word-break: break-all;"><span style="font-size: 16px; line-height: 28.8px; background-color: rgb(255, 255, 255);">较好</span></td><td width="142" valign="top" style="word-break: break-all;"><span style="font-size: 16px; line-height: 28.8px; background-color: rgb(255, 255, 255);">一般</span></td><td width="142" valign="top" style="word-break: break-all;"><span style="font-size: 16px; line-height: 28.8px; background-color: rgb(255, 255, 255);">无</span></td><td width="142" valign="top" style="word-break: break-all;"><span style="font-size: 16px; line-height: 28.8px; background-color: rgb(255, 255, 255);">无</span></td></tr></tbody></table><p><br/></p><p>而谈到消息系统的设计，就回避不了两个问题：</p><p>1、消息的顺序问题</p><p>2、消息的重复问题</p><p><br/></p><p>关于这两方面，RocketMQ的测试结果如下：</p><p><br/></p><p><strong>一、消息顺序读写</strong></p><p>参考文章：http://www.jianshu.com/p/453c6e7ff81c</p><p>1、常规的理解是：在同一个队列（分区）的消息是按顺序排列的。但测试结果如下：</p><p>单服务器单个线程的Producer异步生产数据，生产的数据都用同一个字符串做hash，数据都分配在同一台机器的同一个队列。</p><p>单服务器单Consumer配置1个或者10个线程一起消费，每次最多抓取1条或者1014条数据，结果：同一个线程同一批次取回来的数据，顺序却不一致。</p><p>例如，取回来的数据预期顺序是：12、13、14、15、16……但结果却是：13、14、15、16、12……</p><p>同一批次测试，所有环境都一样，有一定几率（大概15%）会出现该情况。</p><p>&nbsp;</p><p>原因：Producer异步生产数据会导致数据乱序。即使是单线程的Producer。</p><p>&nbsp;</p><p>解决方案：为保证生产的消息顺序一致，<span style="color: rgb(0, 32, 96);">Producer需采用同步发送数据，但是性能会大大下降（实测1851条/秒，同等情况下比kafka慢45%，不过一般情况下这性能也足够了）</span>。</p><p>&nbsp;</p><p><strong>二、消息不丢失、不存在重复发送</strong></p><p>根据阿里的测试结论，RocketMQ和Kafka在 消息不丢失 方面，做得差不多，<span style="color: rgb(0, 32, 96);">服务器基本上不会丢失数据</span>。结论如下：</p><p>1、在Broker进程被Kill的场景（在消息收发过程中，利用Kill -9 命令使Broker进程终止）， Kafka和RocketMQ都不丢消息，可靠性都比较高。</p><p>2、在宿主机掉电的场景，在“同步刷盘”策略下，Kafka与RocketMQ均能做到不丢消息，在“异步刷盘”策略下，Kafka和RMQ都无法保证掉电后不丢消息。</p><p>参考来源：http://jm.taobao.org/2016/04/28/kafka-vs-rocktemq-4/</p><p>&nbsp;</p><p>在 消息不重复 方面，RocketMQ和Kafka估计都差不多，在kill或者宕机时，<span style="color: rgb(0, 32, 96);">都会存在数据重复</span>，而且RocketMQ官方说明，RocketMQ无法保证数据不重复，建议通过业务手段来保证。</p><p><br/></p><p><br/></p><p><strong>实际应用场景分析（RocketMQ）</strong></p><p>&nbsp;</p><p>1、保证消息按顺序写入和读取</p><p>1)顺序写入（前提：单机，或者 集群但是每个节点来源数据不同）</p><p>原理：</p><p>&nbsp; 在同一个队列（分区）的消息是按顺序排列的。（跟Kafka一样，只不过kafka的分区为物理分区，rocketMQ的队列是逻辑分区）</p><p>故，要保证消息按顺序处理，必须把它们放在同一个队列中。</p><p>&nbsp;</p><p>实现方式：但producer同步发送数据，按orderid hash来区分队列存放数据。</p><p>&nbsp;</p><p>单线程版：RocketMQ使用单线程同步写入消息到topic里面，topic使用消息类型区分，appid用tags区分，可以在消息中添加orderid关键字。</p><p>例如：</p><p>Message(topic-&gt;&quot;abc&quot;, tags-&gt;&quot;appid11111&quot;, keys-&gt;&quot;M324343ef&quot;, content);</p><p>Message(topic-&gt;&quot;cdb&quot;, tags-&gt;&quot;appid33333&quot;, keys-&gt;&quot;M684343ef&quot;, content);</p><p>&nbsp;</p><p>多线程版：每个线程操作不同appId的数据。实测单机普通CPU多线程无益于提高producer的效率。（i7-CPU测试结果为：两线程比单线程提高36%，三线程比两线程提高12%，三线程CPU已爆满）</p><p>&nbsp;</p><p>2）按顺序消费</p><p>RocketMQ的消费方式有两种，一种是传统的自动化的push推模式（对应的DefaultMQPushConsumer），服务器端主动推送消息。另一种是pull拉模式（对应的DefaultMQPullConsumer），客户端从指定位置主动去服务器拉取数据。</p><p>RocketMQ 的 推 模式原理：源码分析（略）</p><p>问题：Consumer可以设置消费线程的数量，但是在顺序消费的模式（MessageListenerOrderly）下，多个消费线程对于同一队列的数据，无法并行运行，仍然是串行执行，以达到顺序处理数据的目的。对多个不同队列的数据，消费线程可以并行执行。</p><p>&nbsp;</p><p>例如：producer同步发送数据，按orderid hash来区分队列存放数据。假设一个topic，有999个orderid分配到999个队列，</p><p>假设consumer端有50个消费线程，那么这50个线程就可以并行的消费999个队列里面的数据。</p><p>&nbsp;</p><p>3）与kafka对比</p><p>顺序写入：kafka producer同步发送数据，按orderid hash来区分队列存放数据。假设一个topic，有999个orderid分配到8个分区，</p><p>顺序消费：kafka consumer都订阅所有topics，但是consumer线程受制于partition数量的限制，假设为8，那么最多8个线程并行消费数据，这8个线程并行的消费8个partition里面的数据。</p><p>&nbsp;</p><p>关键之处，kafka和rocketMQ的区别在于一个用物理分区来存放数据，一个按虚拟队列的存放数据，都能保证队列或分区里面数据的有序性。</p><p>据阿里中间件 官方给出的测试结论，RocketMQ虚拟队列的效率 高于kafka 物理分区的效率，当kafka的分区数大于8时，kafka性能快速下降，而rocketMQ支持1万队列而不会降低性能。</p><p>&nbsp;</p><p>集群模式：</p><p>假设有4台master的RocketMQ ，</p><p>每台RocketMQ 的consumer都订阅所有topic，</p><p>假设一个topic，有999个appid分配到999个队列，</p><p>假设每台RocketMQ consumer端有50个消费线程，那么这4*50=200个线程就可以并行的消费999个队列里面的数据。</p><p>&nbsp;</p><p>假设有4台broker的Kafka，</p><p>每台kafka的consumer都订阅所有topic，</p><p>假设一个topic，有999个orderid分配到8个分区，</p><p>总的consumer线程受制于partition数量的限制，假设为8，那么最多8个线程（4*2，每台broker2个线程）并行消费8个partition里面的数据。</p><p>&nbsp;</p><p>显然，RocketMQ 更占优势，如果kafka要达到RocketMQ 这种效果，需要扩展到200个分区才能使200个线程同时消费。</p><p>&nbsp;<span style="line-height: 1.8;">&nbsp;</span></p><p>&nbsp;</p><p><strong>开源版本RocketMQ存在的问题</strong></p><p>1、主从不能自动切换，导致了一系列小问题。</p><p>&nbsp; &nbsp; &nbsp;1）普通消息当主挂了，会拉取从上面的消息，最后如果主又活过来了，会导致重复消费（之前消费的进度在从上面）。</p><p>&nbsp; &nbsp; 2）主down，顺序消息不能写入，不能消费（顺序消费不能消费slave上面的消息）。顺序消息是写入特定的queue，这个queue所在的机器挂了，就不能写了，手动写入其他的queue，在业务来看，也是有问题。</p><p>2、rocketmq 对于消息重复的处理能力是不足且没有保障的，文档中也明确说明需要业务去重。</p><p>&nbsp;</p><p>3、对于指定位置消费，RocketMQ 的PushAPI比较低级，需要自己实现消费位置的保存、节点的拉取和维护等。</p><p>&nbsp;</p><p>Github上有300多个issues，坑很多，而且看评论，都没有及时解决。</p><p>&nbsp;</p><p>相比Kafka，在Apache下，有完善的测试，能看到存在的bug和fix状态，以及比较详细的说明。比如：</p><p>https://issues.apache.org/jira/browse/KAFKA-4189?jql=project%20%3D%20KAFKA%20AND%20resolution%20%3D%20Unresolved%20AND%20component%20%3D%20consumer%20ORDER%20BY%20priority%20DESC</p><p><br/></p><p><br/></p><p>推荐一篇关于RocketMQ非常棒的文章：</p><p>http://www.jianshu.com/p/453c6e7ff81c#</p>