---
layout: ue
title: ZooKeeper和Curator的使用
category: 中间件技术
tags: ZooKeeper,Curator
keywords: "ZooKeeper,Curator"
---

<p><strong><span style="font-size: 20px;">一、Zookeeper的一些概念和理解</span></strong></p><p><strong>ZooKeeper 节点类型</strong></p><p>ZooKeeper 节点是有生命周期的，这取决于节点的类型。在 ZooKeeper 中，节点类型可以分为持久节点（PERSISTENT ）、临时节点（EPHEMERAL），以及时序节点（SEQUENTIAL ），具体在节点创建过程中，一般是组合使用，可以生成以下 4 种节点类型。</p><p><br/></p><p>持久节点（PERSISTENT）</p><p>所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。</p><p><br/></p><p>持久顺序节点（PERSISTENT_SEQUENTIAL）</p><p>这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。</p><p><br/></p><p>临时节点（EPHEMERAL）</p><p>和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。</p><p><br/></p><p>临时顺序节点（EPHEMERAL_SEQUENTIAL）</p><p><br/></p><p><strong>关于Zookeeper和客户端的通信</strong></p><p>在实际的应用中，如果Client与Server之间的通信足够频繁，Session的维护就不需要其它额外的消息了。否则，ZooKeeper Client会每t/3 ms发一次心跳给Server，如果Client 2t/3 ms没收到来自Server的心跳回应，就会换到一个新的ZooKeeper Server上。这里t是用户配置的Session的超时时间。</p><p><br/></p><p>官方文档地址：</p><p><a href="http://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkWatches">http://zookeeper.apache.org/doc/current/</a></p><p><a href="http://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkWatches">http://zookeeper.apache.org/doc/current/zookeeperProgrammers.html</a></p><p><br/></p><p>二、ZooKeeper经验总结</p><p>1、使用<span style="line-height: 32.4px;">命令行</span>客户端</p><p>./zkCli.sh -server 127.0.0.1:2180</p><p><br/></p><p>2、启动和关闭</p><p>./zkServer.sh start</p><p><span style="line-height: 32.4px;">./zkServer.sh stop</span></p><p><br/></p><p>3、查看集群状态</p><p>zkServer.sh status</p><p><br/></p><p>关于zookeeper的watch用法，详细说明如下：</p><h2 class="h3" style="font-family: &quot;Trebuchet MS&quot;, verdana, arial, helvetica, sans-serif; font-weight: bold; margin: 22px 0px 3px; font-size: 17.92px; padding: 0px; color: rgb(0, 0, 0); line-height: normal; white-space: normal; background-color: rgb(255, 255, 255);">ZooKeeper Watches</h2><div class="section" style="font-family: Verdana, Helvetica, sans-serif; font-size: 12.8px; line-height: normal; white-space: normal; background-color: rgb(255, 255, 255);"><p style="line-height: 15.36px; margin-top: 0.5em; margin-bottom: 1em;">All of the read operations in ZooKeeper -&nbsp;<strong>getData()</strong>,&nbsp;<strong>getChildren()</strong>, and&nbsp;<strong>exists()</strong>&nbsp;- have the option of setting a watch as a side effect. Here is ZooKeeper&#39;s definition of a watch: a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes. There are three key points to consider in this definition of a watch:</p><ul style="padding: 0px 25px;" class=" list-paddingleft-2"><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;"><strong>One-time trigger（如果被节点被删除，再创建的节点需要重新绑定watcher）</strong></p><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">One watch event will be sent to the client when the data has changed. For example, if a client does a getData(&quot;/znode1&quot;, true) and later the data for /znode1 is changed or deleted, the client will get a watch event for /znode1. If /znode1 changes again, no watch event will be sent unless the client has done another read that sets a new watch.</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;"><strong>Sent to the client</strong></p><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">This implies that an event is on the way to the client, but may not reach the client before the successful return code to the change operation reaches the client that initiated the change. Watches are sent asynchronously异步&nbsp;to watchers. <span style="color: rgb(0, 176, 80);">ZooKeeper provides an ordering guarantee（有序的）: a client will never see a change for which it has set a watch until it first sees the watch event</span>. <span style="color: rgb(0, 176, 80);">Network delays or other factors may cause different clients to see watches and return codes from updates at different times</span>. The key point is that everything seen by the different clients will have a consistent order.</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;"><strong>The data for which the watch was set</strong></p><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">This refers to the different ways a node can change. It helps to think of <span style="color: rgb(0, 176, 80);">ZooKeeper as maintaining two lists of watches: data watches and child watches</span>. <span style="color: rgb(0, 176, 80);">getData() and exists() set data watches. getChildren() sets child watches.</span> Alternatively, it may help to think of watches being set according to the kind of data returned. getData() and exists() return information about the data of the node, whereas getChildren() returns a list of children. Thus, setData() will trigger data watches for the znode being set (assuming the set is successful). A successful create() will trigger a data watch for the znode being created and a child watch for the parent znode. A successful delete() will trigger both a data watch and a child watch (since there can be no more children) for a znode being deleted as well as a child watch for the parent znode.</p></li></ul><p style="line-height: 15.36px; margin-top: 0.5em; margin-bottom: 1em;">Watches are maintained locally at the ZooKeeper server to which the client is connected. This allows watches to be lightweight to set, maintain, and dispatch. When a client connects to a new server, the watch will be triggered for any session events. <span style="color: rgb(255, 0, 0);">Watches will not be received while disconnected from a server. When a client reconnects, any previously registered watches will be reregistered and triggered if needed（客户端重新连接上时，之前发生的watch事件将会触发）</span>. In general this all occurs transparently. <span style="color: rgb(255, 0, 0);">There is one case where a watch may be missed</span>: a watch for the existence of a znode not yet created will be missed if the znode is created and deleted while disconnected（如果在断开连接期间，watch的节点被创建又被删除，那么watch事件会丢失）.</p><a></a><h3 class="h4" style="font-family: &quot;Trebuchet MS&quot;, verdana, arial, helvetica, sans-serif; font-weight: bold; margin: 18px 0px 0px; font-size: 16.64px; padding: 0px;">Semantics of Watches</h3><p style="line-height: 15.36px; margin-top: 0.5em; margin-bottom: 1em;">We can set watches with the three calls that read the state of ZooKeeper: exists, getData, and getChildren. The following list details the events that a watch can trigger and the calls that enable them:</p><ul style="padding: 0px 25px;" class=" list-paddingleft-2"><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;"><strong>Created event:</strong></p><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">Enabled with a call to exists.</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;"><strong>Deleted event:</strong></p><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">Enabled with a call to exists, getData, and getChildren.</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;"><strong>Changed event:</strong></p><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">Enabled with a call to exists and getData.</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;"><strong>Child event:</strong></p><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">Enabled with a call to getChildren.</p></li></ul><a></a><h3 class="h4" style="font-family: &quot;Trebuchet MS&quot;, verdana, arial, helvetica, sans-serif; font-weight: bold; margin: 18px 0px 0px; font-size: 16.64px; padding: 0px;">What ZooKeeper Guarantees about Watches</h3><p style="line-height: 15.36px; margin-top: 0.5em; margin-bottom: 1em;">With regard to watches, ZooKeeper maintains these guarantees:</p><ul style="padding: 0px 25px;" class=" list-paddingleft-2"><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">Watches are ordered with respect to other events, other watches, and asynchronous replies. The ZooKeeper client libraries ensures that everything is dispatched in order.</p></li></ul><ul style="padding: 0px 25px;" class=" list-paddingleft-2"><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">A client will see a watch event for a znode it is watching before seeing the new data that corresponds to that znode.</p></li></ul><ul style="padding: 0px 25px;" class=" list-paddingleft-2"><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">The order of watch events from ZooKeeper corresponds to the order of the updates as seen by the ZooKeeper service.</p></li></ul><a></a><h3 class="h4" style="font-family: &quot;Trebuchet MS&quot;, verdana, arial, helvetica, sans-serif; font-weight: bold; margin: 18px 0px 0px; font-size: 16.64px; padding: 0px;">Things to Remember about Watches</h3><ul style="padding: 0px 25px;" class=" list-paddingleft-2"><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">Watches are one time triggers; if you get a watch event and you want to get notified of future changes, you must set another watch.</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">Because watches are one time triggers and <span style="color: rgb(0, 176, 80); background-color: rgb(235, 241, 221);">there is latency between getting the event and sending a new request to get a watch you cannot reliably see every change that happens to a node in ZooKeeper. Be prepared to handle the case where the znode changes multiple times between getting the event and setting the watch again.也就是说在两次watch之间node实际上可能发生多次变更&nbsp;</span>&nbsp;(You may not care, but at least realize it may happen.)</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">A watch object, or function/context pair, will only be triggered once for a given notification. For example, if the same watch object is registered for an exists and a getData call for the same file and that file is then deleted, the watch object would only be invoked once with the deletion notification for the file.</p></li><li><p>&nbsp;</p></li><li><p style="line-height: 15.36px; margin-bottom: 0px; padding: 0px;">When you disconnect from a server (for example, when the server fails), you will not get any watches until the connection is reestablished. For this reason session events are sent to all outstanding watch handlers. Use session events to go into a safe mode: you will not be receiving events while disconnected, so your process should act conservatively in that mode.（谨慎处理与server断开连接的情况）</p></li></ul></div><p><br/></p><p><br/></p><p>三、Zookeeper集群</p><p>步骤：<br/></p><p>1、conf/zoo_sample.cfg文件复制一份，并更名为zoo.cfg</p><p>2、配置zoo.cfg</p><p>3、根据配置的dataDir和dataLogDir变量创建相应的目录</p><p>4、在dataDir目录下创建一个myid文件，写入按照zoo.cfg文件的server.A中A的数值，比如</p><p>server.1=172.16.1.164:2888:3888</p><p>server.2=172.16.1.165:2888:3888</p><p>server.3=172.16.1.166:2888:3888</p><p>那么在myid文件中写入1，或者2或者3。</p><p><br/></p><p>集群配置实例如下，供参考：</p><pre class="brush:plain;toolbar:false">#&nbsp;The&nbsp;number&nbsp;of&nbsp;milliseconds&nbsp;of&nbsp;each&nbsp;tick
tickTime=2000
#&nbsp;The&nbsp;number&nbsp;of&nbsp;ticks&nbsp;that&nbsp;the&nbsp;initial&nbsp;
#&nbsp;synchronization&nbsp;phase&nbsp;can&nbsp;take
initLimit=10
#&nbsp;The&nbsp;number&nbsp;of&nbsp;ticks&nbsp;that&nbsp;can&nbsp;pass&nbsp;between&nbsp;
#&nbsp;sending&nbsp;a&nbsp;request&nbsp;and&nbsp;getting&nbsp;an&nbsp;acknowledgement
syncLimit=5
#&nbsp;the&nbsp;directory&nbsp;where&nbsp;the&nbsp;snapshot&nbsp;is&nbsp;stored.
#&nbsp;do&nbsp;not&nbsp;use&nbsp;/tmp&nbsp;for&nbsp;storage,&nbsp;/tmp&nbsp;here&nbsp;is&nbsp;just&nbsp;
#&nbsp;example&nbsp;sakes.
dataDir=/home/kafka/zookeeper/data
#&nbsp;the&nbsp;port&nbsp;at&nbsp;which&nbsp;the&nbsp;clients&nbsp;will&nbsp;connect
clientPort=2181
#&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;client&nbsp;connections.
#&nbsp;increase&nbsp;this&nbsp;if&nbsp;you&nbsp;need&nbsp;to&nbsp;handle&nbsp;more&nbsp;clients
#maxClientCnxns=60
#
#&nbsp;Be&nbsp;sure&nbsp;to&nbsp;read&nbsp;the&nbsp;maintenance&nbsp;section&nbsp;of&nbsp;the&nbsp;
#&nbsp;administrator&nbsp;guide&nbsp;before&nbsp;turning&nbsp;on&nbsp;autopurge.
#
#&nbsp;http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
#
#&nbsp;The&nbsp;number&nbsp;of&nbsp;snapshots&nbsp;to&nbsp;retain&nbsp;in&nbsp;dataDir
#autopurge.snapRetainCount=3
#&nbsp;Purge&nbsp;task&nbsp;interval&nbsp;in&nbsp;hours
#&nbsp;Set&nbsp;to&nbsp;&quot;0&quot;&nbsp;to&nbsp;disable&nbsp;auto&nbsp;purge&nbsp;feature
#autopurge.purgeInterval=1
server.1=172.16.1.164:2888:3888
server.2=172.16.1.165:2888:3888
server.3=172.16.1.166:2888:3888</pre><p><br/></p><p>具体参见官方文档：</p><p><a href="http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_zkMulitServerSetup">http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_zkMulitServerSetup</a> </p><p><br/></p><p><br/></p><p style="line-height: 32.4px; white-space: normal;"><strong><span style="font-size: 20px;">四、Zookeeper典型应用</span></strong></p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><strong>参考官方文档：</strong></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://zookeeper.apache.org/doc/current/recipes.html">http://zookeeper.apache.org/doc/current/recipes.html</a> </p><p style="line-height: 32.4px; white-space: normal;"><br/></p><ul class="minitoc list-paddingleft-2" style="list-style-image: url(&quot;images/current.gif&quot;); margin-top: 0.5em; margin-bottom: 0.5em; padding: 0px 25px; font-family: Verdana, Helvetica, sans-serif; font-size: 12.8px; line-height: normal; white-space: normal; background-color: rgb(255, 255, 255);"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_outOfTheBox" style="color: rgb(0, 153, 153);">Out of the Box Applications: Name Service, Configuration, Group Membership</a></p></li><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_eventHandles" style="color: rgb(0, 153, 153);">Barriers</a></p></li><ul class="minitoc list-paddingleft-2" style="list-style-type: square;"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_doubleBarriers" style="color: rgb(0, 153, 153);">Double Barriers</a></p></li></ul><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_Queues" style="color: rgb(0, 153, 153);">Queues</a></p></li><ul class="minitoc list-paddingleft-2" style="list-style-type: square;"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_priorityQueues" style="color: rgb(0, 153, 153);">Priority Queues</a></p></li></ul><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_Locks" style="color: rgb(0, 153, 153);">Locks</a></p></li><ul class="minitoc list-paddingleft-2" style="list-style-type: square;"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#Shared+Locks" style="color: rgb(0, 153, 153);">Shared Locks</a></p></li><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recoverableSharedLocks" style="color: rgb(0, 153, 153);">Recoverable Shared Locks</a></p></li></ul><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_twoPhasedCommit" style="color: rgb(0, 153, 153);">Two-phased Commit</a></p></li><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_leaderElection" style="color: rgb(0, 153, 153);">Leader Election</a></p></li></ul><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><strong>Barriers（障碍）</strong></p><p style="line-height: 32.4px; white-space: normal;">Distributed systems use barriers to block processing of a set of nodes until a condition is met at which time all the nodes are allowed to proceed.</p><p style="line-height: 32.4px; white-space: normal;"><strong>Double Barriers（双屏障）</strong></p><p style="line-height: 32.4px; white-space: normal;">Double barriers enable clients to synchronize the beginning and the end of a computation. When enough processes have joined the barrier, processes start their computation and leave the barrier once they have finished.&nbsp;</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><strong>Distributed Queues（分布式队列）</strong></p><p style="line-height: 32.4px; white-space: normal;">略</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><strong>Distributed Locks（分布式锁，排它锁）</strong></p><p style="line-height: 32.4px; white-space: normal;">At any snapshot in time no two clients think they hold the same lock.</p><p style="line-height: 32.4px; white-space: normal;"><strong>Shared Locks（共享锁，又称为读锁，可以查看，但无法修改和删除的一种数据锁）</strong></p><p style="line-height: 32.4px; white-space: normal;">略</p><p style="line-height: 32.4px; white-space: normal;"><strong>Recoverable Shared Locks（可撤销的共享锁）</strong></p><p style="line-height: 32.4px; white-space: normal;">略</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><strong>Two-phased Commit（两阶段提交协议）</strong></p><p style="line-height: 32.4px; white-space: normal;">A two-phase commit protocol is an algorithm that lets all clients in a distributed system agree either to commit a transaction or abort.</p><p style="line-height: 32.4px; white-space: normal;">两阶段提交协议可以保证数据的强一致性，许多分布式关系型数据管理系统采用此协议来完成分布式事务。它是协调所有分布式原子事务参与者，并决定提交或取消（回滚）的分布式算法。</p><p style="line-height: 32.4px; white-space: normal;">在两阶段提交协议中，系统一般包含两类机器（或节点）：一类为协调者（coordinator），通常一个系统中只有一个；另一类为事务参与者（participants，cohorts或workers），一般包含多个，在数据存储系统中可以理解为数据副本的个数。协议中假设每个节点都会记录写前日志（write-ahead log）并持久性存储，即使节点发生故障日志也不会丢失。协议中同时假设节点不会发生永久性故障而且任意两个节点都可以互相通信。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">当事务的最后一步完成之后，协调器执行协议，参与者根据本地事务能够成功完成回复同意提交事务或者回滚事务。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">顾名思义，两阶段提交协议由两个阶段组成。在正常的执行下，这两个阶段的执行过程如下所述：</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">阶段1：请求阶段（commit-request phase，或称表决阶段，voting phase）</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">阶段2：提交阶段（commit phase）</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。参与者在接收到协调者发来的消息后将执行响应的操作。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><strong>Leader Election（Leader 选举）</strong></p><p>略</p><p><br/></p><p><strong>具体应用可以使用&nbsp;<span style="color: rgb(255, 0, 0);">Curator </span>的实现：</strong><a href="http://curator.apache.org/" style="line-height: 1.8;">http://curator.apache.org/</a></p><div><p><br/></p><p><span style="font-size: 20px;"><strong>五、Curator相关经验</strong></span></p><p><br/></p><p><br/></p><p><strong>监听与zookeeper的连接状态：<span style="line-height: 1.8;">ConnectionStateListener&nbsp;</span></strong></p><p>具体的状态有5种：</p><p>CONNECTED</p><p>SUSPENDED（挂起）</p><p>RECONNECTED（挂起或者丢失连接后重新连接）</p><p>LOST（挂起后重试超时，客户端认为与zk服务器的连接丢失）</p><p>READONLY</p><p>&nbsp;注意： The meaning of LOST has changed since Curator 3.0.0. Prior to 3.0.0 LOST only meant that the retry policy had expired.</p><p><br/></p><p style="line-height: 32.4px; white-space: normal;">具体用法参见官方文档：</p><p style="line-height: 32.4px; white-space: normal;"><a href="http://curator.apache.org/curator-recipes/index.html">http://curator.apache.org/curator-recipes/index.html</a></p><p style="line-height: 32.4px; white-space: normal;">下面列出它的所有功能：</p><p style="color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 16px; line-height: 22px; white-space: normal; background-color: rgb(255, 255, 255);">Curator implements all of the recipes listed on the ZooKeeper recipes doc (except two phase commit). Click on the recipe name below for detailed documentation. NOTE: Most Curator recipes will autocreate parent nodes of paths given to the recipe as CreateMode.CONTAINER. Also, see&nbsp;<a class="externalLink" href="https://cwiki.apache.org/confluence/display/CURATOR/TN7" style="color: rgb(0, 53, 172); padding-right: 18px; background-image: url(&quot;../images/application-certificate.png&quot;); background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: right center; background-repeat: no-repeat;">Tech Note 7</a>&nbsp;regarding &quot;Curator Recipes Own Their ZNode/Paths&quot;.</p><table class="table table-striped" width="1219"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);"><strong>Elections</strong></th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/leader-latch.html" style="color: rgb(0, 53, 172);">Leader Latch</a>&nbsp;- In distributed computing, leader election is the process of designating a single process as the organizer of some task distributed among several computers (nodes). Before the task is begun, all network nodes are unaware which node will serve as the &quot;leader,&quot; or coordinator, of the task. After a leader election algorithm has been run, however, each node throughout the network recognizes a particular, unique node as the task leader.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/leader-election.html" style="color: rgb(0, 53, 172);">Leader Election</a>&nbsp;- Initial Curator leader election recipe.</td></tr></tbody></table><table class="table table-striped" width="1219"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);"><strong>Locks</strong></th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/shared-reentrant-lock.html" style="color: rgb(0, 53, 172);">Shared Reentrant Lock</a>&nbsp;- Fully distributed locks that are globally synchronous, meaning at any snapshot in time no two clients think they hold the same lock.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/shared-lock.html" style="color: rgb(0, 53, 172);">Shared Lock</a>&nbsp;- Similar to Shared Reentrant Lock but not reentrant.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/shared-reentrant-read-write-lock.html" style="color: rgb(0, 53, 172);">Shared Reentrant Read Write Lock</a>&nbsp;- A re-entrant read/write mutex that works across JVMs. A read write lock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader processes, so long as there are no writers. The write lock is exclusive.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/shared-semaphore.html" style="color: rgb(0, 53, 172);">Shared Semaphore</a>&nbsp;- A counting semaphore that works across JVMs. All processes in all JVMs that use the same lock path will achieve an inter-process limited set of leases. Further, this semaphore is mostly &quot;fair&quot; - each user will get a lease in the order requested (from ZK&#39;s point of view).</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/multi-shared-lock.html" style="color: rgb(0, 53, 172);">Multi Shared Lock</a>&nbsp;- A container that manages multiple locks as a single entity. When acquire() is called, all the locks are acquired. If that fails, any paths that were acquired are released. Similarly, when release() is called, all locks are released (failures are ignored).</td></tr></tbody></table><table class="table table-striped" width="1219"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);"><strong>Barriers</strong></th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/barrier.html" style="color: rgb(0, 53, 172);">Barrier</a>&nbsp;- Distributed systems use barriers to block processing of a set of nodes until a condition is met at which time all the nodes are allowed to proceed.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/double-barrier.html" style="color: rgb(0, 53, 172);">Double Barrier</a>&nbsp;- Double barriers enable clients to synchronize the beginning and the end of a computation. When enough processes have joined the barrier, processes start their computation and leave the barrier once they have finished.</td></tr></tbody></table><table class="table table-striped" width="1219"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);"><strong>Counters</strong></th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/shared-counter.html" style="color: rgb(0, 53, 172);">Shared Counter</a>&nbsp;- Manages a shared integer. All clients watching the same path will have the up-to-date value of the shared integer (considering ZK&#39;s normal consistency guarantees).</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/distributed-atomic-long.html" style="color: rgb(0, 53, 172);">Distributed Atomic Long</a>&nbsp;- A counter that attempts atomic increments. It first tries using optimistic locking. If that fails, an optional InterProcessMutex is taken. For both optimistic and mutex, a retry policy is used to retry the increment.</td></tr></tbody></table><table class="table table-striped" width="1219"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);"><strong>Caches</strong></th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/path-cache.html" style="color: rgb(0, 53, 172);">Path Cache</a>&nbsp;- A Path Cache is used to watch a ZNode. Whenever a child is added, updated or removed, the Path Cache will change its state to contain the current set of children, the children&#39;s data and the children&#39;s state. Path caches in the Curator Framework are provided by the PathChildrenCache class. Changes to the path are passed to registered PathChildrenCacheListener instances.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/node-cache.html" style="color: rgb(0, 53, 172);">Node Cache</a>&nbsp;- A utility that attempts to keep the data from a node locally cached. This class will watch the node, respond to update/create/delete events, pull down the data, etc. You can register a listener that will get notified when changes occur.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/tree-cache.html" style="color: rgb(0, 53, 172);">Tree Cache</a>&nbsp;- A utility that attempts to keep all data from all children of a ZK path locally cached. This class will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can register a listener that will get notified when changes occur.</td></tr></tbody></table><table class="table table-striped" width="1219"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);"><strong>Nodes</strong></th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/persistent-ephemeral-node.html" style="color: rgb(0, 53, 172);">Persistent Ephemeral Node</a>&nbsp;- An ephemeral node that attempts to stay present in ZooKeeper, even through connection and session interruptions.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/group-member.html" style="color: rgb(0, 53, 172);">Group Member</a>&nbsp;- Group membership management. Adds this instance into a group and keeps a cache of members in the group.</td></tr></tbody></table><table class="table table-striped" width="1219"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);"><strong>Queues</strong></th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/distributed-queue.html" style="color: rgb(0, 53, 172);">Distributed Queue</a>&nbsp;- An implementation of the Distributed Queue ZK recipe. Items put into the queue are guaranteed to be ordered (by means of ZK&#39;s PERSISTENTSEQUENTIAL node). If a single consumer takes items out of the queue, they will be ordered FIFO. If ordering is important, use a LeaderSelector to nominate a single consumer.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/distributed-id-queue.html" style="color: rgb(0, 53, 172);">Distributed Id Queue</a>&nbsp;- A version of DistributedQueue that allows IDs to be associated with queue items. Items can then be removed from the queue if needed.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/distributed-priority-queue.html" style="color: rgb(0, 53, 172);">Distributed Priority Queue</a>&nbsp;- An implementation of the Distributed Priority Queue ZK recipe.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/distributed-delay-queue.html" style="color: rgb(0, 53, 172);">Distributed Delay Queue</a>&nbsp;- An implementation of a Distributed Delay Queue.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/simple-distributed-queue.html" style="color: rgb(0, 53, 172);">Simple Distributed Queue</a>&nbsp;- A drop-in replacement for the DistributedQueue that comes with the ZK distribution.</td></tr></tbody></table><p><br/></p><p style="line-height: 32.4px; white-space: normal;"><span style="font-size: 20px;"><span style="font-weight: 700;">Zookeeper学习资料</span></span></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a></p><p style="line-height: 32.4px; white-space: normal;"><a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index">https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index</a></p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">zookeeper原理</p><p style="line-height: 32.4px; white-space: normal;"><a href="http://cailin.iteye.com/blog/2014486">http://cailin.iteye.com/blog/2014486</a></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://www.oschina.net/question/928033_84720">http://www.oschina.net/question/928033_84720</a></p><p style="line-height: 32.4px; white-space: normal;">zookeeper入门</p><p style="line-height: 32.4px; white-space: normal;"><a href="http://blackproof.iteye.com/blog/2039040">http://blackproof.iteye.com/blog/2039040</a></p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">zookeeper学习记录(二)</p><p style="line-height: 32.4px; white-space: normal;"><a href="http://agapple.iteye.com/blog/1112032">http://agapple.iteye.com/blog/1112032</a></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://agapple.iteye.com/blog/1292129">http://agapple.iteye.com/blog/1292129</a></p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://zookeeper.apache.org/doc/current/">http://zookeeper.apache.org/doc/current/</a></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://zookeeper.apache.org/doc/current/javaExample.html">http://zookeeper.apache.org/doc/current/javaExample.html</a></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/">http://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://www.jdon.com/artichect/zookeeper.html">http://www.jdon.com/artichect/zookeeper.html</a></p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">zookeeper节点Watch机制实例展示:</p><p style="line-height: 32.4px; white-space: normal;"><a href="http://www.tuicool.com/articles/BFFvqeY">http://www.tuicool.com/articles/BFFvqeY</a></p><p style="line-height: 32.4px; white-space: normal;">ZooKeeper示例 实时更新server列表:</p><p style="line-height: 32.4px; white-space: normal;"><a href="http://coolxing.iteye.com/blog/1871520/">http://coolxing.iteye.com/blog/1871520/</a></p><p><br/></p></div>