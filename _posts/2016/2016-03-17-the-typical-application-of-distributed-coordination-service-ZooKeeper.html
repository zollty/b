---
layout: ue
title: 分布式协调服务ZooKeeper的典型应用
category: 中间件技术
tags: ZooKeeper
keywords: "ZooKeeper,分布式"
---

<p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;"><span style="font-size: 20px;">Zookeeper典型应用</span></span></p><p style="line-height: 32.4px; white-space: normal;"><span style="line-height: 1.8;"><br/></span></p><p style="line-height: 32.4px; white-space: normal;"><span style="line-height: 1.8;">参考官方文档：</span><br/></p><p style="line-height: 32.4px; white-space: normal;"><a href="http://zookeeper.apache.org/doc/current/recipes.html">http://zookeeper.apache.org/doc/current/recipes.html</a></p><ul class="minitoc list-paddingleft-2" style="margin-top: 0.5em; margin-bottom: 0.5em; width: 929.094px; padding: 0px 25px; white-space: normal; list-style-image: url(&quot;images/current.gif&quot;); font-family: Verdana, Helvetica, sans-serif; font-size: 12.8px; line-height: normal; background-color: rgb(255, 255, 255);"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_outOfTheBox" style="color: rgb(0, 153, 153);">Out of the Box Applications: Name Service, Configuration, Group Membership</a></p></li><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_eventHandles" style="color: rgb(0, 153, 153);">Barriers</a></p></li><ul class="minitoc list-paddingleft-2" style="list-style-type: square;"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_doubleBarriers" style="color: rgb(0, 153, 153);">Double Barriers</a></p></li></ul><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_Queues" style="color: rgb(0, 153, 153);">Queues</a></p></li><ul class="minitoc list-paddingleft-2" style="list-style-type: square;"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_priorityQueues" style="color: rgb(0, 153, 153);">Priority Queues</a></p></li></ul><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_Locks" style="color: rgb(0, 153, 153);">Locks</a></p></li><ul class="minitoc list-paddingleft-2" style="list-style-type: square;"><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#Shared+Locks" style="color: rgb(0, 153, 153);">Shared Locks</a></p></li><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recoverableSharedLocks" style="color: rgb(0, 153, 153);">Recoverable Shared Locks</a></p></li></ul><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_twoPhasedCommit" style="color: rgb(0, 153, 153);">Two-phased Commit</a></p></li><li><p><a href="http://zookeeper.apache.org/doc/current/recipes.html#sc_leaderElection" style="color: rgb(0, 153, 153);">Leader Election</a></p></li></ul><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700; line-height: 32.4px;"><br/></span></p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700; line-height: 32.4px;">Barriers（障碍）</span><br/></p><p style="line-height: 32.4px; white-space: normal;">Distributed systems use barriers to block processing of a set of nodes until a condition is met at which time all the nodes are allowed to proceed.</p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">Double Barriers（双屏障）</span></p><p style="line-height: 32.4px; white-space: normal;">Double barriers enable clients to synchronize the beginning and the end of a computation. When enough processes have joined the barrier, processes start their computation and leave the barrier once they have finished.&nbsp;</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">Distributed Queues（分布式队列）</span></p><p style="line-height: 32.4px; white-space: normal;">略</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">Distributed Locks（分布式锁，排它锁）</span></p><p style="line-height: 32.4px; white-space: normal;">At any snapshot in time no two clients think they hold the same lock.</p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">Shared Locks（共享锁，又称为读锁，可以查看，但无法修改和删除的一种数据锁）</span></p><p style="line-height: 32.4px; white-space: normal;">略</p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">Recoverable Shared Locks（可撤销的共享锁）</span></p><p style="line-height: 32.4px; white-space: normal;">略</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">Two-phased Commit（两阶段提交协议）</span></p><p style="line-height: 32.4px; white-space: normal;">A two-phase commit protocol is an algorithm that lets all clients in a distributed system agree either to commit a transaction or abort.</p><p style="line-height: 32.4px; white-space: normal;">两阶段提交协议可以保证数据的强一致性，许多分布式关系型数据管理系统采用此协议来完成分布式事务。它是协调所有分布式原子事务参与者，并决定提交或取消（回滚）的分布式算法。</p><p style="line-height: 32.4px; white-space: normal;">在两阶段提交协议中，系统一般包含两类机器（或节点）：一类为协调者（coordinator），通常一个系统中只有一个；另一类为事务参与者（participants，cohorts或workers），一般包含多个，在数据存储系统中可以理解为数据副本的个数。协议中假设每个节点都会记录写前日志（write-ahead log）并持久性存储，即使节点发生故障日志也不会丢失。协议中同时假设节点不会发生永久性故障而且任意两个节点都可以互相通信。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">当事务的最后一步完成之后，协调器执行协议，参与者根据本地事务能够成功完成回复同意提交事务或者回滚事务。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">顾名思义，两阶段提交协议由两个阶段组成。在正常的执行下，这两个阶段的执行过程如下所述：</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">阶段1：请求阶段（commit-request phase，或称表决阶段，voting phase）</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">阶段2：提交阶段（commit phase）</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;">在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。参与者在接收到协调者发来的消息后将执行响应的操作。</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">Leader Election（Leader 选举）</span></p><p style="line-height: 32.4px; white-space: normal;">略</p><p style="line-height: 32.4px; white-space: normal;"><br/></p><p style="line-height: 32.4px; white-space: normal;"><span style="font-weight: 700;">具体应用可以使用&nbsp;<span style="color: rgb(255, 0, 0);">Curator&nbsp;</span>的实现</span></p><p style="line-height: 32.4px; white-space: normal;"><span style="line-height: 32.4px;">具体用法参见官方文档：</span><br/></p><div style="line-height: 32.4px; white-space: normal;"><p style="line-height: 32.4px;"><a href="http://curator.apache.org/curator-recipes/index.html">http://curator.apache.org/curator-recipes/index.html</a></p><p style="line-height: 32.4px;">下面列出它的所有功能：</p><p style="color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 16px; line-height: 22px; background-color: rgb(255, 255, 255);">Curator implements all of the recipes listed on the ZooKeeper recipes doc (except two phase commit). Click on the recipe name below for detailed documentation. NOTE: Most Curator recipes will autocreate parent nodes of paths given to the recipe as CreateMode.CONTAINER. Also, see&nbsp;<a class="externalLink" href="https://cwiki.apache.org/confluence/display/CURATOR/TN7" style="color: rgb(0, 53, 172); padding-right: 18px; background-image: url(&quot;../images/application-certificate.png&quot;); background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: right center; background-repeat: no-repeat;">Tech Note 7</a>&nbsp;regarding &quot;Curator Recipes Own Their ZNode/Paths&quot;.</p><table class="table table-striped" width="978"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);">Elections</th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/leader-latch.html" style="color: rgb(0, 53, 172);">Leader Latch</a>&nbsp;- In distributed computing, leader election is the process of designating a single process as the organizer of some task distributed among several computers (nodes). Before the task is begun, all network nodes are unaware which node will serve as the &quot;leader,&quot; or coordinator, of the task. After a leader election algorithm has been run, however, each node throughout the network recognizes a particular, unique node as the task leader.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/leader-election.html" style="color: rgb(0, 53, 172);">Leader Election</a>&nbsp;- Initial Curator leader election recipe.</td></tr></tbody></table><table class="table table-striped" width="978"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);">Locks</th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/shared-reentrant-lock.html" style="color: rgb(0, 53, 172);">Shared Reentrant Lock</a>&nbsp;- Fully distributed locks that are globally synchronous, meaning at any snapshot in time no two clients think they hold the same lock.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/shared-lock.html" style="color: rgb(0, 53, 172);">Shared Lock</a>&nbsp;- Similar to Shared Reentrant Lock but not reentrant.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/shared-reentrant-read-write-lock.html" style="color: rgb(0, 53, 172);">Shared Reentrant Read Write Lock</a>&nbsp;- A re-entrant read/write mutex that works across JVMs. A read write lock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader processes, so long as there are no writers. The write lock is exclusive.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/shared-semaphore.html" style="color: rgb(0, 53, 172);">Shared Semaphore</a>&nbsp;- A counting semaphore that works across JVMs. All processes in all JVMs that use the same lock path will achieve an inter-process limited set of leases. Further, this semaphore is mostly &quot;fair&quot; - each user will get a lease in the order requested (from ZK&#39;s point of view).</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/multi-shared-lock.html" style="color: rgb(0, 53, 172);">Multi Shared Lock</a>&nbsp;- A container that manages multiple locks as a single entity. When acquire() is called, all the locks are acquired. If that fails, any paths that were acquired are released. Similarly, when release() is called, all locks are released (failures are ignored).</td></tr></tbody></table><table class="table table-striped" width="978"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);">Barriers</th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/barrier.html" style="color: rgb(0, 53, 172);">Barrier</a>&nbsp;- Distributed systems use barriers to block processing of a set of nodes until a condition is met at which time all the nodes are allowed to proceed.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/double-barrier.html" style="color: rgb(0, 53, 172);">Double Barrier</a>&nbsp;- Double barriers enable clients to synchronize the beginning and the end of a computation. When enough processes have joined the barrier, processes start their computation and leave the barrier once they have finished.</td></tr></tbody></table><table class="table table-striped" width="978"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);">Counters</th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/shared-counter.html" style="color: rgb(0, 53, 172);">Shared Counter</a>&nbsp;- Manages a shared integer. All clients watching the same path will have the up-to-date value of the shared integer (considering ZK&#39;s normal consistency guarantees).</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/distributed-atomic-long.html" style="color: rgb(0, 53, 172);">Distributed Atomic Long</a>&nbsp;- A counter that attempts atomic increments. It first tries using optimistic locking. If that fails, an optional InterProcessMutex is taken. For both optimistic and mutex, a retry policy is used to retry the increment.</td></tr></tbody></table><table class="table table-striped" width="978"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);">Caches</th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/path-cache.html" style="color: rgb(0, 53, 172);">Path Cache</a>&nbsp;- A Path Cache is used to watch a ZNode. Whenever a child is added, updated or removed, the Path Cache will change its state to contain the current set of children, the children&#39;s data and the children&#39;s state. Path caches in the Curator Framework are provided by the PathChildrenCache class. Changes to the path are passed to registered PathChildrenCacheListener instances.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/node-cache.html" style="color: rgb(0, 53, 172);">Node Cache</a>&nbsp;- A utility that attempts to keep the data from a node locally cached. This class will watch the node, respond to update/create/delete events, pull down the data, etc. You can register a listener that will get notified when changes occur.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/tree-cache.html" style="color: rgb(0, 53, 172);">Tree Cache</a>&nbsp;- A utility that attempts to keep all data from all children of a ZK path locally cached. This class will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can register a listener that will get notified when changes occur.</td></tr></tbody></table><table class="table table-striped" width="978"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);">Nodes</th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/persistent-ephemeral-node.html" style="color: rgb(0, 53, 172);">Persistent Ephemeral Node</a>&nbsp;- An ephemeral node that attempts to stay present in ZooKeeper, even through connection and session interruptions.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/group-member.html" style="color: rgb(0, 53, 172);">Group Member</a>&nbsp;- Group membership management. Adds this instance into a group and keeps a cache of members in the group.</td></tr></tbody></table><table class="table table-striped" width="978"><tbody><tr class="a firstRow"><th style="line-height: 20px; background-color: rgb(249, 249, 249);">Queues</th></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/distributed-queue.html" style="color: rgb(0, 53, 172);">Distributed Queue</a>&nbsp;- An implementation of the Distributed Queue ZK recipe. Items put into the queue are guaranteed to be ordered (by means of ZK&#39;s PERSISTENTSEQUENTIAL node). If a single consumer takes items out of the queue, they will be ordered FIFO. If ordering is important, use a LeaderSelector to nominate a single consumer.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/distributed-id-queue.html" style="color: rgb(0, 53, 172);">Distributed Id Queue</a>&nbsp;- A version of DistributedQueue that allows IDs to be associated with queue items. Items can then be removed from the queue if needed.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/distributed-priority-queue.html" style="color: rgb(0, 53, 172);">Distributed Priority Queue</a>&nbsp;- An implementation of the Distributed Priority Queue ZK recipe.</td></tr><tr class="a"><td style="line-height: 20px; background-color: rgb(249, 249, 249);"><a href="http://curator.apache.org/curator-recipes/distributed-delay-queue.html" style="color: rgb(0, 53, 172);">Distributed Delay Queue</a>&nbsp;- An implementation of a Distributed Delay Queue.</td></tr><tr class="b"><td style="line-height: 20px;"><a href="http://curator.apache.org/curator-recipes/simple-distributed-queue.html" style="color: rgb(0, 53, 172);">Simple Distributed Queue</a>&nbsp;- A drop-in replacement for the DistributedQueue that comes with the ZK distribution.</td></tr></tbody></table><p><br/></p></div>