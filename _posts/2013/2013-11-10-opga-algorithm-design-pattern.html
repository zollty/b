---
layout: ue
title: 程序设计模式-“OPGA设计模式”简介
category: 算法_数据结构_设计模式
tags: 算法,设计模式
keywords: "算法 程序设计模式"
---

<p style="text-align: center;">程序设计模式-“OPGA设计模式”简介<br/>即（One Parameter Go Anywhere）“一参走天下”</p><p><br/></p><p><span style=";font-size:16px">这是个新想法，看起来很不错。能够解决我们在编程时，要考虑太多的参数传递和回传的问题。如果能实现一种模式，让我们无须传递这么多参数，那是多么的好啊！</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">先看看，我们编程中经常会遇到的问题：</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">1、要求<span style="font-family:Times New Roman">Service</span>类</span><span style=";font-weight:bold;font-size:16px">回传多个信息</span><span style=";font-size:16px">。</span></p><p><span style=";font-size:16px">可行的做法：</span></p><p><span style=";font-size:16px">public&nbsp;ResultBean&nbsp;doService(xxx){} <br/></span></p><p><span style=";font-size:16px"><br/></span></p><p><span style=";font-size:16px">即</span><span style=";font-weight:bold;font-size:16px">定义一个返回的<span style="font-family:Times New Roman">ResultBean</span>，用于存放返回的多个信息</span><span style=";font-size:16px">。</span></p><p><span style=";font-size:16px">&nbsp; <br/></span></p><p><span style=";font-size:16px">2、要求</span><span style=";font-weight:bold;font-size:16px">把一堆参数交给下一个方法去处理</span><span style=";font-size:16px">。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">比如，如下代码：</span></p><p><span style=";font-size:16px">public&nbsp;ResultBean&nbsp;</span><strong><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">doService</span></strong><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(255,0,0);font-weight:bold;font-size:16px">(</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,0,255);font-size:16px">String</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;taskType,&nbsp;String&nbsp;timerAttr,</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,0,255);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&lt;FormVO&gt;&nbsp;formAttrs,&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,0,255);font-size:16px">List</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&lt;OthersVO&gt;&nbsp;otherAttrs,</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,0,255);font-size:16px">String</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;taskName,</span><span style=";font-size:16px">&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,0,255);font-size:16px">String</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;serviceId,&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,0,255);font-size:16px">String</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span><span style=";font-size:16px">orgID</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,0,255);font-size:16px">String</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span><span style=";font-size:16px">userID</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(255,0,0);font-weight:bold;font-size:16px">)</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">或者</span><span style=";font-weight:bold;font-size:16px">把参数全都封装成一个<span style="font-family:Times New Roman">bean</span></span><span style=";font-size:16px">，如下：</span></p><p><span style=";font-size:16px">public&nbsp;ResultBean&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">doService(</span><span style=";color:rgb(0,0,255);font-weight:normal;font-size:16px">StatReqBean</span><span style=";font-weight:bold;font-size:16px">&nbsp;bean</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">)</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">第一种呢，参数倒是传递了，但是</span><span style=";font-weight:bold;font-size:16px">用起来不给力，特别是链式传递</span><span style=";font-size:16px">（比如说上面的<span style="font-family:Times New Roman">doService</span>方法用完之后，又把这些参数传给一个叫<span style="font-family:Times New Roman">xxxDAO</span>的方法），又要传这么多参数，麻烦。参数你就不能少一点吗？没办法啊，程序有这么复杂啊，<span style="font-family:Times New Roman">Service</span>层或者<span style="font-family:Times New Roman">Dao</span>层人家就需要这些参数，你怎么办？</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">第二种呢，其实更“科学”一点，</span><span style=";font-weight:bold;font-size:16px">唯独有一点不好的是，每次都要定义各种<span style="font-family:Times New Roman">bean</span></span><span style=";font-size:16px">，请求有请求的各种<span style="font-family:Times New Roman">bean</span>，返回有返回的各种<span style="font-family:Times New Roman">bean</span>。（比如在航空公司<span style="font-family:Times New Roman">B2B</span>平台项目中，习惯的是请求的<span style="font-family:Times New Roman">bean</span>命名为<span style="font-family:Times New Roman">XxxReqBean</span>，导致</span><span style=";font-weight:bold;font-size:16px">一大堆<span style="font-family:Times New Roman">Xxx</span></span><span style=";color:rgb(0,0,255);font-weight:bold;font-size:16px">Req</span><span style=";font-weight:bold;font-size:16px">Bean</span><span style=";font-size:16px">，返回的<span style="font-family:Times New Roman">bean</span>命名为<span style="font-family:Times New Roman">XxxRespBean</span>，</span><span style=";font-weight:bold;font-size:16px">Xxx</span><span style=";color:rgb(0,0,255);font-weight:bold;font-size:16px">Resp</span><span style=";font-weight:bold;font-size:16px">Bean也是一大堆</span><span style=";font-size:16px">）。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">很早以前，我还没用<span style="font-family:Times New Roman">Struts&nbsp;1</span>、<span style="font-family:Times New Roman">2</span>，那时用纯<span style="font-family:Times New Roman">Servlet</span>和<span style="font-family:Times New Roman">JSP</span>做开发，表单参数一大堆，要是想把这些参数传递到<span style="font-family:Times New Roman">Helper</span>类去处理，比如校验，就要传递很多参数，麻烦！</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">后来用上了<span style="font-family:Times New Roman">Struts</span>的表单自动封装到<span style="font-family:Times New Roman">VO</span>的功能，把数据都定义成一个<span style="font-family:Times New Roman">VO</span>，然后这个<span style="font-family:Times New Roman">VO</span>对象，就可以方便的传到程序的各处了，不管是传到<span style="font-family:Times New Roman">Helper</span>类去处理，还是传到<span style="font-family:Times New Roman">Service</span>或<span style="font-family:Times New Roman">Dao</span>中，都是很方便的。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">现在<span style="font-family:Times New Roman">Spring</span>盛行，我们又学到了很巧妙的一招——<span style="font-family:Times New Roman">BeanFactory</span>、<span style="font-family:Times New Roman">ApplicationContext</span>、……即，我们可以把需要的东西放到一个<span style="font-family:Times New Roman">bean</span>容器中，要什么就拿什么。通过<span style="font-family:Times New Roman">bean</span>的<span style="font-family:Times New Roman">id</span>（<span style="font-family:Times New Roman">name</span>）去获取<span style="font-family:Times New Roman">bean</span>。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">当然，这个容器需要一些通用性，要能“海纳百川”。</span></p><p><span style=";font-size:16px">&nbsp; <br/></span></p><p><span style=";font-size:16px">好，思路就是这样。</span><span style=";font-weight:bold;font-size:16px">我们需要定义一个通用的<span style="font-family:Times New Roman">bean</span>容器</span><span style=";font-size:16px">。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">我将它命名为：</span><span style=";font-weight:bold;font-size:16px">BeanSet</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">设计目的：可以轻松<span style="font-family:Times New Roman">add</span>一个对象，然后轻松<span style="font-family:Times New Roman">get</span>出来。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">那么，现在参数传递的方法，参数都可以统一了，写法如下：</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">public&nbsp;void&nbsp;doService(BeansSet&nbsp;beans){}</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">看到没，我们参数统一为<span style="font-family:Times New Roman">BeansSet</span>，这里面可以装任何我们想要的参数，获取也很简单，只需要调用<span style="font-family:Times New Roman">beans.get(&nbsp;id&nbsp;)</span>即可。聪明的你，也许会想到，这个<span style="font-family:Times New Roman">BeansSet</span>怎么这么神奇呢，不会全部都是存的<span style="font-family:Times New Roman">Object</span>对象吧，到时候还要强制转换对象类型，是不是比较麻烦，而且效率低。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">呵呵，这些问题，设计者早就已经想到了，咱们既要易用，又要高效！</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">自从<span style="font-family:Times New Roman">JDK&nbsp;1.5</span>之后，泛型是被推荐使用，<span style="font-family:Times New Roman">JDK</span>能非常高效地支持泛型！</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">于是，我</span><span style=";font-weight:bold;font-size:16px">通过泛型，实现了类型自动<span style="font-family:Times New Roman">aware</span>的功能</span><span style=";font-size:16px">。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">BeansSet里面装了<span style="font-family:Times New Roman">BeanObject&lt;?&gt;</span>，这是个泛型的对象，在<span style="font-family:Times New Roman">new</span>的时候指定其对象类型，比如：</span></p><p><span style=";font-size:16px">BeanObject&lt;String&gt;&nbsp;nameObj&nbsp;=&nbsp;new&nbsp;BeanObject&lt;String&gt;(id,&nbsp;value);</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">其实，<span style="font-family:Times New Roman">BeanObject</span>也是一个容器，它里面可以存储一个特定类型的<span style="font-family:Times New Roman">Java</span>对象实例。通过<span style="font-family:Times New Roman">getObject()</span>方法获取对象的实例（称之为<span style="font-family:Times New Roman">value</span>）。还有一个<span style="font-family:Times New Roman">id</span>，也就是这个对象的名称。通过<span style="font-family:Times New Roman">getId</span>获取。还有一个<span style="font-family:Times New Roman">getType()</span>方法，可以获取该<span style="font-family:Times New Roman">Object</span>的<span style="font-family:Times New Roman">Class</span>类型。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">比如<span style="font-family:Times New Roman">String&nbsp;name&nbsp;=&nbsp;&quot;zollty&quot;;&nbsp;</span>这个<span style="font-family:Times New Roman">name</span>参数，我们要把它装载到<span style="font-family:Times New Roman">BeanObject</span>中：</span></p><p><span style=";font-size:16px">BeanObject&lt;String&gt;&nbsp;nameObj&nbsp;=&nbsp;new&nbsp;BeanObject&lt;String&gt;(&quot;name&quot;,&nbsp;name);</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">然后加入<span style="font-family:Times New Roman">BeansSet</span>里面，</span></p><p><span style=";font-size:16px">beans.add(&nbsp;nameObject&nbsp;);</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">现在看，本文的标题，叫做“<span style="font-family:Times New Roman">OPGA</span>设计模式”，“一参走天下”。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">这个<span style="font-family:Times New Roman">BeanObject</span>组装好了之后，就可以传给其他程序了，其他程序中去拿自己需要的<span style="font-family:Times New Roman">bean</span>。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-weight:bold;font-size:16px">我们经常头痛的问题又来了，一个方法可能有多个方法名相同，但是参数个数、类型不同的情况。假设有<span style="font-family:Times New Roman">4</span>个参数，如果要提供全面的构造函数，那要写<span style="font-family:Times New Roman">4</span>的排列组合数（即<span style="font-family:Times New Roman">4*3*2*1=24</span>）个构造函数</span><span style=";font-size:16px">，而且<span style="font-family:Times New Roman">java</span>相同类型和参数个数的方法或构造函数是不被允许的，所以即使你想写<span style="font-family:Times New Roman">24</span>个构造函数，除非是<span style="font-family:Times New Roman">4</span>个类型各不相同的参数，否则，还不支持这么多构造函数或方法。</span></p><p><span style=";font-size:16px">&nbsp;<br/></span></p><p><span style=";font-weight:bold;font-size:16px">比如</span><span style=";font-size:16px">：</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-weight:bold;font-size:16px">//&nbsp;两个参数</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">public&nbsp;</span><span style=";font-size:16px">Result</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;fileUpload(Request&nbsp;request,&nbsp;String&nbsp;</span><span style=";font-size:16px">dir</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">)&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">fileUpload(request,&nbsp;absDir,&nbsp;null,&nbsp;null);</span><span style=";font-size:16px">&nbsp;//&nbsp;调用<span style="font-family:Times New Roman">4</span>参的方法，用两个<span style="font-family:Times New Roman">null</span>参数</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">}</span></p><p><span style=";font-weight:bold;font-size:16px">//&nbsp;三个参数</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">public&nbsp;</span><span style=";font-size:16px">Result</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;fileUpload(Request&nbsp;request,&nbsp;String&nbsp;</span><span style=";font-size:16px">dir</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;String&nbsp;</span><span style=";font-size:16px">suffix</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">)&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">fileUpload(request,&nbsp;absDir,&nbsp;null,&nbsp;inludeSuffix);</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">}</span></p><p><span style=";font-weight:bold;font-size:16px">//&nbsp;四个参数</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">public&nbsp;</span><span style=";font-size:16px">Result</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;fileUpload(Request&nbsp;request,&nbsp;String&nbsp;</span><span style=";font-size:16px">dir</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;</span><span style=";font-size:16px">int</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span><span style=";font-size:16px">len</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;String&nbsp;</span><span style=";font-size:16px">suffix</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;String&nbsp;</span><span style=";font-size:16px">m</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">imeType)&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">fileUpload(request,&nbsp;absDir,&nbsp;null,&nbsp;inludeSuffix);</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">}</span></p><p><span style=";font-weight:bold;font-size:16px">大家是不是经常见到这种代码，你用起来是很方便，有时只用两个参数的，某些情况又可能用三、四个参数的。但是对于写<span style="font-family:Times New Roman">API</span>的人来讲，太麻烦了</span><span style=";font-size:16px">，还要写这么多个不同参数的方法，真是麻烦！</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">这个还不算什么，</span><span style=";font-weight:bold;font-size:16px">最坑的是，有一次我们被坑惨了，本来是一个很小的改动（修改了一个接口，为一个方法增加了一个参数而已</span><span style=";font-size:16px">），但是</span><span style=";font-weight:bold;font-size:16px">要通知所有的接口调用者统统修改他们的代码</span><span style=";font-size:16px">。造成了多少人力和时间的消耗？比如</span></p><p><span style=";font-size:16px">public&nbsp;interface&nbsp;IService{</span></p><p><span style=";font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;Result&nbsp;doProcess(String&nbsp;appid,&nbsp;List&nbsp;data,&nbsp;User&nbsp;user);</span></p><p><span style=";font-size:16px">}</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">现在，改了接口，给<span style="font-family:Times New Roman">doProcess</span>方法多加了一个参数<span style="font-family:Times New Roman">orgid</span>，如下</span></p><p><span style=";font-size:16px">Result&nbsp;doProcess(String&nbsp;appid,&nbsp;List&nbsp;data,&nbsp;User&nbsp;user,&nbsp;String&nbsp;orgid);</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">这一改是“牵一发而动全身”啊！，别人以前的代码继承了这个接口，现在全是一堆红叉，报错：未实现接口的所有方法！</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">有了“<span style="font-family:Times New Roman">OPGA</span>设计模式”，就可以基于一种惯性的编程习惯：</span><span style=";font-weight:bold;font-size:16px">我们只传一个参数——<span style="font-family:Times New Roman">BeansSet</span></span><span style=";font-size:16px">，比如：</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">void&nbsp;doProcess(BeansSet&nbsp;beans);</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-weight:bold;font-size:16px">何时何地，我们都传一个参数！因为它是万能的</span><span style=";font-size:16px">。这是“一参走天下”的第一层含义。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">这样，我们也不会像上面所遇到的那种情况，去改接口，然后其他实现类都报错。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-weight:bold;font-size:16px">我们基于一个原则</span><span style=";font-size:16px">：“服务者”只需要把值传给“被服务者”，至于哪些值要用，哪些值不用，“服务者”根本不用关心。同理，“被服务者”</span><span style=";font-weight:bold;font-size:16px">按需</span><span style=";font-size:16px">去取它需要的东西，用到哪些取哪些，至于有没有，取了再说。</span></p><p><span style=";font-size:16px"><br/></span></p><p><span style=";font-size:16px">注意，我们</span><span style=";font-size:16px">可以</span><span style=";font-size:16px">把<span style="font-family:Times New Roman">Result</span>对象也省了，因为它也被<span style="font-family:Times New Roman">BeansSet</span>对象取代了，返回的结果也存在<span style="font-family:Times New Roman">BeansSet</span>中。这样，方法从调用，到全部执行完，算是一个周期。在这个周期中，<span style="font-family:Times New Roman">BeansSet</span>可以全线通吃的。这是“一参走天下”的第二层含义，它可以贯彻到一个方法的整个执行线路。</span></p><p><span style=";font-size:16px"><br/></span></p><p><span style=";font-size:16px">这种设计模式，我刚开始还不是很习惯，但现在我越用越顺手了，它的好处就是基于一种良好的习惯。现在，又发现了很多的好处，比如：</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">有些方法要<span style="font-family:Times New Roman">throw&nbsp;Exception</span>，但<span style="font-family:Times New Roman">throw&nbsp;Exception</span>这个动作，是和“终止程序运行”绑定了的，也就是说<span style="font-family:Times New Roman">throw</span>了<span style="font-family:Times New Roman">Exception</span>，方法也就返回了。但</span><span style=";font-weight:bold;font-size:16px">有时候，我们希望在<span style="font-family:Times New Roman">throw</span>了一些非核心的<span style="font-family:Times New Roman">Exception</span>的情况下，程序不返回，依然继续往下运行</span><span style=";font-size:16px">。</span></p><p><span style=";font-size:16px">如果<span style="font-family:Times New Roman">throw&nbsp;Exception</span>的话，意味着我们只有两种状态：要么完全成功，要么完全失败！我现在要多加几种状态，在方法中可以保存多个错误信息，全部都放到<span style="font-family:Times New Roman">BeansSet</span>中，比如<span style="font-family:Times New Roman">throw&nbsp;</span>了<span style="font-family:Times New Roman">WarnExp1</span>、<span style="font-family:Times New Roman">WarnExp2</span>、<span style="font-family:Times New Roman">ErrorExp1</span>、<span style="font-family:Times New Roman">FatalExp1</span>，把这些信息都回传回去，同时也可以传一个<span style="font-family:Times New Roman">isSuccess</span>的标识，非常简单，只需要添加到<span style="font-family:Times New Roman">BeansSet</span>中去就可以了，比如：</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">beans.add(&nbsp;new&nbsp;BeanObject&lt;Boolean&gt;(&quot;isSuccess&quot;,&nbsp;false)&nbsp;);</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">上层如果需要，它可以查看“有没有成功啊，有没有轻微错误和警告啊，有没有造成严重影响的<span style="font-family:Times New Roman">Fatal</span>错误啊”</span></p><p><span style=";font-size:16px"><br/></span></p><p><span style=";font-size:16px">小伙伴们，读完动手试试吧。用多了，你会真正喜欢上这种设计模式的。它不是强制性的编程要求，你可用可不用。但是</span><span style=";font-weight:bold;font-size:16px">多了一个解决方案，而且是实用的解决方案，总算是一件好事</span><span style=";font-size:16px">！而且这个设计模式的强大，连作者自己都还未完全发掘，上面那些例子，只是凤毛麟角、普通应用，说不定还能够衍生出一些很<span style="font-family:Times New Roman">Nice</span>的功能！</span></p><p><br/></p>
