---
layout: ue
title: JavaScript进阶学习笔记
category: 前端技术_JS、CSS等
tags: JavaScript
keywords: "JavaScript,js"
---

<p><br/></p><p><strong><span style="font-size: 20px; ">一、基本语法</span></strong></p><p>很简单。（略）</p><p><br/></p><p><strong><span style="font-size: 20px; ">二、JavaScript HTML DOM</span></strong></p><p>1、document</p><p>JavaScript 提供了&nbsp;document对象 来操作 HTML DOM，例如： document.write(&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;);</p><p>var x=document.getElementById(&quot;main&quot;);</p><p>var y=x.getElementsByTagName(&quot;p&quot;);</p><p>document.getElementById(&quot;p1&quot;).innerHTML=&quot;New text!&quot;;</p><p>document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;</p><p>document.getElementById(id).attribute=new value</p><p>document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;</p><p><br/></p><p>var para=document.createElement(&quot;p&quot;);</p><p>var node=document.createTextNode(&quot;这是新段落。&quot;);</p><p>para.appendChild(node);</p><p>parent.removeChild(child);</p><p><br/></p><p>2、HTML DOM事件<br/></p><p>例如：&lt;h1 <strong>onclick</strong>=&quot;changetext(this)&quot;&gt;请点击该文本&lt;/h1&gt;</p><p>document.getElementById(&quot;myBtn&quot;).onclick=function(){displayDate()};</p><p>1. onload 和 onunload 事件</p><p>onload 和 onunload 事件会在用户进入或离开页面时被触发。</p><p>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</p><p>onload 和 onunload 事件可用于处理 cookie。</p><p>2. onchange 事件</p><p>onchange 事件常结合对输入字段的验证来使用。例如：</p><p>&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;upperCase()&quot;&gt;</p><p>3. onmouseover 和 onmouseout 事件</p><p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。</p><p>4、onmousedown、onmouseup 以及 onclick 事件</p><p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</p><p><br/></p><p><strong><span style="font-size: 20px; ">三、JavaScript 对象</span></strong></p><p>1、<strong>内建对象</strong></p><p>Array、Boolean、Date、Math、Number、String、RegExp</p><p>注意 String对象的一些常用方法，例如substring、slice、split、replace等，还有Array的contact、join、push、pop、shift、sort等；<br/></p><p><br/></p><p><strong>全局对象：</strong></p><table class="dataintable" width="709"><tbody style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; " class="firstRow"><th style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-right: 15px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: baseline; background-color: rgb(213, 213, 213); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); width: 227px; ">函数</th><th style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-right: 15px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: baseline; background-color: rgb(213, 213, 213); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">描述</th></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_decodeURI.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">decodeURI()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">解码某个编码的 URI。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_decodeURIComponent.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">decodeURIComponent()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">解码一个编码的 URI 组件。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_encodeuri.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">encodeURI()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">把字符串编码为 URI。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_encodeURIComponent.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">encodeURIComponent()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">把字符串编码为 URI 组件。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_escape.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">escape()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">对字符串进行编码。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_eval.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">eval()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">计算 JavaScript 字符串，并把它作为脚本代码来执行。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_getClass.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">getClass()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">返回一个 JavaObject 的 JavaClass。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_isFinite.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">isFinite()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">检查某个值是否为有穷大的数。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_isNaN.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">isNaN()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">检查某个值是否是数字。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_number.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">Number()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">把对象的值转换为数字。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_parseFloat.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">parseFloat()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">解析一个字符串并返回一个浮点数。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_parseInt.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">parseInt()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">解析一个字符串并返回一个整数。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_string.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">String()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">把对象的值转换为字符串。</td></tr><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; "><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); "><a href="http://www.w3school.com.cn/jsref/jsref_unescape.asp" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; text-decoration: underline; color: rgb(144, 11, 9); background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; ">unescape()</a></td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 15px; padding-bottom: 6px; padding-left: 6px; border-style: initial; border-color: initial; vertical-align: text-top; background-color: rgb(239, 239, 239); border-top-color: rgb(170, 170, 170); border-right-color: rgb(170, 170, 170); border-bottom-color: rgb(170, 170, 170); border-left-color: rgb(170, 170, 170); ">对由 escape() 编码的字符串进行解码。</td></tr></tbody></table><p><strong>Browser 对象</strong>：Window、Navigator、Screen、History、Location；</p><p><strong>HTML DOM 对象</strong>：Document、Body、Button、Event、Form、Frame；</p><p><br/></p><p><strong>Object 对象</strong></p><p>Object 对象具有下列属性：</p><p>constructor</p><p>对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。</p><p>Prototype</p><p>对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。</p><p>Object 对象还具有几个方法：</p><p>hasOwnProperty(property)</p><p>判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(&quot;name&quot;)）</p><p>IsPrototypeOf(object)</p><p>判断该对象是否为另一个对象的原型。</p><p>PropertyIsEnumerable</p><p>判断给定的属性是否可以用 for...in 语句进行枚举。</p><p>ToString()</p><p>返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。</p><p>ValueOf()</p><p>返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。</p><p>注释：上面列出的每种属性和方法都会被其他对象覆盖。</p><p><br/></p><p>2、JavaScript中，创建一个空对象的两种方式：</p><p>1. var obj = new Object();</p><p>2. var obj = {};</p><p><br/></p><p>3、使用函数来构造对象：</p><pre class="brush:js;toolbar:false">function&nbsp;person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}
var&nbsp;myFather=new&nbsp;person(&quot;Bill&quot;,&quot;Gates&quot;,56,&quot;blue&quot;);
var&nbsp;myMother=new&nbsp;person(&quot;Steve&quot;,&quot;Jobs&quot;,48,&quot;green&quot;);</pre><p><br/></p><p>4、</p><p>JavaScript 是面向对象的语言，但 JavaScript 不使用类。</p><p>在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）。</p><p>JavaScript 基于 prototype，而不是基于类的。</p><p><br/></p><p>5、用 for...in 语句循环遍历对象的属性</p><pre class="brush:js;toolbar:false">var&nbsp;person={fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56};
for&nbsp;(x&nbsp;in&nbsp;person)
{
&nbsp;&nbsp;alert(person[x]);
}</pre><p><br/></p><p><strong><span style="font-size: 20px; ">四、JavaScript Window - 浏览器对象模型</span></strong></p><p>Browser 对象包括：Window、Navigator、Screen、History、Location；</p><p>1、window对象</p><p>所有浏览器都支持 window 对象。它表示浏览器窗口。</p><p>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p><p>全局变量是 window 对象的属性。</p><p>全局函数是 window 对象的方法。</p><p>甚至 HTML DOM 的 document 也是 window 对象的属性之一：</p><p>window.document.getElementById(&quot;header&quot;);</p><p>等价于：document.getElementById(&quot;header&quot;);</p><p><br/></p><p>2、Window 尺寸：</p><p>有三种方法能够确定浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）。</p><p>对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：</p><p>&nbsp; window.innerHeight - 浏览器窗口的内部高度</p><p>&nbsp; window.innerWidth - 浏览器窗口的内部宽度</p><p>对于 Internet Explorer 8、7、6、5：</p><p>&nbsp; document.documentElement.clientHeight</p><p>&nbsp; document.documentElement.clientWidth</p><p>或者</p><p>&nbsp; document.body.clientHeight</p><p>&nbsp; document.body.clientWidth</p><p><br/></p><p>3、其他 Window 方法：</p><p>window.open() - 打开新窗口</p><p>window.close() - 关闭当前窗口</p><p>window.moveTo() - 移动当前窗口</p><p>window.resizeTo() - 调整当前窗口的尺寸</p><p><br/></p><p>4、window.screen 对象包含有关用户屏幕的信息。</p><p>screen.availWidth - 可用的屏幕宽度</p><p>screen.availHeight - 可用的屏幕高度</p><p><br/></p><p>5、window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</p><p>一些例子：</p><p>location.hostname 返回 web 主机的域名</p><p>location.pathname 返回当前页面的路径和文件名</p><p>location.port 返回 web 主机的端口 （80 或 443）</p><p>location.protocol 返回所使用的 web 协议（http:// 或 https://）</p><p><br/></p><p>location.href 属性 返回当前页面的 URL。</p><p><br/></p><p>6、window.history 对象包含浏览器的历史。</p><p>history.back() - 与在浏览器点击后退按钮相同</p><p>history.forward() - 与在浏览器中点击按钮向前相同</p><p><br/></p><p>7、document.cookie 对象</p><p>cookie 用来识别用户。</p><p>什么是cookie?</p><p>cookie 是存储于访问者的计算机中的<strong>变量</strong>。每当<strong>同一台</strong>计算机<strong>通过浏览器请求某个页面时，就会发送这个 cookie</strong>。你可以使用 JavaScript 来创建和取回 cookie 的值。</p><p>有关cookie的例子：</p><p>名字 cookie</p><p>&nbsp; 当访问者首次访问页面时，他或她也许会填写他/她们的名字。名字会存储于 cookie 中。当访问者再次访问网站时，他们会收到类似 &quot;Welcome John Doe!&quot; 的欢迎词。而名字则是从 cookie 中取回的。</p><p>密码 cookie</p><p>&nbsp; 当访问者首次访问页面时，他或她也许会填写他/她们的密码。密码也可被存储于 cookie 中。当他们再次访问网站时，密码就会从 cookie 中取回。</p><p>日期 cookie</p><p>&nbsp; 当访问者首次访问你的网站时，当前的日期可存储于 cookie 中。当他们再次访问网站时，他们会收到类似这样的一条消息：&quot;Your last visit was on Tuesday August 11, 2005!&quot;。日期也是从 cookie 中取回的。</p><p><br/></p><p>8、XMLHttpRequest 对象</p><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)）</p><p>1. 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p><pre class="brush:js;toolbar:false">&nbsp;&nbsp;xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);
&nbsp;&nbsp;xmlhttp.send();
&nbsp;&nbsp;
&nbsp;&nbsp;xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);
&nbsp;&nbsp;xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
&nbsp;&nbsp;xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);</pre><p>2. 如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p><p>3.&nbsp;每当 readyState 改变时，就会触发 onreadystatechange 事件。</p><pre class="brush:js;toolbar:false">xmlhttp.onreadystatechange=function()
&nbsp;&nbsp;{
&nbsp;&nbsp;if&nbsp;(xmlhttp.readyState==4&nbsp;&amp;&amp;&nbsp;xmlhttp.status==200)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&nbsp;xmlhttp.responseText&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}</pre><p><br/></p><p><strong><span style="font-size: 20px; ">五、ECMAScript&nbsp;</span></strong></p><p>1、ECMAScript 函数</p><p>什么是函数？</p><p>&nbsp; 函数是一组可以随时随地运行的语句。</p><p>&nbsp; 函数是 ECMAScript 的核心。</p><p>在函数代码中，使用<strong>特殊对象 arguments</strong>，开发者无需明确指出参数名，就能访问它们。</p><p>例如，在函数 sayHi() 中，第一个参数是 message。用 arguments[0] 也可以访问这个值，即第一个参数的值（第一个参数位于位置 0，第二个参数位于位置 1，依此类推）。</p><p>还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。例如：</p><pre class="brush:js;toolbar:false">function&nbsp;howManyArgs()&nbsp;{
&nbsp;&nbsp;alert(arguments.length);
}

howManyArgs(&quot;string&quot;,&nbsp;45);
howManyArgs();
howManyArgs(12);</pre><p>函数参数个数：与其他程序设计语言不同，ECMAScript 不会验证传递给函数的参数个数是否等于函数定义的参数个数。开发者定义的函数都可以接受任意个数的参数（根据 Netscape 的文档，最多可接受 255 个），而不会引发任何错误。任何遗漏的参数都会以 undefined 传递给函数，多余的函数将忽略。</p><p>注意：在函数内使用 arguments&nbsp;时不需要加 this.arguments ！因为arguments不属于 this。</p><p><br/></p><p>2、Function 对象</p><p>用 Function 对象可以直接创建函数，语法如下：</p><p><strong><span style="background-color: rgb(216, 216, 216); ">var function_name = new function(arg1, arg2, ..., argN, function_body)</span></strong></p><p>在上面的形式中，每个 arg 都是一个参数，最后一个参数是函数主体（要执行的代码）。这些参数必须是字符串。</p><p style="line-height: normal; ">function sayHi(sName, sMessage) {</p><p style="line-height: normal; ">&nbsp; alert(&quot;Hello &quot; + sName + sMessage);</p><p style="line-height: normal; ">}</p><p>等价于：</p><p>var sayHi = new Function(&quot;sName&quot;, &quot;sMessage&quot;, &quot;alert(\&quot;Hello \&quot; + sName + sMessage);&quot;);</p><p>注意：尽管可以使用 Function 构造函数创建函数，但最好不要使用它，因为用它定义函数比用传统方式要<strong>慢得多</strong>。不过，所有函数都应看作 Function 类的实例。</p><p><br/></p><p>3、Function 对象的 属性和方法</p><p>如前所述，函数属于引用类型，所以它们也有属性和方法。</p><p>ECMAScript 定义的属性 length 声明了函数期望的参数个数。</p><p>Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码。</p><p><br/></p><p>4、ECMAScript 闭包</p><p>闭包，指的是词法表示包括不被计算的变量的函数，也就是说，<strong>函数可以使用函数之外定义的变量</strong>。</p><p>1. 简单的闭包实例</p><p>在 ECMAScript 中使用全局变量是一个简单的闭包实例。请思考下面这段代码：</p><pre class="brush:js;toolbar:false">var&nbsp;sMessage&nbsp;=&nbsp;&quot;hello&nbsp;world&quot;;
function&nbsp;sayHelloWorld()&nbsp;{
&nbsp;&nbsp;alert(sMessage);
}
sayHelloWorld();</pre><p>在上面这段代码中，脚本被载入内存后，并没有为函数 sayHelloWorld() 计算变量 sMessage 的值。<strong>该函数捕获 sMessage 的值只是为了以后的使用</strong>，也就是说，解释程序知道在调用该函数时要检查 sMessage 的值。<strong>sMessage 将在函数调用 sayHelloWorld() 时（最后一行）被赋值</strong>，显示消息 &quot;hello world&quot;。</p><p>2.&nbsp;复杂的闭包实例</p><p>在一个函数中定义另一个会使闭包变得更加复杂。例如：</p><pre class="brush:js;toolbar:false">var&nbsp;iBaseNum&nbsp;=&nbsp;10;
function&nbsp;addNum(iNum1,&nbsp;iNum2)&nbsp;{
&nbsp;&nbsp;function&nbsp;doAdd()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;iNum1&nbsp;+&nbsp;iNum2&nbsp;+&nbsp;iBaseNum;
&nbsp;&nbsp;}
&nbsp;&nbsp;return&nbsp;doAdd();
}</pre><p>这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。</p><p>这里要掌握的重要概念是，doAdd() 函数根本不接受参数，它<strong>使用的值是从执行环境中获取的</strong>。</p><p>可以看到，闭包是 ECMAScript 中非常强大多用的一部分，可用于执行复杂的计算。</p><p>提示：就像使用任何高级函数一样，使用闭包要小心，因为它们可能会变得非常复杂。</p><p><br/></p><p>5、ECMAScript 面向对象</p><p>ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。</p><p>ECMAScript 并没有正式的类。即使类并不真正存在，我们也把对象定义叫做类，因为大多数开发者对此术语更熟悉，而且从功能上说，两者是等价的。</p><p>一种面向对象语言需要向开发者提供四种基本能力：</p><p>封装 - 把相关的信息（无论数据或方法）存储在对象中的能力</p><p>聚集 - 把一个对象存储在另一个对象内的能力</p><p>继承 - 由另一个类（或多个类）得来类的属性和方法的能力</p><p>多态 - 编写能以多种方法运行的函数或方法的能力</p><p>ECMAScript 支持这些要求，因此可被是看做面向对象的。</p><p><br/></p><p>6、对象废除</p><p>ECMAScript 拥有无用存储单元收集程序（garbage collection routine），意味着不必专门销毁对象来释放内存。当再没有对对象的引用时，称该对象被废除（dereference）了。运行无用存储单元收集程序时，所有废除的对象都被销毁。每当函数执行完它的代码，无用存储单元收集程序都会运行，释放所有的局部变量，还有在一些其他不可预知的情况下，无用存储单元收集程序也会运行。</p><p>把对象的所有引用都设置为 null，可以强制性地废除对象。例如：</p><p>var oObject = new Object;</p><p>// do something with the object here</p><p>oObject = null;</p><p>当变量 oObject 设置为 null 后，对第一个创建的对象的引用就不存在了。这意味着下次运行无用存储单元收集程序时，该对象将被销毁。</p><p>每用完一个对象后，就将其废除，来释放内存，这是个好习惯。这样还确保不再使用已经不能访问的对象，从而防止程序设计错误的出现。此外，旧的浏览器（如 IE/MAC）没有全面的无用存储单元收集程序，所以在卸载页面时，对象可能不能被正确销毁。废除对象和它的所有特性是确保内存使用正确的最好方法。</p><p>注意：废除对象的所有引用时要当心。如果一个对象有两个或更多引用，则要正确废除该对象，必须将其所有引用都设置为 null。</p><p><br/></p><p>7、对象类型</p><p>在 ECMAScript 中，所有对象并非同等创建的。</p><p>一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。</p><p>1. 本地对象</p><p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：</p><pre class="brush:plain;toolbar:false">Object
Function
Array
String
Boolean
Number
Date
RegExp
Error&nbsp;EvalError&nbsp;RangeError&nbsp;ReferenceError&nbsp;SyntaxError&nbsp;TypeError&nbsp;URIError</pre><p>2. 内置对象：ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。</p><p>3.&nbsp;宿主对象</p><p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。</p><p>所有 BOM 和 DOM 对象都是宿主对象。</p><p><br/></p><p>8、ECMAScript&nbsp;作用域</p><p>1.&nbsp;ECMAScript 只有公用作用域 (public)</p><p>&nbsp; &nbsp; ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的(<strong>public</strong>)！</p><p><br/></p><p>9. &nbsp;ECMAScript 定义类（对象）</p><p>1. 原始方式</p><pre class="brush:js;toolbar:false">var&nbsp;oCar&nbsp;=&nbsp;new&nbsp;Object;
oCar.color&nbsp;=&nbsp;&quot;blue&quot;;
oCar.doors&nbsp;=&nbsp;4;
oCar.mpg&nbsp;=&nbsp;25;
oCar.showColor&nbsp;=&nbsp;function()&nbsp;{
&nbsp;&nbsp;alert(this.color);
};</pre><p>原始方式有个重大局限就是，如果要定义多个对象，则要重复写很多次属性和方法。</p><p>2. 工厂方式</p><p>工厂方式，解决了原始方式的问题，如下。</p><pre class="brush:js;toolbar:false">function&nbsp;createCar(sColor,iDoors,iMpg)&nbsp;{
&nbsp;&nbsp;var&nbsp;oTempCar&nbsp;=&nbsp;new&nbsp;Object;
&nbsp;&nbsp;oTempCar.color&nbsp;=&nbsp;sColor;
&nbsp;&nbsp;oTempCar.doors&nbsp;=&nbsp;iDoors;
&nbsp;&nbsp;oTempCar.mpg&nbsp;=&nbsp;iMpg;
&nbsp;&nbsp;oTempCar.showColor&nbsp;=&nbsp;function()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;alert(this.color);
&nbsp;&nbsp;};
&nbsp;&nbsp;return&nbsp;oTempCar;
}

var&nbsp;oCar1&nbsp;=&nbsp;createCar(&quot;red&quot;,4,23);
var&nbsp;oCar2&nbsp;=&nbsp;createCar(&quot;blue&quot;,3,25);

oCar1.showColor();		//输出&nbsp;&quot;red&quot;
oCar2.showColor();		//输出&nbsp;&quot;blue&quot;</pre><p>但是还是存在一个性能问题：每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。</p><p>4.&nbsp;原形方式</p><p>首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性：</p><pre class="brush:js;toolbar:false">function&nbsp;Car()&nbsp;{
}

Car.prototype.color&nbsp;=&nbsp;&quot;blue&quot;;
Car.prototype.doors&nbsp;=&nbsp;4;
Car.prototype.mpg&nbsp;=&nbsp;25;
Car.prototype.showColor&nbsp;=&nbsp;function()&nbsp;{
&nbsp;&nbsp;alert(this.color);
};

var&nbsp;oCar1&nbsp;=&nbsp;new&nbsp;Car();
var&nbsp;oCar2&nbsp;=&nbsp;new&nbsp;Car();</pre><p><strong>调用 </strong>new Car() <strong>时</strong>，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。</p><p>此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。因此，下面的代码将输出 TRUE：</p><p>alert(oCar1 instanceof Car);<span class="Apple-tab-span" style="white-space: pre; "></span>//输出 &quot;true&quot;</p><p><br/></p><p>原型方式看起来是个不错的解决方案。遗憾的是，它并不尽如人意。</p><p>1. 首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值。</p><p>3. 真正的问题出现在属性指向的是对象的引用，多个对象会公用一个对象，例如：</p><pre class="brush:js;toolbar:false">function&nbsp;Car()&nbsp;{
}

Car.prototype.color&nbsp;=&nbsp;&quot;blue&quot;;
Car.prototype.doors&nbsp;=&nbsp;4;
Car.prototype.mpg&nbsp;=&nbsp;25;Car.prototype.drivers&nbsp;=&nbsp;new&nbsp;Array(&quot;Mike&quot;,&quot;John&quot;);Car.prototype.showColor&nbsp;=&nbsp;function()&nbsp;{
&nbsp;&nbsp;alert(this.color);
};

var&nbsp;oCar1&nbsp;=&nbsp;new&nbsp;Car();
var&nbsp;oCar2&nbsp;=&nbsp;new&nbsp;Car();oCar1.drivers.push(&quot;Bill&quot;);alert(oCar1.drivers);	//输出&nbsp;&quot;Mike,John,Bill&quot;alert(oCar2.drivers);	//输出&nbsp;&quot;Mike,John,Bill&quot;</pre><p>由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 &quot;Bill&quot;，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 &quot;Mike,John,Bill&quot;。</p><p>由于创建对象时有这么多问题，你一定会想，是否有种合理的创建对象的方法呢？答案是有，需要联合使用构造函数和原型方式。</p><p>5.&nbsp;混合的构造函数/原型方式</p><p>联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。</p><p>我们重写了前面的例子，代码如下：</p><pre class="brush:js;toolbar:false">function&nbsp;Car(sColor,iDoors,iMpg)&nbsp;{
&nbsp;&nbsp;this.color&nbsp;=&nbsp;sColor;
&nbsp;&nbsp;this.doors&nbsp;=&nbsp;iDoors;
&nbsp;&nbsp;this.mpg&nbsp;=&nbsp;iMpg;
&nbsp;&nbsp;this.drivers&nbsp;=&nbsp;new&nbsp;Array(&quot;Mike&quot;,&quot;John&quot;);
}

Car.prototype.showColor&nbsp;=&nbsp;function()&nbsp;{
&nbsp;&nbsp;alert(this.color);
};

var&nbsp;oCar1&nbsp;=&nbsp;new&nbsp;Car(&quot;red&quot;,4,23);
var&nbsp;oCar2&nbsp;=&nbsp;new&nbsp;Car(&quot;blue&quot;,3,25);

oCar1.drivers.push(&quot;Bill&quot;);

alert(oCar1.drivers);	//输出&nbsp;&quot;Mike,John,Bill&quot;alert(oCar2.drivers);	//输出&nbsp;&quot;Mike,John&quot;</pre><p>6.&nbsp;动态原型方法</p><pre class="brush:js;toolbar:false">function&nbsp;Car(sColor,iDoors,iMpg)&nbsp;{
&nbsp;&nbsp;this.color&nbsp;=&nbsp;sColor;
&nbsp;&nbsp;this.doors&nbsp;=&nbsp;iDoors;
&nbsp;&nbsp;this.mpg&nbsp;=&nbsp;iMpg;
&nbsp;&nbsp;this.drivers&nbsp;=&nbsp;new&nbsp;Array(&quot;Mike&quot;,&quot;John&quot;);
&nbsp;&nbsp;
&nbsp;&nbsp;if&nbsp;(typeof&nbsp;Car._initialized&nbsp;==&nbsp;&quot;undefined&quot;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Car.prototype.showColor&nbsp;=&nbsp;function()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.color);
&nbsp;&nbsp;&nbsp;&nbsp;};	
&nbsp;&nbsp;&nbsp;&nbsp;Car._initialized&nbsp;=&nbsp;true;
&nbsp;&nbsp;}
}</pre><p>这种方法更接近面向对象，如同JAVA一般。</p><p>10. 字符串连接的性能问题<br/></p><pre class="brush:js;toolbar:false">&nbsp;&nbsp;var&nbsp;str&nbsp;=&nbsp;&quot;hello&nbsp;&quot;;
&nbsp;&nbsp;str&nbsp;+=&nbsp;&quot;world&quot;;</pre><p>这段代码在幕后执行的步骤如下：</p><p>创建存储 &quot;hello &quot; 的字符串。</p><p>创建存储 &quot;world&quot; 的字符串。</p><p>创建存储连接结果的字符串。</p><p>把 str 的当前内容复制到结果中。</p><p>把 &quot;world&quot; 复制到结果中。</p><p>更新 str，使它指向结果。</p><p>每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。解决方法是用 Array 对象存储字符串，然后用 join() 方法（参数是空字符串）创建最后的字符串。想象用下面的代码代替前面的代码：</p><pre class="brush:js;toolbar:false">&nbsp;&nbsp;var&nbsp;arr&nbsp;=&nbsp;new&nbsp;Array();
&nbsp;&nbsp;arr[0]&nbsp;=&nbsp;&quot;hello&nbsp;&quot;;
&nbsp;&nbsp;arr[1]&nbsp;=&nbsp;&quot;world&quot;;
&nbsp;&nbsp;var&nbsp;str&nbsp;=&nbsp;arr.join(&quot;&quot;);</pre><p>虽然这种解决方案很好，但还有更好的方法。问题是，这段代码不能确切反映出它的意图。要使它更容易理解，可以用 StringBuffer 类打包该功能：</p><pre class="brush:js;toolbar:false">function&nbsp;StringBuffer(){
&nbsp;&nbsp;this._sArray_&nbsp;=&nbsp;new&nbsp;Array();
}
StringBuffer.prototype.append&nbsp;=&nbsp;function(str)&nbsp;{
&nbsp;&nbsp;this._sArray_.push(str);
}
StringBuffer.prototype.toString&nbsp;=&nbsp;function()&nbsp;{
&nbsp;&nbsp;return&nbsp;this._sArray_.join(&quot;&quot;);
}</pre><p>用法如下：</p><pre class="brush:js;toolbar:false">var&nbsp;buffer&nbsp;=&nbsp;new&nbsp;StringBuffer&nbsp;();
buffer.append(&quot;hello&nbsp;&quot;);
buffer.append(&quot;world&quot;);
var&nbsp;result&nbsp;=&nbsp;buffer.toString();</pre><p><br/></p><p>11. 对象的继承</p><p>1. 对象冒充</p><p>构想原始的 ECMAScript 时，根本没打算设计对象冒充（object masquerading）。它是在开发者开始理解函数的工作方式，尤其是如何在函数环境中使用 this 关键字后才发展出来。</p><p>其原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB：</p><pre class="brush:js;toolbar:false">function&nbsp;ClassA(sColor)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.color&nbsp;=&nbsp;sColor;
&nbsp;&nbsp;&nbsp;&nbsp;this.sayColor&nbsp;=&nbsp;function&nbsp;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.color);
&nbsp;&nbsp;&nbsp;&nbsp;};
}
function&nbsp;ClassB(sColor)&nbsp;{
}</pre><p>还记得吗？关键字 this 引用的是构造函数当前创建的对象。不过在这个方法中，this 指向的所属的对象。这个原理是把 ClassA 作为常规函数来建立继承机制，而不是作为构造函数。如下使用构造函数 ClassB 可以实现继承机制：</p><pre class="brush:js;toolbar:false">function&nbsp;ClassB(sColor)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod&nbsp;=&nbsp;ClassA;
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod(sColor);
&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;this.newMethod;
}</pre><p>在这段代码中，为 ClassA 赋予了方法 newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是 ClassB 构造函数的参数 sColor。最后一行代码删除了对 ClassA 的引用，这样以后就不能再调用它。</p><p>所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法：</p><pre class="brush:js;toolbar:false">function&nbsp;ClassB(sColor,&nbsp;sName)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod&nbsp;=&nbsp;ClassA;
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod(sColor);&nbsp;//&nbsp;执行构造函数，给this添加属性和函数
&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;this.newMethod;
&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;sName;
&nbsp;&nbsp;&nbsp;&nbsp;this.sayName&nbsp;=&nbsp;function&nbsp;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.name);
&nbsp;&nbsp;&nbsp;&nbsp;};
}</pre><p>为证明前面的代码有效，可以运行下面的例子：</p><pre class="brush:js;toolbar:false">var&nbsp;objA&nbsp;=&nbsp;new&nbsp;ClassA(&quot;blue&quot;);
var&nbsp;objB&nbsp;=&nbsp;new&nbsp;ClassB(&quot;red&quot;,&nbsp;&quot;John&quot;);
objA.sayColor();//输出&nbsp;&quot;blue&quot;
objB.sayColor();//输出&nbsp;&quot;red&quot;
objB.sayName();//输出&nbsp;&quot;John&quot;</pre><p>对象冒充可以实现多重继承</p><p>例如，如果存在两个类 ClassX 和 ClassY，ClassZ 想继承这两个类，可以使用下面的代码：</p><pre class="brush:js;toolbar:false">function&nbsp;ClassZ()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod&nbsp;=&nbsp;ClassX;
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod();
&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;this.newMethod;
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod&nbsp;=&nbsp;ClassY;
&nbsp;&nbsp;&nbsp;&nbsp;this.newMethod();
&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;this.newMethod;
}</pre><p>由于这种继承方法的流行，ECMAScript 的第三版为 Function 对象加入了两个方法，即 call() 和 apply()。</p><p>2. call() 方法</p><p>call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如：</p><pre class="brush:js;toolbar:false">function&nbsp;sayColor(sPrefix,sSuffix)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;alert(sPrefix&nbsp;+&nbsp;this.color&nbsp;+&nbsp;sSuffix);
};
var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Object();
obj.color&nbsp;=&nbsp;&quot;blue&quot;;
sayColor.call(obj,&nbsp;&quot;The&nbsp;color&nbsp;is&nbsp;&quot;,&nbsp;&quot;a&nbsp;very&nbsp;nice&nbsp;color&nbsp;indeed.&quot;);</pre><p>在这个例子中，函数 sayColor() 在对象外定义，即使它不属于任何对象，也可以引用关键字 this。对象 obj 的 color 属性等于 blue。调用 call() 方法时，第一个参数是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个和第三个参数是字符串。它们与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息 &quot;The color is blue, a very nice color indeed.&quot; 将被显示出来。</p><p>要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可：</p><pre class="brush:js;toolbar:false">function&nbsp;ClassB(sColor,&nbsp;sName)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//this.newMethod&nbsp;=&nbsp;ClassA;
&nbsp;&nbsp;&nbsp;&nbsp;//this.newMethod(color);
&nbsp;&nbsp;&nbsp;&nbsp;//delete&nbsp;this.newMethod;
&nbsp;&nbsp;&nbsp;&nbsp;ClassA.call(this,&nbsp;sColor);
&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;sName;
&nbsp;&nbsp;&nbsp;&nbsp;this.sayName&nbsp;=&nbsp;function&nbsp;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.name);
&nbsp;&nbsp;&nbsp;&nbsp;};
}</pre><p>3.&nbsp;apply() 方法</p><p>apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如：</p><pre class="brush:js;toolbar:false">function&nbsp;sayColor(sPrefix,sSuffix)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;alert(sPrefix&nbsp;+&nbsp;this.color&nbsp;+&nbsp;sSuffix);
};
var&nbsp;obj&nbsp;=&nbsp;new&nbsp;Object();
obj.color&nbsp;=&nbsp;&quot;blue&quot;;
sayColor.apply(obj,&nbsp;new&nbsp;Array(&quot;The&nbsp;color&nbsp;is&nbsp;&quot;,&nbsp;&quot;a&nbsp;very&nbsp;nice&nbsp;color&nbsp;indeed.&quot;));</pre><p>这个例子与前面的例子相同，只是现在调用的是 apply() 方法。</p><p><br/></p><p>2、原型链（prototype chaining）</p><p>在上一章学过，prototype 对象是个模板，要实例化的对象都以这个模板为基础。总而言之，prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。</p><p>如果用原型方式重定义前面例子中的类，它们将变为下列形式：</p><pre class="brush:js;toolbar:false">function&nbsp;ClassA()&nbsp;{
}
ClassA.prototype.color&nbsp;=&nbsp;&quot;blue&quot;;
ClassA.prototype.sayColor&nbsp;=&nbsp;function&nbsp;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;alert(this.color);
};
function&nbsp;ClassB()&nbsp;{
}

ClassB.prototype&nbsp;=&nbsp;new&nbsp;ClassA();

ClassB.prototype.name&nbsp;=&nbsp;&quot;&quot;;
ClassB.prototype.sayName&nbsp;=&nbsp;function&nbsp;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;alert(this.name);
};</pre><p>原型方式的神奇之处在于 ClassB.prototype = new ClassA()&nbsp;，这里把 ClassB 的 prototype 属性设置成 ClassA 的实例。这很有意思，因为想要 ClassA 的所有属性和方法，但又不想逐个将它们 ClassB 的 prototype 属性。还有比把 ClassA 的实例赋予 prototype 属性更好的方法吗？</p><p>此外，在原型链中，instanceof 运算符的运行方式也很独特。对 ClassB 的所有实例，instanceof 为 ClassA 和 ClassB 都返回 true。例如：</p><pre class="brush:js;toolbar:false">var&nbsp;objB&nbsp;=&nbsp;new&nbsp;ClassB();
alert(objB&nbsp;instanceof&nbsp;ClassA);//输出&nbsp;&quot;true&quot;
alert(objB&nbsp;instanceof&nbsp;ClassB);//输出&nbsp;&quot;true&quot;</pre><p>在 ECMAScript 的弱类型世界中，这是极其有用的工具，不过使用对象冒充时不能使用它。</p><p>原型链的弊端是不支持多重继承。记住，原型链会用另一类型的对象重写类的 prototype 属性。</p><p>混合方式</p><p>这种继承方式使用构造函数定义类，并非使用任何原型。对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。</p><p>代码如下：</p><pre class="brush:js;toolbar:false;highlight: [8, 11]">function&nbsp;ClassA(sColor)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;this.color&nbsp;=&nbsp;sColor;
}
ClassA.prototype.sayColor&nbsp;=&nbsp;function&nbsp;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;alert(this.color);
};
function&nbsp;ClassB(sColor,&nbsp;sName)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ClassA.call(this,&nbsp;sColor);
&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;sName;
}
ClassB.prototype&nbsp;=&nbsp;new&nbsp;ClassA();
ClassB.prototype.sayName&nbsp;=&nbsp;function&nbsp;()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;alert(this.name);
};</pre><p>在此例子中，继承机制由第8、11行代码实现。在8行代码中，在 ClassB 构造函数中，用对象冒充继承 ClassA 类的 sColor 属性。在11行代码中，用原型链继承 ClassA 类的方法。由于这种混合方式使用了原型链，所以 instanceof 运算符仍能正确运行。</p><p><br/></p>