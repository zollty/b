---
layout: ue
title: 深入学习XML和XSD、定制XML数据交互规范
category: 其他语言和技术
tags: XML
keywords: "XSD、XML数据交互规范"
---

<p><br/></p><p>最近制定了报表引擎数据交互的XML规范，</p><p>没时间写总结，先列出下面的参考资料：<br/></p><p><a href="http://www.w3school.com.cn/schema/schema_example.asp" target="_blank">http://www.w3school.com.cn/schema/schema_example.asp</a></p><p><a href="http://www.w3.org/TR/xmlschema-0/" target="_blank">http://www.w3.org/TR/xmlschema-0/</a></p><p><a href="http://maven.apache.org/xsd/" target="_blank">http://maven.apache.org/xsd/</a>（很好的规范参考）</p><p><a href="http://www.opentravel.org/Specifications/OnlineXmlSchema.aspx" target="_blank">http://www.opentravel.org/Specifications/OnlineXmlSchema.aspx</a>（很好的规范参考）</p><p><br/></p><p><a href="http://blog.csdn.net/zhengyeqing520/article/details/6091656" target="_blank">http://blog.csdn.net/zhengyeqing520/article/details/6091656</a></p><p><br/></p><p style="text-align:center;line-height:300%"><span style=";font-family:宋体;color:rgb(44,44,44);font-weight:bold;font-size:24px">报表引擎<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">规范“</span><span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”的制定和实施</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">一、“<span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”的来源和背景</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">我们可以看到，很多项目的<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">结构采用了“</span><span style="font-family:Times New Roman">OTA</span><span style="font-family:宋体">标准”，报表引擎在这一方面借鉴了“</span><span style="font-family:Times New Roman">OTA</span><span style="font-family:宋体">标准”，制定了自己的</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">标准，我们称之为“</span><span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">1<span style="font-family:宋体">、为什么要制定这样一个标准？它有什么作用？</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">因为报表引擎的一些参数传递采用了<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的结构，</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">是一种较好的组装数据的方式，内容丰富，易于扩展，也得到了广泛的认可。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">报表引擎支持多个不同的项目，报表引擎是提供服务的一方，应用端需要通过一套规范的流程来调用报表引擎的服务，无论是应用端提交的指令还是数据，都需要遵循一定的格式。我们通过<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">来定义这种格式，一是可以验证，二是方便解析。（最原始的方式是自己组装字符串，用</span><span style="font-family:Times New Roman">%</span><span style="font-family:宋体">、</span><span style="font-family:Times New Roman">&amp;</span><span style="font-family:宋体">等字符来分割，用正则表达式去验证，用</span><span style="font-family:Times New Roman">split</span><span style="font-family:宋体">等方法去解析……这种方式很麻烦，不太适合复杂类型的数据）。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">标准化的东西，一个是容易使用（比如封装、解析），二是容易判定（是否符合标准），三是便于版本控制，四是体系容易扩展。</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">2<span style="font-family:宋体">、“</span><span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”是基于什么规范？参考了哪些标准？</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">1<span style="font-family:宋体">）“</span><span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”是</span><strong><span style="font-family:宋体">基于</span><span style="font-family:Times New Roman">W3C</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">规范</span></strong><span style="font-family:宋体">制定的，</span></span><strong><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">除了</span><span style="font-family:Times New Roman">W3C</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">规范外，业界还有比如微软的</span><span style="font-family:Times New Roman">OOXML</span><span style="font-family:宋体">规范、</span><span style="font-family:Times New Roman">ISO</span><span style="font-family:宋体">的</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">RELAX&nbsp;NG</span><span style=";font-family:宋体;font-size:19px">规范</span></strong><span style=";font-family:宋体;font-size:19px">等。</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">2<span style="font-family:宋体">）“</span><span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”主要参考了“</span><span style="font-family:Times New Roman">OTA</span><span style="font-family:宋体">标准”、</span><span style="font-family:Times New Roman">Spring</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">配置文件标准、</span><span style="font-family:Times New Roman">Maven</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">配置文件标准以及</span><span style="font-family:Times New Roman">Apache</span><span style="font-family:宋体">的一些知名项目的</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">配置文件标准，包括它们的数据格式、类型、验证方式、版本定义、命名方式等。下面列举一部分示例：</span></span></p><p style="text-align: center; "><img src="{{site.assets_url}}img/20150712/wpsA5.tmp.jpg" title="wpsA5.tmp.jpg"/><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="text-align:center;line-height:29px"><span style=";font-family:宋体;font-size:19px">图<span style="font-family:Times New Roman">1.1&nbsp;&nbsp;Maven</span><span style="font-family:宋体">标准</span><span style="font-family:Times New Roman">XSD</span><span style="font-family:宋体">的头部信息</span></span></p><p style="text-align:center"><img src="{{site.assets_url}}img/20150712/wpsA6.tmp.jpg" title="wpsA6.tmp.jpg"/></p><p style="text-align: center; "><span style=";font-family:宋体;font-size:19px">图<span style="font-family:Times New Roman">1.2&nbsp;&nbsp;OTA</span><span style="font-family:宋体">标准的</span><span style="font-family:Times New Roman">XSD</span><span style="font-family:宋体">头部信息</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">二、制定“<span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”的过程</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">1<span style="font-family:宋体">、选择定义方式</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">规范<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">格式的方法最常见的有两种：</span><strong><span style="font-family:宋体">一是通过</span><span style="font-family:Times New Roman">DTD</span><span style="font-family:宋体">去定义和验证，二是通过</span><span style="font-family:Times New Roman">XML&nbsp;Schema</span><span style="font-family:宋体">去定义和验证。</span><span style="font-family:Times New Roman">DTD</span><span style="font-family:宋体">的方式较古老，现在用的不是很多</span></strong><span style="font-family:宋体">（</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">Unfortunately&nbsp;<strong>the&nbsp;DTD&nbsp;Syntax&nbsp;was&nbsp;not&nbsp;that&nbsp;powerful</strong>.&nbsp;Written&nbsp;in&nbsp;SGML,&nbsp;DTDs&nbsp;are&nbsp;also&nbsp;not&nbsp;as&nbsp;easy&nbsp;to&nbsp;handle&nbsp;as&nbsp;XML.</span><span style=";font-family:宋体;font-size:19px">），而<span style="font-family:Times New Roman">Schema</span><span style="font-family:宋体">要更灵活，功能更强大，使用更广泛。鉴于报表引擎</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">数据结构还是比较复杂，需要较好的扩展性，且考虑到</span><span style="font-family:Times New Roman">Schema</span><span style="font-family:宋体">使用的广泛性，我们选择了</span><strong><span style="font-family:宋体">用</span><span style="font-family:Times New Roman">XML&nbsp;Schema</span><span style="font-family:宋体">这种方式去定义</span></strong><span style="font-family:宋体">。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">2<span style="font-family:宋体">、选择</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">规范</span><span style="font-family:Times New Roman">(</span><span style="font-family:宋体">和编程工具</span><span style="font-family:Times New Roman">)</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">首先我们想到的就是基于<span style="font-family:Times New Roman">W3C</span><span style="font-family:宋体">的规范。它是最老的，也是用得最多的规范，基于这个规范，可以很好的定义和验证</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">文档。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">不过，我们也没有用到十分特殊的语法，所以，对于其他规范，比如</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">RELAX&nbsp;NG</span><span style=";font-family:宋体;font-size:19px">，应该也是兼容的。</span></p><p style="line-height:29px"><strong><span style=";font-family:宋体;font-size:19px">XML<span style="font-family:宋体">相关的编程工具</span></span></strong><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，有</span></span><strong><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">Apaches&nbsp;Xerces</span><span style=";font-family:宋体;font-size:19px">，<span style="font-family:Times New Roman">DOM4J</span><span style="font-family:宋体">，</span><span style="font-family:Times New Roman">JDOM</span><span style="font-family:宋体">，</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">MSV</span></strong><span style=";font-family:宋体;font-size:19px">（</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">Multi&nbsp;Schema&nbsp;ValidatorMSV</span><span style=";font-family:宋体;font-size:19px">），</span><strong><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">JARV</span></strong><span style=";font-family:宋体;font-size:19px">（</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">Java&nbsp;API&nbsp;for&nbsp;RELAX&nbsp;Verifiers</span><span style=";font-family:宋体;font-size:19px">）等。<strong>经过很多的比较和测试，我们选择了<span style="font-family:Times New Roman">DOM4J</span><span style="font-family:宋体">作为解析</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的工具</span></strong><span style="font-family:宋体">，而</span><strong><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的验证，是基于</span><span style="font-family:Times New Roman">Java</span><span style="font-family:宋体">自带的</span><span style="font-family:Times New Roman">API</span></strong><span style="font-family:宋体">——</span></span><strong><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">JaXP&nbsp;1.1&nbsp;TraX</span></strong><span style=";font-family:宋体;font-size:19px">（</span><strong><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">javax.xml</span><span style=";font-family:宋体;font-size:19px">.*</span></strong><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">），<strong>相比之下，其效率是最好的</strong>。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">3<span style="font-family:宋体">、定义便于扩展的</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">数据结构</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">直接编写<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">，考虑到各种情况，如果不好统一，也可以弄出几个版本。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">4<span style="font-family:宋体">、定义描述和验证</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">Schema</span><span style="font-family:宋体">文档</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">在<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的需求上，</span><strong><span style="font-family:宋体">定义它的</span><span style="font-family:Times New Roman">Schema</span><span style="font-family:宋体">文档</span></strong><span style="font-family:宋体">，主要考虑到<strong>格式的</strong><strong>验证</strong>，<strong>数据结构</strong>的合理性。</span></span></p><p style="line-height:29px"><span style="font-family:宋体"><span class="Apple-style-span" style="font-size: 19px;"><br/></span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">5<span style="font-family:宋体">、编写验证</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的程序&nbsp;</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">使用定义好的<span style="font-family:Times New Roman">xsd</span><span style="font-family:宋体">文件去验证</span><span style="font-family:Times New Roman">xml</span><span style="font-family:宋体">文档。<strong>我</strong>这里<strong>写了</strong></span><strong><span style="font-family:宋体">很多个程序去验证</span><span style="font-family:Times New Roman">xml</span></strong><span style="font-family:宋体">，包括</span></span><strong><span style=";font-family:宋体;font-size:19px"><span style="font-family:Times New Roman">dom4j</span><span style="font-family:宋体">、</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">JARV</span><span style=";font-family:宋体;font-size:19px">、<span style="font-family:Times New Roman">MSV</span><span style="font-family:宋体">等等</span></span></strong><span style=";font-family:宋体;font-size:19px"><span style="font-family:宋体">，<strong>选择效果最好的那个</strong>。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">6<span style="font-family:宋体">、定义</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的体系和版本</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">类似于<span style="font-family:Times New Roman">Maven</span><span style="font-family:宋体">等定义的版本方式，但是没有采用“</span><span style="font-family:Times New Roman">OTA</span><span style="font-family:宋体">”那种复杂的版本定义方式，主要是我认为“</span><span style="font-family:Times New Roman">OTA</span><span style="font-family:宋体">”的版本控制过于复杂和冗余。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">目前我只制定了</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">ReportAddRQ.xml,&nbsp;Version&nbsp;1.0.0</span><span style=";font-family:宋体;font-size:19px">。我认为报表引擎的<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">版本更新不会太频繁，因为每一个版本都对应于不同的解析和验证程序，所以为了简便起见，类似于</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">Version&nbsp;1.0.0</span><span style=";font-family:宋体;font-size:19px">（完整的定义为<span style="font-family:Times New Roman">aa.bb.cc</span><span style="font-family:宋体">，可以从</span><span style="font-family:Times New Roman">0.0.0</span><span style="font-family:宋体">到</span><span style="font-family:Times New Roman">99.99.99</span><span style="font-family:宋体">）这种版本号，</span><span style="font-family:Times New Roman">aa</span><span style="font-family:宋体">表示</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的体系，例如</span><span style="font-family:Times New Roman">1</span><span style="font-family:宋体">就代表</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">ReportAddRQ</span><span style=";font-family:宋体;font-size:19px">这个体系（即新增报表请求的<span style="font-family:Times New Roman">xml</span><span style="font-family:宋体">）；中间那位数字</span><span style="font-family:Times New Roman">bb</span><span style="font-family:宋体">代表大版本号，用于区分一些不同的应用版本（包括一些个性化的要求）；后面的那位数字</span><span style="font-family:Times New Roman">cc</span><span style="font-family:宋体">代表小的版本号，即，在原来版本的基础上进行的一些里程碑式的升级更新。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">程序在验证和解析<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的时候，只需要判断这个</span><span style="font-family:Times New Roman">Version</span><span style="font-family:宋体">便可以立即从</span><span style="font-family:Times New Roman">API</span><span style="font-family:宋体">方法里面寻找到合适的解析、验证方法。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">7<span style="font-family:宋体">、编写整体</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的传递、验证、解析、封装流程</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">如题。需要提到的一点是，<strong><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的传送最好采用加密传输的方式</span></strong><span style="font-family:宋体">，关于加密解密算法，不再本文讨论的访问内。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">另外，传递的时候，版本号要单独传递（独立于<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">文档之外），以便接收方拿到版本号之后，对</span><span style="font-family:Times New Roman">xml</span><span style="font-family:宋体">文档进行验证和解析。</span></span></p><p style="line-height:29px"><br/></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">三、“<span style="font-family:Times New Roman">TRE</span><span style="font-family:宋体">标准”解密</span></span></p><p style="line-height:29px"><br/></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">1<span style="font-family:宋体">、头部定义</span></span></p><p style="line-height:29px"><span style="font-family:宋体"><span class="Apple-style-span" style="font-size: 19px;"><br/></span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">我们定义了默认的名称命名空间<span style="font-family:Times New Roman">(name&nbsp;space)</span><span style="font-family:宋体">，并在名称命名空间中融入了版本号。</span></span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">xmlns=&quot;http://report.zollty.com/TRE/1.0.0&quot;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">第二，我们定义了<span style="font-family:Times New Roman">schema</span><span style="font-family:宋体">文件的网络</span><span style="font-family:Times New Roman">Location</span><span style="font-family:宋体">，以便可以直接通过网络下载此</span><span style="font-family:Times New Roman">xsd</span><span style="font-family:宋体">文件，对</span><span style="font-family:Times New Roman">xml</span><span style="font-family:宋体">进行验证。</span></span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">xsi:schemaLocation=&quot;http://report.zollty.com/TRE/1.0.0&nbsp;http://report.zollty.com/schema/ReportAddRQ-1.0.0.xsd&quot;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">第三，看看它的命名规范，<span style="font-family:Times New Roman">root</span><span style="font-family:宋体">元素名叫“</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">RepoortAddRQ</span><span style=";font-family:宋体;font-size:19px">”，<span style="font-family:Times New Roman">ReportAdd</span><span style="font-family:宋体">是功能性描述，</span><span style="font-family:Times New Roman">RQ</span><span style="font-family:宋体">即</span><span style="font-family:Times New Roman">Request</span><span style="font-family:宋体">，代表这是一个“请求”，同理，如果是</span><span style="font-family:Times New Roman">RS(</span><span style="font-family:宋体">即</span><span style="font-family:Times New Roman">Response)</span><span style="font-family:宋体">，则代表“响应、返回”。其他元素、属性都是以大写开头，“驼峰式”命名法。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">第四，<span style="font-family:Times New Roman">xml</span><span style="font-family:宋体">内容的开始部分，定义了</span><span style="font-family:Times New Roman">xml</span><span style="font-family:宋体">的属性（</span><span style="font-family:Times New Roman">XmlAttr</span><span style="font-family:宋体">），包含了</span><span style="font-family:Times New Roman">Version</span><span style="font-family:宋体">，</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">Token</span><span style=";font-family:宋体;font-size:19px">，</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">TimeStamp</span><span style=";font-family:宋体;font-size:19px">等基本信息。这一部分的内容针对不同的<span style="font-family:Times New Roman">XML&nbsp;Version</span><span style="font-family:宋体">，是可以任意改变的。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">2<span style="font-family:宋体">、</span><strong><span style="font-family:宋体">元素</span><span style="font-family:Times New Roman">Type</span><span style="font-family:宋体">的定义</span></strong></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">我采用了元素和元素的<span style="font-family:Times New Roman">Type</span><span style="font-family:宋体">分开定义的方式。以</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">XmlAttr</span><span style=";font-family:宋体;font-size:19px">为例，如下图：</span></p><p style="text-align: center; "><img src="{{site.assets_url}}img/20150712/wpsA9.tmp.jpg" title="wpsA9.tmp.jpg"/></p><p style="text-align:center;line-height:29px"><span style=";font-family:宋体;font-size:19px">图<span style="font-family:Times New Roman">3.3&nbsp;&nbsp;</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">XmlAttr</span><span style=";font-family:宋体;font-size:19px">元素的定义</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="text-align: center; "><img src="{{site.assets_url}}img/20150712/wpsAA.tmp.jpg" title="wpsAA.tmp.jpg"/><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="text-align:center;line-height:29px"><span style=";font-family:宋体;font-size:19px">图<span style="font-family:Times New Roman">3.4&nbsp;&nbsp;</span></span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">XmlAttr</span><span style=";font-family:宋体;font-size:19px">元素<span style="font-family:Times New Roman">Type</span><span style="font-family:宋体">的定义（片段）</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">这种定义方式的好处在于：使元素的定义更加清晰，而且使得某些类型可以重用。</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">3<span style="font-family:宋体">、</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的<strong>组装、验证和传递</strong></span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">1<span style="font-family:宋体">）组装入口，示例如下：</span></span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">if(VERSION_1_0_0.equals(version)){</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">xmlStr&nbsp;=&nbsp;createXmlVer1_0_0(xmlParams,version);</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">}</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">就是根据不同的版本，调用不同的方法去组装<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">2<span style="font-family:宋体">）传递方式，示例如下：</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">x</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">ml</span><span style=";font-family:宋体;font-size:19px">Str</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">&nbsp;=&nbsp;EncryptTools.getEncryptedStr(attrsXml);</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">originalStr.append(&quot;&amp;&quot;).append(version);</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">originalStr.append(&quot;&amp;&quot;).append(</span><span style=";font-family:宋体;font-size:19px">x</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">ml</span><span style=";font-family:宋体;font-size:19px">Str</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">);</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">其中<span style="font-family:Times New Roman">xmlStr</span><span style="font-family:宋体">加密过，类似于</span><span style="font-family:Times New Roman">d94b3c5a7f646d8e....</span><span style="font-family:宋体">这种形式，同时注意到传递了版本号</span><span style="font-family:Times New Roman">version</span><span style="font-family:宋体">参数。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">3<span style="font-family:宋体">）</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的验证，入口示例如下：</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">//&nbsp;xml<span style="font-family:宋体">格式校验</span></span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">InputStream&nbsp;xsdIn&nbsp;=&nbsp;RequestTools.class</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">.getResourceAsStream(&quot;ReportAddRQ-&quot;+version+&quot;.xsd&quot;);</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">StreamSource&nbsp;xsdSource&nbsp;=&nbsp;new&nbsp;StreamSource(xsdIn);</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">XmlSaxErrorHandler&nbsp;errorHandler&nbsp;=&nbsp;XMLUtils.xmlValidator(xmlStr,&nbsp;xsdSource);</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">if(!errorHandler.isSuccess()){</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">throw&nbsp;new&nbsp;RuntimeException(errorHandler.getErrorMsg());</span></p><p style="line-height:29px"><span style=";font-family:&#39;Times New Roman&#39;;font-size:19px">}</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">根据不同的版本号，调用不同的验证规则<span style="font-family:Times New Roman">xsd</span><span style="font-family:宋体">文件去验证它。</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">关于这个<span style="font-family:Times New Roman">XMLUtils</span><span style="font-family:宋体">里面的验证方法，我写了一整套，下面仅列举其中的核心方法：</span></span></p><p><img src="{{site.assets_url}}img/20150712/wpsAB.tmp.jpg" title="wpsAB.tmp.jpg"/><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p><img src="{{site.assets_url}}img/20150712/wpsAC.tmp.jpg" title="wpsAC.tmp.jpg"/><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">&nbsp;</span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">4<span style="font-family:宋体">、</span><span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">的解析和封装</span></span></p><p style="line-height:29px"><span style=";font-family:宋体;font-size:19px">将<span style="font-family:Times New Roman">XML</span><span style="font-family:宋体">解析出来，封装成</span><span style="font-family:Times New Roman">JavaBean</span><span style="font-family:宋体">，我用的是</span><strong><span style="font-family:Times New Roman">dom4j</span></strong><span style="font-family:宋体">，仅举一例来说明吧：</span></span></p><pre class="brush:java;toolbar:false">/**
&nbsp;*&nbsp;解析任务请求的特定格式的XML
&nbsp;*&nbsp;@param&nbsp;xml&nbsp;待解析的XML字符串，其格式应严格为：
&nbsp;*&nbsp;@return&nbsp;封装好的参数Bean
&nbsp;*&nbsp;@author&nbsp;zollty&nbsp;&lt;br&gt;2012-12-17
&nbsp;*/
public&nbsp;static&nbsp;ParamsXMLBean&nbsp;xmlParser(String&nbsp;xml){
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringReader&nbsp;sr&nbsp;=&nbsp;new&nbsp;StringReader(xml);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SAXReader&nbsp;reader&nbsp;=&nbsp;new&nbsp;SAXReader();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.setEncoding(&quot;UTF-8&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Document&nbsp;document&nbsp;=&nbsp;reader.read(sr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element&nbsp;root&nbsp;=&nbsp;document.getRootElement();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Element&gt;&nbsp;formAttrsElement&nbsp;=&nbsp;root.element(&quot;FormAttrs&quot;).elements();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String,FormVO&gt;&nbsp;formAttrs&nbsp;=&nbsp;new&nbsp;LinkedHashMap&lt;String,&nbsp;FormVO&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormVO&nbsp;fvo&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Element&nbsp;element&nbsp;:&nbsp;formAttrsElement)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;element.element(&quot;Name&quot;).getText().trim();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fvo&nbsp;=&nbsp;new&nbsp;FormVO();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fvo.setName(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fvo.setValue(element.element(&quot;Value&quot;).getText().trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;null!=element.element(&quot;Title&quot;)&nbsp;){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fvo.setTitle(element.element(&quot;Title&quot;).getText().trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fvo.setTitle(&quot;&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;null!=element.element(&quot;DisName&quot;)&nbsp;){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fvo.setDisName(element.element(&quot;DisName&quot;).getText().trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fvo.setDisName(&quot;&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formAttrs.put(name,&nbsp;fvo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Element&gt;&nbsp;otherAttrsElement&nbsp;=&nbsp;root.element(&quot;OtherAttrs&quot;).elements();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String,OthersVO&gt;&nbsp;otherAttrs&nbsp;=&nbsp;new&nbsp;LinkedHashMap&lt;String,&nbsp;OthersVO&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OthersVO&nbsp;ovo&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Element&nbsp;element&nbsp;:&nbsp;otherAttrsElement)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;element.element(&quot;Name&quot;).getText().trim();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ovo&nbsp;=&nbsp;new&nbsp;OthersVO();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ovo.setName(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ovo.setValue(element.element(&quot;Value&quot;).getText().trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;null!=element.element(&quot;Extra&quot;)&nbsp;){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ovo.setValue(element.element(&quot;Extra&quot;).getText().trim());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherAttrs.put(name,ovo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ParamsXMLBean&nbsp;paramsXMLBean&nbsp;=&nbsp;new&nbsp;ParamsXMLBean();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramsXMLBean.setFormAttrs(formAttrs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paramsXMLBean.setOtherAttrs(otherAttrs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;paramsXMLBean;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(Exception&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><br/></p><p><br/></p>