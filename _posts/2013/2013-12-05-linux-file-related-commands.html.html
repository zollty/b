---
layout: ue
title: Linux系统文件相关的命令
category: Linux系统与应用
tags: Linux
keywords: "linux,文件命令"
---

<p style='line-height: 1;'><br/></p><h3>一、拷贝文件（包括隐藏文件）</h3><p>1、cp命令 常用参数说明：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>-r或-R <span style="color: rgb(192, 0, 0);">递归</span></p></li><li><p>-f <span style="color: rgb(192, 0, 0);">覆盖</span></p></li><li><p>-u <span style="color: rgb(192, 0, 0);">仅更新</span></p></li><li><p>-p&nbsp;&nbsp;<span style="color: rgb(192, 0, 0);">保留文件属性</span> (default:mode,ownership,timestamps), if possible additional attributes: context, links, xattr, all</p></li><li><p>-d或-P&nbsp; 保留符号链接&nbsp;</p></li><li><p>-a （--archive，<span style="color: rgb(192, 0, 0);">归档</span>的意思）相当于 -dpR 或者 -dR --preserve=all（-p和--preserve=all意思差不多）</p></li></ul><p>2、拷贝<span style="color: rgb(192, 0, 0);">目录下的所有文件</span>（包括隐藏文件）：<br/></p><p><strong>cp&nbsp; &nbsp;-a&nbsp; &nbsp;/src<span style="color: rgb(192, 0, 0);">/.</span>&nbsp; &nbsp; /dist<span style="color: rgb(192, 0, 0);">/</span></strong></p><p>参数说明：-r为递归拷贝，-f为强制覆盖已存在的文件。</p><p>3、连带<span style="color: rgb(192, 0, 0);">外层目录</span>一起拷贝（包括隐藏文件）：</p><p><strong>cp -a /demo/src /dist/</strong></p><p style='line-height: 1;'><br/></p><h3>二、混合隐藏文件的处理（删除、剪切、拷贝）</h3><p>1、问题分析（ 想看结论的直接看3 ）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux下面以 `.` 开头的文件为隐藏文件。另外，linux中还有两个特殊目录：`.` 和 `..`，有时候需要特殊处理。</p><p>&nbsp; &nbsp; 所谓 “混合隐藏文件”，是指操作的文件中，<span style="color: rgb(192, 0, 0);">可能</span>既有隐藏文件又有非隐藏文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通常的场景为：<br/></p><ol class="custom_num1 list-paddingleft-1"><li class="list-num-2-1 list-num1-paddingleft-1"><p>剪切(移动)一个目录下的所有内容或者部分内容（内容包括文件和目录，且文件中可能有隐藏文件）</p></li><li class="list-num-2-2 list-num1-paddingleft-1"><p>拷贝、删除一个目录下的所有内容</p></li><li class="list-num-2-3 list-num1-paddingleft-1"><p>拷贝、删除一个目录下的部分内容<br/></p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;特别注意：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 若是针对 目录 和 非隐藏文件，则无需考虑隐藏文件问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例来说，我要拷贝（删除、移动）某个目录下的几个非隐藏文件，则直呼其名就行了，示例如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <span style="color: rgb(192, 0, 0);">cp -a&nbsp;<em>src/aaa src/bbb src/*.doc&nbsp; &nbsp;</em>/dist</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，针对场景2，<span style="color: rgb(192, 0, 0);">“拷贝、删除一个目录下的所有内容”</span>，很容易实现：</p><p>拷贝目录下的所有：<span style="color: rgb(192, 0, 0);">cp -a /src/.&nbsp; /target/</span></p><p>删除目录下的所有：<span style="color: rgb(192, 0, 0);">rm -rf /src &amp;&amp; mkdir -p /src</span></p><p style='line-height: 1;'><br/></p><p>2、总体策略</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(12, 12, 12);">方法一，使用通配符，分两批操作（隐藏文件一批，非隐藏文件一批）</span><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;例如：<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;rm&nbsp; &nbsp;-rf&nbsp; &nbsp; *&nbsp; &nbsp; .[^.]*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;mv&nbsp; &nbsp;*&nbsp; &nbsp; .[^.]*&nbsp; &nbsp; /dist/</p><p>&nbsp; &nbsp; cp&nbsp; -a&nbsp; src/*&nbsp; &nbsp;src/.[^.]*&nbsp; &nbsp;/dist/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;说明：第一个*匹配除了隐藏文件的所有文件，第二个参数 .[^.]* 匹配隐藏文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;表达式<span style="color: rgb(192, 0, 0);"> .[^.]* </span>的解释如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;以<span style="color: rgb(192, 0, 0);">.</span>开头，<span style="color: rgb(192, 0, 0);">加不是.的一个任意字符</span>，再加其他任意字符（*）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;为什么不用 “.*” ？ 因为 .* 会匹配 . 和 .. 这两个特殊目录。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;注意，.[^.]*不是正真意义上的正则表达式，<span style="color: rgb(192, 0, 0);">普通ls、rm、mv、cp等命令只支持通配符</span>，不支持完整的正则表达式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(192, 0, 0);">方法二（推荐）：使用ls -A + 支持正则表达式的过滤命令</span>（例如grep、sed或awk）。<br/></p><p>&nbsp; &nbsp; ls -A 等价于：ls -a egrep -v &quot;^\.$|^\.\.$&quot;&nbsp; （即ls -a排除掉特殊目录`.`和`..`）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的几个例子，可以用<span style="color: rgb(192, 0, 0);">下面的解法</span>：<br/></p><p>&nbsp; &nbsp; ls -A | xargs -i rm -rf {}</p><p>&nbsp; &nbsp; ls -A | xargs -i mv {} /dist/</p><p>&nbsp; &nbsp; ls -A <span style="color: rgb(192, 0, 0);">/opt/src</span> | xargs -i cp -a <span style="color: rgb(192, 0, 0);">/opt/src/</span>{} /dist/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;注意 ls -A /opt/src打印出来的值是<span style="color: rgb(192, 0, 0);">没有 /opt/src路径的</span>，所以后面 cp等指令<span style="color: rgb(192, 0, 0);">务必跟上路径</span>。<br/></p><p style='line-height: 1;'><br/></p><p><span style="color: rgb(192, 0, 0);"><strong>3、总结</strong></span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;1）<strong>剪切(移动)一个目录下的<span style="color: rgb(192, 0, 0);">所有</span>内容</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;ls -A | xargs -i mv {} /dist/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ls -A <span style="color: rgb(192, 0, 0);">/opt/src</span> | xargs -i mv <span style="color: rgb(192, 0, 0);">/opt/src/{}</span> /dist/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2）<strong>剪切、拷贝、删除一个目录下的<span style="color: rgb(192, 0, 0);">部分</span>内容</strong><br/></p><p>&nbsp; &nbsp; ls -A <span style="color: rgb(192, 0, 0);">/opt/src </span>| <span style="color: rgb(192, 0, 0);">egrep -v &quot;^target&quot;</span>&nbsp;| xargs -i mv <span style="color: rgb(192, 0, 0);">/opt/src/{}</span> /dist/</p><p style='line-height: 1;'><br/></p><p>4、延伸：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;剪切、拷贝、删除的对象为“从一个目录的<span style="color: rgb(192, 0, 0);">任意子目录中筛选出部分内容</span>”，怎么办？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;答案：<strong>先使用find、locate、whereis等命令查找到文件，得到全路径再做处理</strong>。例如：</p><p>rm -rf <span style="color: rgb(192, 0, 0);">$(</span>find /src/ -maxdepth 2 -mindepth 1 -name &quot;*er&quot;<span style="color: rgb(192, 0, 0);">)&nbsp; || true</span></p><p>mv -f <span style="color: rgb(192, 0, 0);">$(</span>find /src/ -maxdepth 2 -mindepth 1 -name &quot;*er&quot;<span style="color: rgb(192, 0, 0);">)</span>&nbsp; /dist/&nbsp;<span style="color: rgb(192, 0, 0);"> || true</span></p><p>或者：</p><p><span style="color: rgb(192, 0, 0);">find&nbsp; /src/ -maxdepth 2 -mindepth 1 -name &quot;*er&quot;</span> <strong>|</strong> xargs <span style="color: rgb(192, 0, 0);">-r</span> rm -rf</p><p>find&nbsp; /src/ -maxdepth 2 -mindepth 1 -name &quot;*er&quot; <strong>|</strong> xargs <span style="color: rgb(192, 0, 0);">-i</span> -r mv -f <span style="color: rgb(192, 0, 0);">{}</span>&nbsp; /dist/&nbsp;（推荐）</p><p>注意，<span style="color: rgb(192, 0, 0);">使用find、locate等命令查找文件后，再做删除、移动时，有一个缺点，那就是目录不能为空</span>，否则mv或rm就会报错。</p><p>解决方案1：<strong>xargs 加上 -r (--no-run-if-empty) 参数</strong>（注意 <strong>-r </strong>option is a GNU extension，使用时最好测试一下）</p><p>解决方案2：可能报错的命令后面跟上“<span style="color: rgb(192, 0, 0);"> || true</span>” 或者“<span style="color: rgb(192, 0, 0);"> || :</span>”，例如：</p><p>mv -f /src/* /dist/ || true</p><p>mv -f /src/* /dist/ || :</p><p>说明：true 或者 ‘:’ 都代表什么都不做，但返回success、状态码0（可以打印echo $?查看上一个指令的状态码）</p><pre class="brush:bash;toolbar:false">$ type -a true
true is a shell builtin
true is /usr/bin/true
true is /bin/true

$ type -a :
: is a shell builtin</pre><p>扩展：排除某个（某些）文件<br/></p><p>例如删除除app以外的其他文件（包括隐藏文件）</p><p>find&nbsp; /src/ -maxdepth 1 -mindepth 1 <strong><span style="color: rgb(192, 0, 0);">! -name &quot;app&quot;</span></strong> | xargs -r rm -rf</p><p>推荐下面的写法（只排除ee和.cc两个文件）：</p><p>ls -A | egrep -v &quot;^\.$|^\.\.$|<span style="color: rgb(192, 0, 0);">^ee$</span>|<span style="color: rgb(192, 0, 0);">^.cc$</span>&quot; | xargs -r rm -rf</p><p style='line-height: 1;'><br/></p><p style='line-height: 1;'><br/></p><h3 style="color: rgb(0, 0, 0); white-space: normal;">简单命令</h3><p><strong>查看磁盘使用率</strong></p><p>df -h</p><p style='line-height: 1;'><br/></p><p><strong>动态查看文件内容</strong></p><p>tail -f FILE_NAME</p><p style='line-height: 1;'><br/></p><p><strong>删除文件使用实例：</strong></p><p>rm -f /var/log/httpd/access.log</p><p>将会强制删除/var/log/httpd/access.log这个文件</p><p style='line-height: 1;'><br/></p><p>删除文件夹实例：</p><p>rm -rf /var/log/httpd/access</p><p>将会删除/var/log/httpd/access目录以及其下所有文件、文件夹</p><p style='line-height: 1;'><br/></p><p>使用这个rm -rf的时候一定要格外小心，linux没有回收站的</p><p style='line-height: 1;'><br/></p><p><strong>新建文件 或 文件夹</strong></p><p>touch test.txt</p><p>mkdir -pv /opt/lib/jvm</p><p>-p代表递归创建文件夹 -v代表显示创建文件夹的过程</p><p style='line-height: 1;'><br/></p><p><strong>拷贝文件/文件夹</strong></p><p>单个文件：cp -u -v lib/report.jar /tmp/report.jar</p><p>多个文件至一个目录： cp -u -v lib/*.jar /tmp</p><p>目录到目录：cp -rf /lib/plugins/.&nbsp; /tmp/plugins</p><p style='line-height: 1;'><br/></p><p><strong>统计文件行数</strong></p><p>wc -lcw</p><p>例如： $ wc - lcw file1.log file2.log</p><p>&nbsp;34106&nbsp; &nbsp;655146&nbsp; &nbsp; 17831207 file1.log</p><p>&nbsp;7&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;52&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5445212&nbsp; file2.log</p><p>每行对应行数、字数、字节数、文件名 如果命令行中没有文件名，则输出中不出现文件名。 <br/></p><p style='line-height: 1;'><br/></p><p style='line-height: 1;'><br/></p><p><strong>相关问题</strong></p><div class="subject-title" onclick="toggleContent(this,'#ykepxv');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>Linux删除文件时报错Argument list too long</p><p>unable to execute /bin/rm: Argument list too long</p></div><div id="ykepxv" class="subject-content" style="display:none;"><p>解决方法：</p><p>ls | xargs -n 10 rm -fr ls</p><p>就解决了，这句解释为：输出所有的文件名(用空格分割) xargs就是将ls的输出，每10个为一组(以空格为分隔符)，作为rm -rf的参数也就是说将所有文件名10个为一组，由rm -rf删除，这样就不会超过命令行的长度了。<br/></p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#244cc9');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>cp -r /lib/plugins/* /tmp/plugins 这个命令有两个问题</p></div><div id="244cc9" class="subject-content" style="display:none;"><p>1、无法拷贝.开头的隐藏文件或目录</p><p>&nbsp;&nbsp;&nbsp;&nbsp;正确拷贝整个目录（包括隐藏文件）的方法是用“.”表示目录，而不是用“*”： /lib/plugins/.</p><p>2、如果后一个目录已经存在某个文件，则不会覆盖。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;强制覆盖的方法为：cp -rf&nbsp;</p><p style='line-height: 1;'><br/></p><p>所以推荐的写法为：</p><p>cp -rf /lib/plugins/.&nbsp; /tmp/plugins<br/></p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#ce8c78');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>删除文件时，排除文件、排除目录</p></div><div id="ce8c78" class="subject-content" style="display:none;"><p>以当前目录为基准 保留一文件+一文件夹&nbsp;</p><p>rm -rf `ls|egrep -v &#39;(config.js|dist)&#39;`</p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#z9dv3z');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>查看目录大小<br/></p></div><div id="z9dv3z" class="subject-content" style="display:none;"><p>du -h --max-depth=1 /home/tomcat</p><p style='line-height: 1;'><br/></p><p>查看 包括.开头的隐藏文件在内的所有文件大小</p><p>du -sh .[!.]* *（参见：<a href="https://blog.csdn.net/rav009/article/details/53049441">https://blog.csdn.net/rav009/article/details/53049441</a>）</p><p style='line-height: 1;'><br/></p><p>查看时按size排序：后面加上&nbsp; “| sort -hr”</p><p style='line-height: 1;'><br/></p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#5yay3x');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>以尺寸大小排列文件和目录&nbsp;</p></div><div id="5yay3x" class="subject-content" style="display:none;"><p>ls -lSr |more&nbsp;</p><p style='line-height: 1;'><br/></p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#8x4c26');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>查看文件夹下面的文件个数：</p></div><div id="8x4c26" class="subject-content" style="display:none;"><p>find ./ -type f | wc -l</p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#k6vxzd');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>查找并替换文件里的字符串内容</p></div><div id="k6vxzd" class="subject-content" style="display:none;"><p>sed -i &quot;s/oldstring/newstring/g&quot; filename</p><p>说明：-i选项是直接在文件中替换，不在终端输出。</p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#gdzzac');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>查找文件</p></div><div id="gdzzac" class="subject-content" style="display:none;"><p>在当前目录下，<strong>递归深度为2，寻找*est文件或文件夹</strong></p><p>find . -maxdepth 2 -name &quot;*est&quot;</p><p style='line-height: 1;'><br/></p><p><strong>查找*.ps文件，列出其完整路径：</strong>&nbsp;</p><p>locate \*.ps</p><p style='line-height: 1;'><br/></p><p><strong>查找某个文件，并删除：</strong></p><p>/bin/find /opt/app/tmp/ -maxdepth 2 -name &quot;aaa.war&quot; -exec /bin/rm -rf {} \;</p><p>等价于</p><p>find /opt/app/tmp/ -maxdepth 2 -name &quot;aaa.war&quot; | xargs rm -rf&nbsp;</p><p style='line-height: 1;'><br/></p><p>按文件名称找出所有文件，并将每个文件的上一级目录删除掉。</p><p>比如，在&nbsp; &nbsp;/opt/app/tmp/&nbsp; 目录下，有如下一些文件夹</p><pre class="brush:plain;toolbar:false">/3j001-tokmza-i5ezsq6t-1-i5ezsxa7-v/amps-dcm.war
/3j001-txjxsz-i5ezkjrf-1-i5ezl2h8-9q/amps-dcm.war
/3j001-5woh4c-i5f0eruz-1-i5f0fbhg-9r/admin-console.war
.......</pre><p>我们的目标是把所有包含 amps-dcm.war的临时目录全部删除</p><pre class="brush:bash;toolbar:false">find /opt/app/tmp/ -maxdepth 2 -name &quot; amps-dcm.war&quot; \
    | xargs echo | sed -r &#39;s/^(\/.*\/)[^/]+\/?/\1/g&#39; \
    | xargs rm -rf</pre><p>其中&nbsp; | sed -r &#39;s/^(\/.*\/)[^/]+\/?/\1/g&#39;&nbsp; 的意思是 字符串截取，路径中最后一个目录后面的字符，例如</p><p>echo &quot;/etc/rc.d/&quot; | sed -r &#39;s/^(\/.*\/)[^/]+\/?/\1/g&#39;</p><p>结果 是&nbsp; /etc/</p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#83xey9');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>查看文件的指定行</p></div><div id="83xey9" class="subject-content" style="display:none;"><p>例如，查看第5~10行内容：</p><p>sed -n &#39;5,10p&#39; filename</p><p style='line-height: 1;'><br/></p></div><div class="subject-title" onclick="toggleContent(this,'#ch2vkc');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>查找某目录下包含关键字内容的文件</p></div><div id="ch2vkc" class="subject-content" style="display:none;"><p>如下：</p><pre class="brush:bash;toolbar:false">grep -r &quot;查询内容&quot;  文件目录
#这样查询出来的包括文件名+内容

grep -r -l &quot;查询内容&quot;  文件目录
#这样只显示包含内容的文件名

find 文件目录  -type f |xargs grep &quot;查询内容&quot;
#也可以达到效果</pre><p style='line-height: 1;'><br/></p></div><p style='line-height: 1;'><br/></p><p><strong>vim字符串查找</strong></p><p>直接输入 斜杠/ 然后输入查找的字符串</p><p>下一个，n是向前找,N是向后找</p><p style='line-height: 1;'><br/></p><p style='line-height: 1;'><br/></p><p><strong>从linux上传文件到linux服务器的命令如下：</strong></p><p>scp local_file remote_user@host:remote_folder</p><p>例如：</p><p>scp 下载/kafka_2.11-0.9.0.1.tgz kafka@172.16.1.170:/home/kafka</p><p style='line-height: 1;'><br/></p><div class="subject-title" onclick="toggleContent(this,'#49cx6k');"><p class="subject-info">＋ (点击以下标题显示正文内容)</p><p>tar命令</p></div><div id="49cx6k" class="subject-content" style="display:none;"><p>解压</p><p>语法：tar [主选项+辅选项] 文件或者目录</p><p>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。</p><p style='line-height: 1;'><br/></p><p>主选项：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。</p></li><li><p>x 从档案文件中释放文件。相当于拆包。</p></li><li><p>t 列出档案文件的内容，查看已经备份了哪些文件。</p></li></ul><p>特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。</p><p style='line-height: 1;'><br/></p><p>辅助选项：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz</p></li><li><p>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩或解压？一般格式为xx.tar.bz2&nbsp;&nbsp;</p></li><li><p>-v ：压缩的过程中显示文件！这个常用</p></li><li><p>-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！</p></li><li><p>-p ：使用原文件的原来属性（属性不会依据使用者而变）</p></li><li><p>--exclude FILE：在压缩的过程中，不要将 FILE 打包！</p></li></ul><p style='line-height: 1;'><br/></p><p>范例：</p><p>范例一：将整个 /etc&nbsp; 打包 成为 /tmp/etc.tar</p><p>[root@linux ~]# tar -cvf /tmp/etc.tar /etc　　　　&lt;==仅打包，不压缩！</p><p>[root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc　　&lt;==打包后，以 gzip 压缩</p><p>[root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc　　&lt;==打包后，以 bzip2 压缩</p><p style='line-height: 1;'><br/></p><p># 特别注意，在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。</p><p># 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～</p><p># 如果加 j 参数，则以 .tar.bz2 来作为附档名啊～</p><p># 上述指令在执行的时候，会显示一个警告讯息：</p><p># 『tar: Removing leading `/&quot; from member names』那是关於绝对路径的特殊设定。</p><p style='line-height: 1;'><br/></p><p>范例二：查阅上述 /tmp/etc.tar.gz 文件内有哪些文件？</p><p>[root@linux ~]# tar -ztvf /tmp/etc.tar.gz</p><p># 由於我们使用 gzip 压缩，所以要查阅该 tar file 内的文件时，</p><p># 就得要加上 z 这个参数了！这很重要的！</p><p style='line-height: 1;'><br/></p><p>范例三：将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下</p><p>[root@linux ~]# cd /usr/local/src</p><p>[root@linux src]# tar -zxvf /tmp/etc.tar.gz</p><p># 在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说</p><p># 我先将工作目录变换到 /usr/local/src 底下，并且解开 /tmp/etc.tar.gz</p><p># 则解开的目录会在 /usr/local/src/etc ，另外，如果您进入 /usr/local/src/etc</p><p># 则会发现，该目录下的文件属性与 /etc/ 可能会有所不同喔！</p><p style='line-height: 1;'><br/></p><p>范例四：在 /tmp 底下，我只想要将 /tmp/etc.tar.gz 内的 etc/passwd 解开而已</p><p>[root@linux ~]# cd /tmp</p><p>[root@linux tmp]# tar -zxvf /tmp/etc.tar.gz etc/passwd</p><p># 我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，如果单只要一个文件，</p><p># 就可以透过这个方式来下达！注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！</p><p style='line-height: 1;'><br/></p><p><strong>-C命令指定路径：&nbsp;</strong></p><p>$ tar -cvf file2.tar -C /home/usr2 file2</p><p>&nbsp;&nbsp;&nbsp;&nbsp;该命令中的-C dir参数，将tar的工作目录从当前目录改为/home/usr2，将file2文件（不带绝对路径）压缩到file2.tar中。注意 ：-C dir参数的作用在于改变工作目录，其有效期为该命令中下一次-C dir参数之前。&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用tar的-C dir参数，同样可以做到在当前目录/home/usr1下将文件解压缩到其他目录，例如：&nbsp;</p><p>$ tar -xvf file2.tar -C /home/usr2</p><p style='line-height: 1;'><br/></p><p style='line-height: 1;'><br/></p></div><script type="text/javascript">var toggleContent=function(that, id){var tx="－ (点击以下标题隐藏正文内容)";if($(id).css("display")!="none"){tx="＋ (点击以下标题显示正文内容)"}$(that).children(":first").text(tx);$(id).fadeToggle(100)};</script>