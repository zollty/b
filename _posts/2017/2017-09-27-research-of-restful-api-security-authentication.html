---
layout: ue
title: REST API安全认证研究
category: 系统架构和设计
tags: API安全认证
keywords: "restful,api,安全认证"
---

<p><br/></p><p><span style="font-size: 20px;"><strong>一、概述</strong></span></p><p><br/></p><p>&nbsp; &nbsp; 对外网暴露的RESTful API，由于是无状态的，如果不做认证，那就相当于裸奔的，任何人都可以调用，随意调用，这样是极不安全的。下面就RESTful API的安全性方案进行了一些研究。</p><p>&nbsp; （但是首先建议，核心系统的API不对外网暴露，只允许内网调用，而且不建议做成HTTP RESTful形式。如果非要使用RESTful API对外网暴露接口，那么请看下面）。</p><p><br/></p><p>RESTful API的安全性，包括了如下三个方面：&nbsp;</p><p>a) 对客户端做身份认证&nbsp;</p><p>b)&nbsp;各种安全防护措施&nbsp;</p><p>c) 身份认证之后的授权&nbsp;</p><p><br/></p><p>1、对客户端做身份认证</p><p>面向最终用户的API，采用HTTPS + OAUTH 2的方式来认证比较好。</p><p>面向服务器的API，则比较简单，方式比较多。</p><p>2、各种安全防护措施</p><p>包括：防止敏感数据泄露，防篡改，防重放攻击，防DDoS攻击。应对方案包括：</p><p>采用HTTPS；DDoS流量清洗；对敏感数据部分加盐再加密传输；在请求中增加一次性的Token。</p><p>3、身份认证之后的授权，由应用服务器端根据业务需求自己实现，比如安全框架Shiro、SpringSecurity等。</p><p><br/></p><p><span style="font-size: 20px;"><strong>考虑两种黑客攻击情况</strong></span></p><p>1、针对HTTP的网络劫持；</p><p>2、针对HTTPS的中间人攻击+SSLstrip</p><p><br/></p><p>防御措施，要点如下：</p><p>1、全站采用HTTPS</p><p>2、客户端、WEB端的数据单向加密传输</p><p><br/></p><p>采用全站HTTPS后，能避免绝大多数的攻击。而针对HTTPS的攻击，难度很大（目前市面上对HTTPS成功的攻击还是比较少见），如果不是非常非常核心的数据，是可以不考虑特殊保护的。</p><p><br/></p><p>针对HTTPS的进一步保护手段，是采用数据加密，对客户端和WEB端用户发送的数据，进行加密再传输，即使被黑客获取了，也无法篡改和利用。</p><p><br/></p><p><span style="font-size: 20px;"><strong>二、客户端身份认证方案</strong></span></p><p><br/></p><p><strong>1、客户端会话认证</strong><br/></p><p>&nbsp; &nbsp; 两种大的方案：</p><p>a）基于服务器端（分布式）Session技术</p><p>b）基于JWT（Json Web Token）技术</p><p>通常来说，针对Web&nbsp;浏览器端的应用，基本用（a）方案，而手机APP端的应用，一般用（b）方案。</p><p><br/></p><p><strong>分布式Session技术</strong></p><p>基本上都是用Redis来存储Session信息。Session的方案比较常规，不做过多说明。<br/></p><p><br/></p><p><strong>JWT技术（基于token的鉴权机制）</strong></p><p>流程上是这样的：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>用户使用用户名密码来请求服务器<br/></p></li><li><p>服务器进行验证用户的信息</p></li><li><p>服务器通过验证后生成一个token发送给用户</p></li><li><p>客户端存储token，并在每次请求时附送上这个token值</p></li><li><p>服务端验证token值，并返回数据</p></li></ol><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *</p><p><br/></p><p>&nbsp; &nbsp; JWT和Session技术的根本区别在于，Session是把访问者信息存储在服务器端的，而JWT是把信息存储在客户端。</p><p>&nbsp; &nbsp; Session方式存储用户信息的最大弊病在于要占用大量服务器内存，要保存许多的状态。一般而言，大型应用还需要借助缓存机制来实现Session的存储。</p><p>&nbsp; &nbsp; 而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员等。</p><p>&nbsp; &nbsp; JWT方式，每次请求都要带上token，服务器每次都要解密出token的信息，这会让服务器有一些计算压力。而且，如果客户端的信息比较多，每次HTTP请求携带的数据就比较多。还有一点，JWT在客户端的存储，不能包含敏感信息，否则很容易被泄露，而且不建议在客户端存储会变动的信息，否则可能出现一致性问题。</p><p>&nbsp;</p><p><strong>JWT长什么样？</strong></p><p>&nbsp; &nbsp; JWT是由三段信息（header.payload.signature）构成的，将这三段信息文本用英文句号链接一起就构成了JWT字符串。例如：<br/></p><p><span style="font-size: 14px; color: rgb(0, 176, 80);">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span style="font-size: 14px;">.<span style="font-size: 14px; color: rgb(0, 112, 192);">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span>.<span style="font-size: 14px; color: rgb(192, 0, 0);">TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br/></p><p>&nbsp; &nbsp; 可以在&nbsp;<a href="https://jwt.io/">https://jwt.io/</a>&nbsp;这个网站，把token解析出来。</p><p><br/></p><p><strong>JWT的构成</strong></p><p>&nbsp; &nbsp; 第一部分我们称它为头部（header)，</p><p>&nbsp; &nbsp; 第二部分我们称其为承载（payload, 类似于飞机上承载的物品)，</p><p>&nbsp; &nbsp; 第三部分是签证（signature)。</p><p><br/></p><p><strong>header</strong></p><p>完整的头部就像下面这样的JSON：</p><p>{</p><p>&nbsp; &#39;typ&#39;: &#39;JWT&#39;,</p><p>&nbsp; &#39;alg&#39;: &#39;HS256&#39;</p><p>}</p><p>即声明 类型 和 加密的算法。然后将头部进行base64加密，就构成了header部分。</p><p><br/></p><p><strong>playload</strong></p><p>承载就是存放有效信息的地方。这个名字像是指飞机上承载的货品，这些有效信息包含三个部分声明（Claims）</p><p>&nbsp; &nbsp; 标准中注册的声明</p><p>&nbsp; &nbsp; 公共的声明</p><p>&nbsp; &nbsp; 私有的声明</p><p><br/></p><p>标准中注册的声明 (建议但不强制使用) ：</p><p>iss: jwt签发者</p><p>sub: jwt所面向的用户</p><p>aud: 接收jwt的一方</p><p>exp: jwt的过期时间，这个过期时间必须要大于签发时间</p><p>nbf: 定义在什么时间之前，该jwt都是不可用的.</p><p>iat: jwt的签发时间</p><p>jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</p><p><br/></p><p><strong>signature</strong></p><p>signature是一个签证信息，它会用到前面的header、payload信息，以及一个密匙（secret）。</p><p>即，这个部分需要 base64加密后的header 和 base64加密后的payload，使用 英文句号 连接组成的字符串，然后通过header中声明的加密方式，进行加盐secret组合加密，然后就构成了jwt的第三部分signature。</p><p><br/></p><p><strong>JWT在实际应用中存在的问题</strong><br/></p><p>上面已经说到了两点，</p><p>1.每次请求都要携带token，服务器端都要解密和验证，对性能会有一定影响；</p><p>2.不适合存储敏感信息，容易泄露。</p><p>下面再总结几点：</p><p>3. token的存储一般有两种方式，一种是存在localStorage中，二是存在cookie中，这两种存储方式都有问题，存在localStorage中有很大的安全隐患，容易造成XSS攻击，因为跨站脚本可以读取localStorage里面的信息，如果存在cookie中，又容易造成CSRF攻击，这个是由于Cookie存储的安全性造成的（可以使用XSRF Token来解决这个问题）。</p><p>4.&nbsp;失效和刷新问题，token肯定要有失效时间，而且如果用户一直处于活跃状态，则要考虑能自动刷新token。</p><p>5.&nbsp;重放攻击，由于每次都传输token，如果这个token被窃取，那么可以在任何一个地方使用。特别的，如果这个token过期时间很长的话，那么它就相当于一个在很长时间内有效的钥匙。（可以考虑每次请求都重新生成一个token并存储一段时间防重放，但是这样又会遇到存储问题和并发刷新的问题，参见：<a href="https://zhuanlan.zhihu.com/p/22693223">https://zhuanlan.zhihu.com/p/22693223</a>）</p><p><br/></p><p><strong>2、OAUTH 2.0认证</strong></p><p><br/></p><p>。。。。。。。。。。。。</p><p><br/></p><p><br/></p><p><br/></p><p><strong>三、关于HTTPS的安全性问题</strong></p><p>首先来说，从目前全世界的报道来看，HTTPS数据加密应该是足够安全的，黑客很难破解。</p><p>但是，对HTTPS的应用，仍然可以变相的攻击：重放攻击。</p><p><br/></p><p>首先，模拟一个重放攻击的例子，如下：</p><p>常规登录流程：</p><p>1、前端web页面用户输入账号、密码，点击登录。</p><p>2、请求提交之前，web端首先通过客户端脚本如javascript对密码原文进行md5加密。</p><p>3、提交账号、md5之后的密码</p><p>4、请求提交至后端，验证账号与密码是否与数据库中的一致，一致则认为登录成功，反之失败。</p><p><br/></p><p>但是，如果监听者截取到了登录信息：</p><p>http://****/login.do?method=login&amp;password=md5&amp;userid=登录账号</p><p>把它重放一下，即可冒充你的身份登录系统。</p><p><br/></p><p>解决思路如下：</p><p style="white-space: normal;">1、把这个url请求做成一次性使用的，第二次（重放）请求就无效了。</p><p style="white-space: normal;">2、每次请求传输一个token值，第二次如果还是一样的token，就无效。这个token的生成算法或者密码数据是保密的，监听者无法得知算法或者密码，从而无法仿制token。</p><p><br/></p><p>方案一</p><p>1、如果是客户端APP，可以采用某种算法和密匙，将密码数据、时间截、随机数等加在一起生成token，然后再发送给服务器端验证，服务器验证通过后会记录下这个token，保存一段时间（比如24小时）。如果网络监听者再次发送一样的请求和token，则服务器端直接拒绝。由于网络监听者是不知道token生成算法或密匙的，如果他随意修改了token，服务器端根据密码数据、时间截、随机数等计算出来的token，就和接收到的token不一致，就拒绝这次访问。</p><p><br/></p><p>举个实际例子：</p><p>&nbsp; &nbsp; 假设第一次请求数据：</p><p>DATA: {password:&quot;ds8fds7&quot;, score: 10}</p><p>RS-TOKEN: AAAAAAAAAA (timestamp + nonce)</p><p>&nbsp; &nbsp; 如果黑客原封不动将这个请求再发一遍，显然这个token是会被拒绝的。所以要重新生成token，但是黑客不知道</p><p><br/></p><p>方案二</p><p>2、也可以在调用这个API之前，先向服务器获取一个随机码（称之为盐值），在客户端和服务器端各保存一份，并且设置一个有效时间，客户端提交请求时，将md5之后的密码数据与该随机码拼接后，再次执行md5，然后提交（提交的token=md5(md5(密码数据)+随机码)），后端也会计算token，然后对比，对比成功则删除从服务器端这个随机码，监听者无法再次使用它进行登录。网络监听者即使再次提交这个请求，但是后端已经删除了随机码，所以无法通过。（这个方案的劣势在于，每次请求之前，都要先获取一个随机码，第二次请求时要携带上这个随机码）</p><p><br/></p><p>3、针对方案一，如果不是客户端APP，而是WEB浏览器，算法和密匙是写在JavaScript里面的，怎么保证算法和密匙不被泄露？js是可以被拿到的，js函数可以被黑客执行，他可以调用js函数向服务器端发起请求。为避免这种情况，应该让网络监听者无法拿到可用的js，即使拿到了，也要限制js的执行，具体方案还有待研究，我考虑到两点，1是JavaScript混淆压缩，让js很难被反编译识别（目前来说是可以做到的），2是只允许js在指定环境下才能执行，例如有指定cookie或浏览器内存数据时才能执行，而cookie数据或内存数据需要从后端获取，js动态生成，且当该js生成的时候就携带一个标识，当js初始化时，就执行一次后端验证，验证通过该js可以执行，否则这个js不能执行。</p><p><br/></p><p><br/></p>