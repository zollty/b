---
layout: ue
title: JWT技术——基于token的鉴权机制
category: 系统架构和设计
tags: 安全
keywords: "API安全认证,鉴权"
---

<p><br/></p><p><em style="white-space: normal;"><span style="color: rgb(23, 54, 93);">本文是《<a href="http://blog.zollty.com/b/archive/research-of-restful-api-security-authentication.html" target="_blank">REST API安全认证研究</a>》的一部分。</span></em></p><p><br/></p><p><strong>JWT技术（基于token的鉴权机制）</strong><br/></p><p>流程上是这样的：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>用户使用用户名密码来请求服务器<br/></p></li><li><p>服务器进行验证用户的信息</p></li><li><p>服务器通过验证后生成一个token发送给用户</p></li><li><p>客户端存储token，并在每次请求时附送上这个token值</p></li><li><p>服务端验证token值，并返回数据</p></li></ol><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *</p><p><br/></p><p>&nbsp; &nbsp; JWT和Session技术的根本区别在于，Session是把访问者信息存储在服务器端的，而JWT是把信息存储在客户端。</p><p>&nbsp; &nbsp; Session方式存储用户信息的最大弊病在于要占用大量服务器内存，要保存许多的状态。一般而言，大型应用还需要借助缓存机制来实现Session的存储。</p><p>&nbsp; &nbsp; 而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员等。</p><p>&nbsp; &nbsp; JWT方式，每次请求都要带上token，服务器每次都要解密出token的信息，这会让服务器有一些计算压力。而且，如果客户端的信息比较多，每次HTTP请求携带的数据就比较多。还有一点，JWT在客户端的存储，不能包含敏感信息，否则很容易被泄露，而且不建议在客户端存储会变动的信息，否则可能出现一致性问题。</p><p>&nbsp;</p><p><strong>JWT长什么样？</strong></p><p>&nbsp; &nbsp; JWT是由三段信息（header.payload.signature）构成的，将这三段信息文本用英文句号链接一起就构成了JWT字符串。例如：<br/></p><p><span style="font-size: 14px; color: rgb(0, 176, 80);">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span style="font-size: 14px;">.<span style="font-size: 14px; color: rgb(0, 112, 192);">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span>.<span style="font-size: 14px; color: rgb(192, 0, 0);">TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br/></p><p>&nbsp; &nbsp; 可以在&nbsp;<a href="https://jwt.io/">https://jwt.io/</a>&nbsp;这个网站，把token解析出来。</p><p><br/></p><p><strong>JWT的构成</strong></p><p>&nbsp; &nbsp; 第一部分我们称它为头部（header)，</p><p>&nbsp; &nbsp; 第二部分我们称其为承载（payload, 类似于飞机上承载的物品)，</p><p>&nbsp; &nbsp; 第三部分是签证（signature)。</p><p><br/></p><p><strong>header</strong></p><p>完整的头部就像下面这样的JSON：</p><p>{</p><p>&nbsp; &#39;typ&#39;: &#39;JWT&#39;,</p><p>&nbsp; &#39;alg&#39;: &#39;HS256&#39;</p><p>}</p><p>即声明 类型 和 加密的算法。然后将头部进行base64加密，就构成了header部分。</p><p><br/></p><p><strong>playload</strong></p><p>承载就是存放有效信息的地方。这个名字像是指飞机上承载的货品，这些有效信息包含三个部分声明（Claims）</p><p>&nbsp; &nbsp; 标准中注册的声明</p><p>&nbsp; &nbsp; 公共的声明</p><p>&nbsp; &nbsp; 私有的声明</p><p><br/></p><p>标准中注册的声明 (建议但不强制使用) ：</p><p>iss: jwt签发者</p><p>sub: jwt所面向的用户</p><p>aud: 接收jwt的一方</p><p>exp: jwt的过期时间，这个过期时间必须要大于签发时间</p><p>nbf: 定义在什么时间之前，该jwt都是不可用的.</p><p>iat: jwt的签发时间</p><p>jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</p><p><br/></p><p><strong>signature</strong></p><p>signature是一个签证信息，它会用到前面的header、payload信息，以及一个密匙（secret）。</p><p>即，这个部分需要 base64加密后的header 和 base64加密后的payload，使用 英文句号 连接组成的字符串，然后通过header中声明的加密方式，进行加盐secret组合加密，然后就构成了jwt的第三部分signature。</p><p><br/></p><p><strong>JWT在实际应用中存在的问题</strong><br/></p><p>上面已经说到了两点，</p><p>1.每次请求都要携带token，服务器端都要解密和验证，对性能会有一定影响；</p><p>2.不适合存储敏感信息，容易泄露。</p><p>下面再总结几点：</p><p>3. token的存储一般有两种方式，一种是存在localStorage中，二是存在cookie中，这两种存储方式都有问题，存在localStorage中有很大的安全隐患，容易造成XSS攻击，因为跨站脚本可以读取localStorage里面的信息，如果存在cookie中，又容易造成CSRF攻击，这个是由于Cookie存储的安全性造成的（可以使用XSRF Token来解决这个问题）。</p><p>4.&nbsp;失效和刷新问题，token肯定要有失效时间，而且如果用户一直处于活跃状态，则要考虑能自动刷新token。</p><p>5.&nbsp;重放攻击，由于每次都传输token，如果这个token被窃取，那么可以在任何一个地方使用。特别的，如果这个token过期时间很长的话，那么它就相当于一个在很长时间内有效的钥匙。（可以考虑每次请求都重新生成一个token并存储一段时间防重放，但是这样又会遇到存储问题和并发刷新的问题，参见：<a href="https://zhuanlan.zhihu.com/p/22693223">https://zhuanlan.zhihu.com/p/22693223</a>）</p><p><br/></p><p>参考资料：</p><p><a href="https://github.com/pac4j/spring-webmvc-pac4j">https://github.com/pac4j/spring-webmvc-pac4j</a></p><p><a href="http://www.pac4j.org/docs/authenticators/jwt.html">http://www.pac4j.org/docs/authenticators/jwt.html</a></p>