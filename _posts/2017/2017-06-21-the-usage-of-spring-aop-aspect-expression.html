---
layout: ue
title: Spring AOP AspectJ 切面表达式高级用法
category: Spring专题
tags: Spring,AspectJ
keywords: "Spring,AspectJ,切面表达式"
---

<p><br/></p><p><strong>一、Spring AOP 配置</strong></p><p><br/></p><p>首先，明白一点，Spring的AOP代理，分为JDK动态代理和Cglib动态代理，这两种代理的实现方式不一样，他们针对同一Aspect的配置效果也可能不一样。</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>JDK的动态代理，只能代理接口，无法代理非接口的方法。</p></li><li><p>Cglib动态代理，采用的是继承代理对象的方法，所以可以代理非private的所有方法。</p></li></ol><p><br/></p><p><strong>Spring和AspectJ的关系：</strong></p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>AspectJ是Eclipse基金会的一个动态代理框架（官方网站为：<a href="http://www.eclipse.org/aspectj/doc/released/progguide/quick.html" style="background-color: rgb(245, 245, 213); white-space: normal;">http://www.eclipse.org/aspectj/</a>），它发明了一种表达式，按照这种表达式可以很方便的配置AOP的切入点。</p></li><li><p>Spring选择模仿和遵循AspectJ定义的表达式规范，并实现了对Aspect表达式的解析，但是它只实现了AspectJ官方表达式的一部分功能，同时又扩展了一些Spring特有的功能。</p></li></ol><p><br/></p><p>SpringMVC要开启AOP，需要配置一个标签：</p><p>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt;</p><p>其中proxy-target-class=true表示可以启用Cglib代理（至于什么时候使用，由Spring自己决定：判断是否基于接口代理，如果是就采用JDK动态代理，否则采用Cglib代理），如果配置proxy-target-class=false就意味着禁用Cglib代理，如果Spring发现无法代理时，就会报错。因为Cglib动态代理的效率比JDK动态代理的效率要低很多，所以如果你只代理接口，你可以设置proxy-target-class=false。</p><pre class="brush:java;toolbar:false">public&nbsp;AopProxy&nbsp;createAopProxy(AdvisedSupport&nbsp;config)&nbsp;{
&nbsp;&nbsp;&nbsp;if&nbsp;(config.isOptimize()&nbsp;||&nbsp;config.isProxyTargetClass())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;&nbsp;targetClass&nbsp;=&nbsp;config.getTargetClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(targetClass&nbsp;==&nbsp;null)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;AopConfigException(&quot;TargetSource&nbsp;cannot&nbsp;determine&nbsp;target&nbsp;class:&nbsp;&quot;&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Either&nbsp;an&nbsp;interface&nbsp;or&nbsp;a&nbsp;target&nbsp;is&nbsp;required&nbsp;for&nbsp;proxy&nbsp;creation.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(targetClass.isInterface())&nbsp;{&nbsp;//&nbsp;基于接口
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;JdkDynamicAopProxy(config);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ObjenesisCglibAopProxy(config);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;//&nbsp;如果配置proxy-target-class=false，直接JDK
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;JdkDynamicAopProxy(config);
&nbsp;&nbsp;&nbsp;}
}</pre><p><br/></p><p>SpringBoot，默认会识别工程中是否有AOP配置，如果有，则自动启用aop，无需配置，但是默认配置是基于JDK的，如果需要用到Cglib，则如下配置：</p><p>@EnableAspectJAutoProxy(proxyTargetClass=true)</p><p><br/></p><p><br/></p><p><strong>二、个人常用的AspectJ表达式介绍</strong></p><p><br/></p><p>1、execution(* com.zollty.**.dao.*.*(..))</p><p>其含义为：所有 com.zollty.**.dao包 下面的类（只包含一级目录，不包含下面的子目录），匹配这些类的所有 非private的方法。</p><p>这个表达式简单，但是效率低。官方不建议这么做，后面会讲，官方的建议做法。<br/></p><p><br/></p><p>2、within(com.zollty.**.dao.*) &amp;&amp; execution(public * *(..))</p><p>加上了within筛选，效率要高一些。效果同(1)一样，只是后面加上了&amp;&amp;条件限制，只匹配public的方法。</p><p><br/></p><p>3、within(com.zollty..BaseService+) &amp;&amp; @annotation(anno)</p><p>基于 包路径 和 BaseService基类的匹配，并且 带有&nbsp;anno 注解，anno注解在@Pointcut的方法参数里面指定，例如：</p><p>@Pointcut(@annotation(anno))</p><p>public void test(SelectDB anno) {</p><p>}</p><p><br/></p><p>4、within(com.zollty..BaseMapper+)&nbsp; &amp;&amp; !execution(* toString())&nbsp; &amp;&amp; !execution(* hashCode()) &amp;&amp; !execution(* getClass())</p><p>和(3)类似，同时排除掉 toString等方法。</p><p><br/></p><p><strong>3、官方建议的切面表达式性能优化方法</strong></p><p>However, AspectJ can only work with what it is told, and for optimal performance of matching the user should think about what they are trying to achieve and narrow the search space for matches as much as they can in the definition. Basically there are three kinds of pointcut designator: kinded, scoping and context:</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>Kinded designators are those which select a particular kind of join point. For example: <strong>execution</strong>, get, set, call, handler</p></li><li><p>Scoping designators are those which select a group of join points of interest (of probably many kinds). For example: <strong>within</strong>, withincode</p></li><li><p>Contextual designators are those that match (and optionally bind) based on context. For example: this, target, @annotation</p></li></ol><p><strong>A well written pointcut should try and include at least the first two types (kinded and scoping)</strong>, whilst the contextual designators may be included if wishing to match based on join point context, or bind that context for use in the advice. Supplying either just a kinded designator or just a contextual designator will work but could affect weaving performance (time and memory used) due to all the extra processing and analysis. Scoping designators are very fast to match, they can very quickly dismiss groups of join points that should not be further processed - that is why a good pointcut should always include one if possible.</p><p>翻译过来，即：至少使用两者类型的匹配模式，建议使用 within 和execution的组合，或者 within 和 @annotation的组合。</p><p><br/></p><p><strong>四、</strong><strong>切面表达式 参考文档：</strong></p><p><br/></p><p>Spring：</p><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts</a></p><p><br/></p><p>Aspectj官方：</p><p><a href="http://www.eclipse.org/aspectj/doc/released/progguide/quick.html">http://www.eclipse.org/aspectj/doc/released/progguide/quick.html</a></p><p><a href="http://www.eclipse.org/aspectj/doc/released/progguide/language-joinPoints.html">http://www.eclipse.org/aspectj/doc/released/progguide/language-joinPoints.html</a></p><p><a href="http://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">http://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html</a></p><p><br/></p><p>参考文章：</p><p><a href="https://wenku.baidu.com/view/7e91a92d4b73f242336c5ff4.html">https://wenku.baidu.com/view/7e91a92d4b73f242336c5ff4.html</a></p><p><a href="http://www.360doc.com/content/13/1212/09/14416931_336521220.shtml">http://www.360doc.com/content/13/1212/09/14416931_336521220.shtml</a></p><p><a href="https://blog.csdn.net/qq525099302/article/details/53996344">https://blog.csdn.net/qq525099302/article/details/53996344</a></p><p><br/></p>