---
layout: ue
title: Session和Cookie原理
category: 系统架构和设计
tags: Session,Cookie
keywords: "Session,Cookie"
---

<p>&nbsp;<br/></p><p style="margin-left:0;text-indent:0">一、Session<span style="font-family:黑体">术语、通常意义上的概念</span></p><p>&nbsp;</p><p>Session<span style="font-family: 宋体">的英文含义为：会议，或者代表进行某活动、会议连续的一段时间（会期、学期）。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">在计算机里面，通常是指某个连接或者操作的连续时间。</span>Session<span style="font-family:宋体">的含义不仅仅局限于常见的</span>HttpSession<span style="font-family:宋体">、浏览器会话，</span>Session<span style="font-family:宋体">是一个广义的概念，</span>HttpSession<span style="font-family:宋体">只是</span>session<span style="font-family:宋体">的一种代表，比如对象的生命周期其实也可以看做是一个</span>session<span style="font-family:宋体">，一个线程的完整运行也可以说是一个</span>session<span style="font-family:宋体">周期。</span></p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">二、HttpSession<span style="font-family:黑体">原理和</span><span style="font-family:黑体">基本</span><span style="font-family:黑体">作用</span></p><p>&nbsp;</p><p><span style="font-family:宋体">首先，</span><strong>HTTP</strong><strong><span style="font-family:宋体">协议本身是无状态的</span></strong><span style="font-family:宋体">，每一次请求之间都是独立的，例如，客户端向服务器请求下载某些文件，下载完就结束这次服务了，服务器不一定非要纪录下客户的行为，下次客户再来下载，还是和上次一样操作就行了。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">注意到一点，如果这个客户是个老顾客，他要连续的操作一段时间，而如果每次操作都要识别客户的身份，那未免也太麻烦了一点，所以</span>Java<span style="font-family:宋体">在</span>Servlet<span style="font-family:宋体">中引入了</span>HttpSession<span style="font-family:宋体">的概念，客户第一次来就记录下客户的身份，后面如果连续操作就直接使用第一次记录下来的信息，如果客户长时间不操作，这个记录下的身份信息就不再保存了，失效之后如果客户再来操作，又需要识别和记录客户身份。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">再回过头来，由于</span>HTTP<span style="font-family:宋体">协议本身是无状态的，但是很多情况下，我们又需要记录下一段连续时间内客户端的信息。其实，有三种方法，举例说明：张三曾经常去的一家咖啡店，有喝</span>5<span style="font-family:宋体">杯咖啡免费赠</span>1<span style="font-family:宋体">杯咖啡的优惠，然而一次性消费</span>5<span style="font-family:宋体">杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案：</span></p><p>1<span style="font-family:宋体">、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是<strong>协议本身支持状态</strong>。</span></p><p>2<span style="font-family:宋体">、发给顾客一张卡片，上面记录着消费的数量，活动有一个截止日期，所以这个卡有一个有效期，过期就用不了了。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前的消费相联系起来。这种做法就是<strong>在客户端保持状态</strong>。</span></p><p>3<span style="font-family:宋体">、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，或者客户自报姓名，每次消费时，如果顾客出示该卡片或者说出自己名字，则店员在店里的纪录本上找到这个卡号对应的纪录添加消费信息。这种做法就是<strong>在服务器端保持状态</strong>。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">这三种方案，都有各自的优劣，第一种，貌似很好，客户和商店都不需要记录客户的信息，但是需要店员主动去识别客户，好比在使用某协议时，就能够主动携带客户信息。但如果服务器不需要客户信息，那么协议里面就没必要携带客户信息了，所以</span>HTTP<span style="font-family:宋体">协议没有要求，在协议里面必须包含客户信息，包括</span>IP<span style="font-family:宋体">、客户端类型等，</span>HTTP<span style="font-family:宋体">协议里面都不需要，但是</span>HTTP<span style="font-family:宋体">协议支持以</span>header<span style="font-family:宋体">、</span>param<span style="font-family:宋体">等形式传输这些客户端信息，使用完全自由。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">第二种方案，优点在于，客户信息由客户自己提供、自己记录下来，服务端不需要知道、更不需要保存客户的信息，减少了服务端的工作。缺点是，客户信息由客户自己提供，服务端没有记录下客户的过往信息，那么客户可以对自己的信息作假，明明客户只消费了</span>2<span style="font-family:宋体">杯咖啡，客户说他消费了</span>20<span style="font-family:宋体">杯咖啡，那样肯定不行。还不如说银行卡密码等信息，肯定是要在服务端保存才行。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">所以说，大多数时候，方案三才是我们需要的，服务端主动记录下客户信息，好处多多。</span></p><p>&nbsp;</p><p>HttpSession<span style="font-family: 宋体">的好处在于，它是一个服务端的标准的解决方案，它提供了一套标准的接口，自带了保存客户信息的容器（其实就是利用</span>Java<span style="font-family:宋体">的</span>Map<span style="font-family:宋体">把数据保存在内存里面）。</span></p><p>&nbsp;</p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">三、Cookie<span style="font-family:黑体">原理和</span><span style="font-family:黑体">基本</span><span style="font-family:黑体">作用</span></p><p>&nbsp;</p><p><span style="font-family:宋体">接着上面讲，</span>HttpSession<span style="font-family:宋体">是服务端的标准解决方案，而</span>Cookie<span style="font-family:宋体">就是客户端的标准解决方案（由</span>W3C<span style="font-family:宋体">提出），就是上面例子中的第二种情况，客户自己保存自己的信息在一个叫做</span>Cookie<span style="font-family:宋体">的容器里面。几乎所有的浏览器都支持</span>Cookie<span style="font-family:宋体">，它不但可以保存在内存中，甚至可以持久化保存在磁盘上。通常</span>Cookie<span style="font-family:宋体">要设置一个过期时间，过期之后保存的信息就被清除了，客户也可以自己随时手工清除。</span></p><p>&nbsp;</p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">四、Cookie<span style="font-family:黑体">的</span><span style="font-family:黑体">具体实现和</span><span style="font-family:黑体">常用功能</span></p><p>&nbsp;</p><p><span style="font-family:宋体">上面只说了</span>Cookie<span style="font-family:宋体">的基本原理和功能，现在来看</span>Cookie<span style="font-family:宋体">的具体功能。首先，</span>Cookie<span style="font-family:宋体">可以由浏览器自动生成和管理，当然也可以自己写客户端脚本</span>JavaScript<span style="font-family:宋体">、</span>VBScript<span style="font-family:宋体">等自己管理。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">什么时候生成</span>Cookie<span style="font-family:宋体">呢，正统的</span>Cookie<span style="font-family:宋体">分发是通过扩展</span>HTTP<span style="font-family:宋体">协议来实现的，服务器通过<strong>在</strong></span><strong>HTTP</strong><strong><span style="font-family:宋体">的响应头</span>[header]</strong><strong><span style="font-family:宋体">中加上一行特殊的指示（</span>Set-Cookie</strong><strong><span style="font-family:宋体">）以提示浏览器按照指示生成相应的</span>cookie</strong><span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><i>Java</i><i><span style="font-family:宋体">中把</span>Cookie</i><i><span style="font-family:宋体">封装成了</span>javax.servlet.http.Cookie</i><i><span style="font-family:宋体">类。服务器通过操作</span>Cookie</i><i><span style="font-family:宋体">类对象对客户端</span>Cookie</i><i><span style="font-family:宋体">进行操作。通过</span>Cookie[] request.getCookie()</i><i><span style="font-family:宋体">获取客户端提交的所有</span>Cookie</i><i><span style="font-family:宋体">，通过</span>response.addCookie(Cookie cookie)</i><i><span style="font-family: 宋体">向客户端设置</span>Cookie</i><i><span style="font-family:宋体">。</span></i></p><p>&nbsp;</p><p>Cookie<span style="font-family:宋体">怎么发送给服务器端呢？是由浏览器按照一定的原则在后台自动发送给服务器的（以请求头</span>[header]<span style="font-family:宋体">的形式）。最重要的原则是：</span><strong>Cookie</strong><strong><span style="font-family:宋体">具有不可跨域名性</span></strong><span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">根据</span>Cookie<span style="font-family:宋体">规范，浏览器访问</span>Google<span style="font-family:宋体">只会携带</span>Google<span style="font-family:宋体">的</span>Cookie<span style="font-family:宋体">，而不会携带</span>Baidu<span style="font-family:宋体">的</span>Cookie<span style="font-family:宋体">。</span>Google<span style="font-family:宋体">也只能操作</span>Google<span style="font-family:宋体">的</span>Cookie<span style="font-family:宋体">，而不能操作</span>Baidu<span style="font-family:宋体">的</span>Cookie<span style="font-family:宋体">。</span></p><p>Cookie<span style="font-family:宋体">在客户端是由浏览器来管理的。浏览器能够保证</span>Google<span style="font-family:宋体">只会操作</span>Google<span style="font-family:宋体">的</span>Cookie<span style="font-family:宋体">而不会操作</span>Baidu<span style="font-family:宋体">的</span>Cookie<span style="font-family:宋体">，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站</span>Cookie<span style="font-family:宋体">的依据是域名。</span>Google<span style="font-family:宋体">与</span>Baidu<span style="font-family:宋体">的域名不一样，因此</span>Google<span style="font-family:宋体">不能操作</span>Baidu<span style="font-family:宋体">的</span>Cookie<span style="font-family:宋体">。</span></p><p>&nbsp;</p><p>cookie<span style="font-family:宋体">的内容主要包括：<strong>名字，值，过期时间（</strong></span><strong>exxpires</strong><strong><span style="font-family:宋体">），路径（</span>path</strong><strong><span style="font-family:宋体">）和域（</span>domain</strong><strong><span style="font-family:宋体">）</span></strong><span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><strong><span style="font-family:宋体">其中域可以指定某一个域比如</span>.google.com</strong><span style="font-family:宋体">，相当于总店招牌，也可以指定一个域下的具体某个子域名，比如</span>www.google.com<span style="font-family:宋体">或者</span>images.google.com<span style="font-family:宋体">。虽然网站</span>images.google.com<span style="font-family:宋体">与网站</span>www.google.com<span style="font-family:宋体">同属于</span>Google<span style="font-family:宋体">，但是域名不一样，二者同样不能互相操作彼此的</span>Cookie<span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><strong><span style="font-family:宋体">路径就是跟在域名后面的</span>URL</strong><strong><span style="font-family:宋体">路径</span></strong><span style="font-family:宋体">，比如</span>/<span style="font-family:宋体">或者</span>/foo<span style="font-family:宋体">等等，路径与域合在一起就构成了</span>cookie<span style="font-family:宋体">的作用范围。</span></p><p>&nbsp;</p><p><strong><span style="font-family:宋体">如果不设置过期时间，则表示这个</span>cookie</strong><strong><span style="font-family:宋体">的生命期为浏览器会话期间，只要关闭浏览器窗口，</span>cookie</strong><strong><span style="font-family:宋体">就消失了</span></strong><span style="font-family:宋体">。这种生命期为浏览器会话期的</span>cookie<span style="font-family:宋体">被称为会话</span>cookie<span style="font-family:宋体">。会话</span>cookie<span style="font-family:宋体">一般不存储在硬盘上而是<strong>保存在内存里</strong>，当然这种行为并不是规范规定的。<strong>如果设置了过期时间，浏览器就会把</strong></span><strong>cookie</strong><strong><span style="font-family:宋体">保存到硬盘上</span></strong><span style="font-family: 宋体">，关闭后再次打开浏览器，这些</span>cookie<span style="font-family:宋体">仍然有效直到超过设定的过期时间。</span></p><p>&nbsp;</p><p><strong><span style="font-family:宋体">存储在硬盘上的</span>cookie</strong><strong><span style="font-family:宋体">可以在不同的浏览器进程间共享，比如两个</span>IE</strong><strong><span style="font-family:宋体">窗口。而对于保存在内存里的</span>cookie</strong><strong><span style="font-family:宋体">，不同的浏览器有不同的处理方式</span></strong><span style="font-family:宋体">。对于</span>IE<span style="font-family:宋体">，在一个打开的窗口上按</span>Ctrl-N<span style="font-family:宋体">（或者从文件菜单）打开的窗口可以与原窗口共享，而使用其他方式新开的</span>IE<span style="font-family:宋体">进程则不能共享已经打开的窗口的内存</span>cookie<span style="font-family:宋体">；对于</span>Mozilla Firefox0.8<span style="font-family:宋体">，所有的进程和标签页都可以共享同样的</span>cookie<span style="font-family:宋体">。<strong>一般来说是用</strong></span><strong>javascript</strong><strong><span style="font-family:宋体">的</span>window.open</strong><strong><span style="font-family:宋体">打开的窗口会与原窗口共享内存</span>cookie</strong><span style="font-family:宋体">。浏览器对于会话</span>cookie<span style="font-family:宋体">的这种只认</span>cookie<span style="font-family:宋体">不认人的处理方式经常给采用</span>session<span style="font-family:宋体">机制的</span>web<span style="font-family:宋体">应用程序开发者造成很大的困扰。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">下面就是一个</span>goolge<span style="font-family:宋体">设置</span>cookie<span style="font-family:宋体">的响应头的例子</span></p><p>HTTP/1.1 302 Found</p><p>Location: http://www.google.com/intl/zh-CN/</p><p>Set-Cookie: <strong>PREF</strong>=<i>ID=0565f77e132de138:NW=1:TM=1098082649:LM=1098082649:S=KaeaCFPo49RiA_d8</i>; <strong>expires</strong>=<i>Sun, 17-Jan-2038 19:14:07 GMT</i>; <strong>path</strong>=/; <strong>domain</strong>=.google.com</p><p>Content-Type: text/html</p><p><span style="font-family:宋体">浏览器在再次访问</span>goolge<span style="font-family:宋体">的资源时自动向外发送</span>Cookie<span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">另外，注意两点：</span></p><p>cookie<span style="font-family:宋体">不是很安全，别人可以分析存放在本地的</span>COOKIE<span style="font-family:宋体">并进行</span>COOKIE<span style="font-family:宋体">欺骗，可以考虑加密存储。</span></p><p><span style="font-family:宋体">单个</span>cookie<span style="font-family:宋体">保存的数据不能超过</span>4K<span style="font-family:宋体">，很多浏览器都限制一个站点最多保存</span>20<span style="font-family:宋体">个</span>cookie<span style="font-family:宋体">。</span></p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">五、Http Session<span style="font-family:黑体">的具体实现和常用功能</span></p><p>&nbsp;</p><p>Http Session<span style="font-family: 宋体">机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">当程序需要为某个客户端的请求创建一个</span>session<span style="font-family:宋体">的时候，<strong>服务器首先检查这个客户端的请求里是否已包含了一个</strong></span><strong>session</strong><strong><span style="font-family:宋体">标识</span> - </strong><strong><span style="font-family:宋体">称为</span>session id</strong><span style="font-family:宋体">，</span><i>Servlet</i><i><span style="font-family:宋体">源码里面是调用这个方法：</span>parseSessionCookiesId(request)</i><span style="font-family:宋体">，如果已包含一个</span>session id<span style="font-family:宋体">则说明以前已经为此客户端创建过</span>session<span style="font-family:宋体">，服务器就按照</span>session id<span style="font-family:宋体">把这个</span>session<span style="font-family:宋体">检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含</span>session id<span style="font-family:宋体">，则为此客户端创建一个</span>session<span style="font-family:宋体">并且生成一个与此</span>session<span style="font-family:宋体">相关联的</span>session id<span style="font-family:宋体">，</span><strong>session id</strong><strong><span style="font-family:宋体">的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串</span></strong><span style="font-family:宋体">，这个</span>session id<span style="font-family:宋体">将被在本次响应中<strong>返回给客户端保存</strong>。</span> <strong><span style="font-family:宋体">保存这个</span>session id</strong><strong><span style="font-family:宋体">的方式可以采用</span>cookie</strong><strong><span style="font-family:宋体">，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器</span></strong><span style="font-family:宋体">。一般这个</span>cookie<span style="font-family:宋体">的名字都是类似于</span><strong>SEEESIONID</strong><span style="font-family:宋体">，但和后端服务器有关，比如</span>weblogic<span style="font-family:宋体">对于</span>web<span style="font-family:宋体">应用程序生成的</span>cookie<span style="font-family:宋体">，它的名字就是</span><strong>JSESSIONID</strong><span style="font-family:宋体">：（前面多一个</span>J<span style="font-family:宋体">）</span></p><p>JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764<span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">由于</span>cookie<span style="font-family:宋体">可以被人为的禁止，必须有其他机制<strong>以便在</strong></span><strong>cookie</strong><strong><span style="font-family:宋体">被禁止时仍然能够把</span>session id</strong><strong><span style="font-family:宋体">传递回服务器</span></strong><span style="font-family:宋体">。经常被使用的一种技术叫做</span><strong>URL</strong><strong><span style="font-family:宋体">重写</span></strong><span style="font-family: 宋体">，<strong>就是把</strong></span><strong>session id</strong><strong><span style="font-family:宋体">直接附加在</span>URL</strong><strong><span style="font-family:宋体">路径的后面</span></strong><span style="font-family:宋体">，<strong>附加方式也有两种</strong>，一种是作为</span>URL<span style="font-family:宋体">路径的附加信息，表现形式为</span></p><p><span style="color:#0070C0">http://...../xxx</span><strong>;jsessionid=</strong>ByOK ... 99zWpBng!-145788764</p><p><span style="font-family:宋体">另一种是作为查询字符串附加在</span>URL<span style="font-family:宋体">后面，表现形式为</span></p><p><span style="color:#0070C0">http://...../xxx</span><strong>?jsessionid=</strong>ByOK ... 99zWpBng!-145788764</p><p><span style="font-family:宋体">这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把</span>session id<span style="font-family:宋体">的信息和正常程序参数区分开来。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个</span>session id<span style="font-family:宋体">。</span></p><p><span style="font-family:宋体">另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把</span>session id<span style="font-family:宋体">传递回服务器。这种技术现在已较少应用，笔者接触过的很古老的</span>iPlanet6(SunONE<span style="font-family:宋体">应用服务器的前身</span>)<span style="font-family:宋体">就使用了这种技术。</span> <span style="font-family:宋体">实际上这种技术可以简单的用对</span>action<span style="font-family:宋体">应用</span>URL<span style="font-family:宋体">重写来代替。</span></p><p>&nbsp;</p><p>Java Servlet<span style="font-family: 宋体">提供的</span>URL<span style="font-family:宋体">重新方案：</span></p><p>HttpServletResponse<span style="font-family:宋体">接口定义了两个用于</span>URL<span style="font-family:宋体">重写的方法：</span></p><p>encodeURL<span style="font-family: 宋体">方法，用于超链接和</span>form<span style="font-family:宋体">表单的</span>action<span style="font-family:宋体">属性中设置的</span>URL<span style="font-family:宋体">进行重写</span></p><p>encodeRedirectURL<span style="font-family:宋体">方法，用于</span>HttpServletResponse.sendRedirect<span style="font-family: 宋体">方法的</span>URL<span style="font-family:宋体">进行重写</span></p><p>&nbsp;</p><p><span style="font-family:宋体">例如：</span></p><p>&lt;td&gt;</p><p>&nbsp;&nbsp;&nbsp; &lt;a href=&quot;&lt;%=response.encodeURL(&quot;index.jsp?c=1&amp;wd=Java&quot;) %&gt;&quot;&gt;Homepage&lt;/a&gt;</p><p>&lt;/td&gt;</p><p><span style="font-family:宋体">该方法会自动判断客户端是否支持</span>Cookie<span style="font-family:宋体">。如果客户端支持</span>Cookie<span style="font-family:宋体">，会将</span>URL<span style="font-family:宋体">原封不动地输出来。如果客户端不支持</span>Cookie<span style="font-family:宋体">，则会将用户</span>Session<span style="font-family:宋体">的</span>id<span style="font-family:宋体">重写到</span>URL<span style="font-family:宋体">中。重写后的输出可能是这样的：</span></p><p>&lt;td&gt;</p><p>&nbsp;&nbsp;&nbsp; &lt;a href=&quot;index.jsp;jsessionid=0CCD096E7F8D97B8AFDC3E1931E?c=1&amp;wd=Java&quot;&gt;</p><p>Homepage&lt;/a&gt;</p><p>&lt;/td&gt;</p><p><span style="font-family:宋体">即在文件名的后面，在</span>URL<span style="font-family:宋体">参数的前面添加了字符串“</span>;jsessionid=XXX<span style="font-family:宋体">”。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">查看</span>HttpServletResponse.encodeURL(url)<span style="font-family:宋体">方法的源码，可以看到：</span></p><p>String tok = &quot;;&quot; +</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SessionConfig.getSessionUriParamName(request.getContext()) +</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;=&quot; + session.getIdInternal();</p><p><span style="font-family:宋体">其中，</span>jsessionid<span style="font-family:宋体">这个名字也是可以配置的。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">在谈论</span>session<span style="font-family:宋体">机制的时候，常常听到这样一种误解“只要关闭浏览器，</span>session<span style="font-family:宋体">就消失了”。其实可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对</span>session<span style="font-family:宋体">来说也是一样的，除非程序通知服务器删除一个</span>session<span style="font-family:宋体">，否则服务器会一直保留，程序一般都是在用户做</span>log off<span style="font-family:宋体">的时候发个指令去删除</span>session<span style="font-family:宋体">。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分</span>session<span style="font-family:宋体">机制都使用会话</span>cookie<span style="font-family:宋体">来保存</span>session id<span style="font-family:宋体">，而关闭浏览器后这个</span>session id<span style="font-family:宋体">就消失了，再次连接服务器时也就无法找到原来的</span>session<span style="font-family:宋体">。如果服务器设置的</span>cookie<span style="font-family:宋体">被保存到硬盘上，或者使用某种手段改写浏览器发出的</span>HTTP<span style="font-family:宋体">请求头，把原来的</span>session id<span style="font-family:宋体">发送给服务器，则再次打开浏览器仍然能够找到原来的</span>session<span style="font-family:宋体">。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">恰恰是由于关闭浏览器不会导致</span>session<span style="font-family:宋体">被删除，迫使服务器为</span>seesion<span style="font-family:宋体">设置了一个失效时间，当距离客户端上一次使用</span>session<span style="font-family:宋体">的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把</span>session<span style="font-family:宋体">删除以节省存储空间。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span style="font-family:宋体">总结</span></p><p>session<span style="font-family: 宋体">机制本身并不复杂，然而其实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当作普遍适用的经验，而是始终需要具体情况具体分析。</span></p><p>&nbsp;</p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">六、Http Session<span style="font-family:黑体">的持久化</span></p><p>&nbsp;</p><p><span style="font-family:宋体">持久化</span>Http Session<span style="font-family:宋体">的作用，例如，在一个</span>web<span style="font-family:宋体">应用程序重启时，服务器也会持久化该应用程序中所有</span>HttpSession<span style="font-family:宋体">对象，保证客户端的会话活动仍可以恢复、继续。</span></p><p>&nbsp;</p><p>Tomcat<span style="font-family:宋体">使用</span>Session Manager<span style="font-family:宋体">类来管理</span>Session<span style="font-family:宋体">的持久化，它提供了两个</span>SessionManager<span style="font-family:宋体">类</span></p><p>org.apache.catalina.session.StandardManager</p><p>org.apache.catalina.session.PersistentManager</p><p>&nbsp;</p><p>StandardManager<span style="font-family:宋体">是</span>tomcat<span style="font-family:宋体">默认使用的，在</span>web<span style="font-family:宋体">应用程序关闭时，对内存中的所有</span>HttpSession<span style="font-family:宋体">对象进行持久化，把他们保存到文件系统中。默认的存储文件为</span></p><p>&lt;tomcat <span style="font-family: 宋体">安装目录</span>&gt;/<strong>work</strong>/Catalina/&lt;<span style="font-family:宋体">主机名</span>&gt;/&lt;<span style="font-family:宋体">应用程序名</span>&gt;/<strong>sessions.ser</strong></p><p><span style="font-family:宋体">这个默认就是配置了的，如果要禁用，可以修改</span>context.xml<span style="font-family:宋体">（全局配置）或者</span>server.xml<span style="font-family:宋体">（单独配置）：</span></p><p>&lt;!-- <strong>Uncomment</strong> this to <strong>disable</strong> session persistence across Tomcat restarts --&gt;</p><p>&nbsp;&nbsp;&nbsp; &lt;!--</p><p>&nbsp;&nbsp;&nbsp; &lt;Manager pathname=&quot;&quot; /&gt;</p><p>&nbsp;&nbsp;&nbsp; --&gt;</p><p><span style="font-family:宋体">当然，如果你是直接</span>kill -9 tomcat<span style="font-family:宋体">进程，那</span>session<span style="font-family:宋体">是没法保存的。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">要实现更健壮、更符合生产环境的重启持久化，最好使用</span>PersistentManager<span style="font-family:宋体">，它比</span>StandardManager<span style="font-family:宋体">更为灵活，只要某个设备提供了实现</span>org.apache.catalina.Store<span style="font-family:宋体">接口的驱动类，</span>PersistentManager<span style="font-family:宋体">就可以将</span>HttpSession<span style="font-family:宋体">对象保存到该设备。</span>Tomcat<span style="font-family:宋体">自带提供了</span>FileStore<span style="font-family:宋体">和</span>JDBCStore<span style="font-family:宋体">两种实现，用户可以配置。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">注意，默认情况下，</span> session<span style="font-family:宋体">持久化，需要</span>session<span style="font-family:宋体">里面的类实现</span>java<span style="font-family:宋体">序列化接口</span>java.io.Serializable<span style="font-family:宋体">，将对象序列化后保存。</span></p><p>&nbsp;</p><p>&nbsp;</p><p style="margin-left:0;text-indent:0">七、<span style="font-family: 黑体">扩展知识：实现</span><span style="font-family:黑体">集群环境下</span><span style="font-family: 黑体">的</span><span style="font-family:黑体">高可用</span>Session</p><p>&nbsp;</p><p><span style="font-family:宋体">为了支持海量用户的访问，应用服务器集群这种水平扩展的方式是最常用的。在单机环境中，</span>Session<span style="font-family:宋体">的创建和存储都是由同一个应用服务器实例来完成，而存储也仅是内存中，最多会在正常的停止服务器的时候，把当前活动的</span>Session<span style="font-family:宋体">钝化到本地，再次启动时重新加载。</span></p><p>&nbsp;</p><p><span style="font-family:宋体">而多个实例之间，</span>Session<span style="font-family:宋体">数据是完全隔离的。而为了实现</span>Session<span style="font-family:宋体">的高可用，多实例间</span>session<span style="font-family:宋体">数据共享是必然的。具体来说，常用有以下几种方案：</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">会话保持（案例：</span>Nginx<span style="font-family:宋体">、</span>Haproxy<span style="font-family:宋体">）</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">会话复制（案例：</span>Tomcat<span style="font-family:宋体">，</span>WAS<span style="font-family:宋体">）</span></p><p class="MsoListParagraph" style="margin-left:28px"><span style="font-family:Wingdings">Ø<span style="font:9px &#39;Times New Roman&#39;">&nbsp; </span></span><span style="font-family:宋体">会话共享（案例：</span>Memcached<span style="font-family:宋体">、</span>Redis<span style="font-family:宋体">）</span></p><p>&nbsp;</p><p><span style="font-family:宋体">具体参见专题：《实现集群环境下的高可用</span>Session<span style="font-family:宋体">》。</span></p><p>&nbsp;</p>