---
layout: ue
title: Dockerfile最佳实践【原创、很多实践经验】
category: 运维与基础设施
tags: [Docker]
keywords: "Docker"
---

{% raw %}
<p>首先，参见官方文档：</p><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank">dockerfile_best-practices</a></p><p>有如下几点说明：<span style="color: rgb(192, 0, 0);">红色标注的是重点</span></p><ul style="list-style-type: none;" class=" list-paddingleft-2"><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#create-ephemeral-containers" class="nomunge" style="color: rgb(0, 144, 200); outline: none; display: inline-block; font-size: 12px;">Create ephemeral containers</a>（构建无状态的容器）</p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#understand-build-context" class="nomunge" style="color: rgb(0, 144, 200); outline: none; display: inline-block; font-size: 12px;">Understand build context</a>（理解上下文，不引入多余文件）</p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#pipe-dockerfile-through-stdin" class="nomunge" style="outline: none; display: inline-block; font-size: 12px; color: rgb(192, 0, 0); text-decoration: underline;"><span style="color: rgb(192, 0, 0);">Pipe Dockerfile through stdin</span></a><span style="color: rgb(192, 0, 0);">（无需上下文的情况，通过stdin构建）</span></p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#exclude-with-dockerignore" class="nomunge" style="outline: none; display: inline-block; font-size: 12px; color: rgb(192, 0, 0); text-decoration: underline;"><span style="color: rgb(192, 0, 0);">Exclude with .dockerignore</span></a><span style="color: rgb(192, 0, 0);">（排除context中文件，参见&nbsp;</span><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank" style="color: rgb(0, 112, 192); text-decoration: underline;"><span style="color: rgb(0, 112, 192);">.dockerignore文件</span></a><span style="color: rgb(192, 0, 0);">）</span></p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#use-multi-stage-builds" class="nomunge" style="outline: none; display: inline-block; font-size: 12px; color: rgb(192, 0, 0); text-decoration: underline;"><span style="color: rgb(192, 0, 0);">Use multi-stage builds</span></a><span style="color: rgb(192, 0, 0);">（多阶段构建，并合理利用缓存：排序原则-&gt;最基础的RUN放在前面）</span></p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#dont-install-unnecessary-packages" class="nomunge" style="outline: none; display: inline-block; font-size: 12px; color: rgb(192, 0, 0); text-decoration: underline;"><span style="color: rgb(192, 0, 0);">Don’t install unnecessary packages</span></a><span style="color: rgb(192, 0, 0);">（不安装不必要的包，中间过程文件，可以删除和clean：rm -rf src/* &amp;&amp; yum clean all）</span></p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#decouple-applications" class="nomunge" style="color: rgb(0, 144, 200); outline: none; display: inline-block; font-size: 12px;">Decouple applications</a>（为了更好管理容器，不推荐在一个容器中部署多个进程）</p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#minimize-the-number-of-layers" class="nomunge" style="outline: none; display: inline-block; font-size: 12px; color: rgb(192, 0, 0); text-decoration: underline;"><span style="color: rgb(192, 0, 0);">Minimize the number of layers</span></a><span style="color: rgb(192, 0, 0);">（减少层数，合并RUN、COPY、ADD、LABEL）</span></p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#sort-multi-line-arguments" class="nomunge" style="color: rgb(0, 144, 200); outline: none; display: inline-block; font-size: 12px;">Sort multi-line arguments</a>（为了直观，RUN参数较多时，建议分成多行并排序）</p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" class="nomunge" style="color: rgb(0, 144, 200); outline: none; display: inline-block; font-size: 12px;">Leverage build cache</a>（同上，多阶段构建合理利用缓存）</p></li><li><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#dockerfile-instructions" class="nomunge" style="color: rgb(0, 144, 200); outline: none; display: inline-block; font-size: 12px;">Dockerfile instructions</a>（Dockerfile指令优化）</p></li></ul><p><br/></p><p>怎么理解“合理利用缓存”？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;即：尽量把变化频率小的往前放，经常可能变化的命令往后放。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;因为假设把经常变化的指令放在前面，缓存没有命中，则后面都要重新打镜像。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;类似 COPY WORKDIR ENV LABEL等命令，可以往后放。</p><p><br/></p><p>什么是“多阶段构建”？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;多阶段构建的应用场景：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;需要在容器中build应用，生成目标文件，然后再把目标文件拷贝到容器中运行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;比如：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>编写编译容器Dockerfile，把源Java代码拷贝进容器，然后编译，生成在一个目录中。</p><p>docker build -t java:build .</p></li><li><p>运行java:build容器，然后把编译好的产物从容器拷贝出来到宿主机上</p><p>docker cp 容器:/home/java/code.class&nbsp; ./</p></li><li><p>编写生产环境Dockerfile</p></li><li><p>将code.class拷贝到生产环境Dockerfile中，最终生成目标镜像</p><p>docker build java:production .</p><p>rm&nbsp; code.class #删除宿主机的文件</p><p>docker rmi java:build&nbsp; #删除无用(中间状态的构建容器)</p><p>docker rm -f java:build容器&nbsp;</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;使用“多阶段构建”，将编译过程和打包过程，合并在一起，build过程中，会自动运行中间状态容器中的命令，拿到中间产物。Dockerfile如下：</p><pre class="brush:bash;toolbar:false">FROM java as build #1.构建阶段别名
COPY code.java /home/java
WORKDDIR  /home/java
RUN java -c code.java

FROM java as production #2.构建阶段别名
#重点！！！ 直接从第一阶段拷贝产物文件
COPY --form=build /home/java/code.class /home/java/code.class
WORKDIR  /home/java
CMD [&quot;java&quot;,&quot;code&quot;]</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;直接生成最后一个阶段构建的容器</p><pre class="brush:bash;toolbar:false">docker build -t java:production .</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;假设想单独生成某个阶段容器</p><pre class="brush:bash;toolbar:false">docker build -t java:build  --target=build(构建阶段名称)  .</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;注意，这个中间件状态容器，并没有CMD和ENTRYPOINT，没有真正的启动起来，但是build过程中RUN指令会执行。要注意一点的是，RUN指令不要长期运行，应该是运行一段时间就能结束的。</p><p><br/></p><h3>Dockerfile指令优化</h3><p><strong><br/></strong></p><p><strong>1、COPY指令和ADD指令的区别</strong></p><p>1）COPY 是传统的复制文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;格式：COPY &lt;源路径&gt;... &lt;目标路径&gt;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;此外，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p><p><br/></p><p>2）ADD 是更高级的复制文件指令，在 COPY 基础上增加了一些功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;比如 &lt;源路径&gt; 可以是一个 URL，或者压缩文件，ADD会自动拉取、解压文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。</p><p><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p><p><br/></p><p>2、CMD 与 ENTRYPOINT的区别</p><p>CMD</p><p>&nbsp;&nbsp;&nbsp;&nbsp;CMD 指令设置镜像中的默认启动命令和参数. 容器启动时，如果没有单独指定启动命令，则默认执行镜像中 CMD。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;设置启动命令时, 应该尽量使用 JSON 格式 CMD [&quot;command&quot;, &quot;arg1&quot;, &quot;arg2&quot;]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;例如 nginx 的启动方式: CMD [&quot;nginx&quot;, &quot;-D&quot;]</p><p><br/></p><p>ENTRYPOINT</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当启动主程序之前还需要执行大量的前置操作时, 可以将 ENTRYPOINT 的入口指令设置为一个脚本 start.sh。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当 dockerfile 中指定了 ENTRYPOINT 的时候, docker run 如果在镜像之后添加的指令, 那么这些指令将被当做 ENTRYPOINT 的参数执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果 dockerfile 中同时有 CMD 和 ENTRYPOINT 指令, 当 CMD 指令可执行时, 它将在 ENTRYPOINT 之前运行; 如果 CMD 不是可执行的命令, 则将作为 ENTRYPOINT 的命令参数追加。</p><p><br/></p><p>下面这种写法，执行时，相当于 top -b -c<br/></p><pre class="brush:bash;toolbar:false">FROM ubuntu
ENTRYPOINT [ &quot;top&quot;, &quot;-b&quot; ]
CMD [ &quot;-c&quot; ]</pre><p>CMD和ENTRIPOINT详解：<a href="https://www.jb51.net/article/136264.htm">https://www.jb51.net/article/136264.htm</a><br/></p><p><br/></p><p><strong>注意：</strong><br/></p><p>1、CMD命令会被docker run命令覆盖，但是ENTRYPOINT不会，但也可以使用--entrypoint参数指定新的脚本。</p><p>2、CMD [xxx] 命令不能用 &amp;&amp; 串联多个指令。</p><p>比如 CMD [&quot;ls&quot;, &quot;&amp;&amp;&quot;, &quot;tail&quot;, &quot;-f&quot;, &quot;app.log&quot;]，这样写是错的，只能像下面这样写：</p><p>CMD ls &amp;&amp; tail -f app.log</p><p>3、但是CMD后面跟的命令，有些限制，比如 nohup start.sh &amp; 加上 tail -f app.log</p><p>CMD nohup start.sh &amp; &amp;&amp; tail -f app.log</p><p>这样写是错的。建议改成sh脚本。</p><p><br/></p><p>ENTRIPOINT编写指南：</p><p>1) set -e</p><p>&nbsp;&nbsp;&nbsp;&nbsp;你写的每个脚本都应该在文件开头加上set -e, 这句语句告诉bash如果任何语句的执行结果不是true则应该退出</p><p>2) exec &quot;$@&quot;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;几乎在每个docker-entrypoint.sh脚本的最后一行, 执行的都是 exec &quot;$@&quot;命令，它的意思是匹配所有参数，原封不动的执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这个命令的意义在于你已经为你的镜像预想到了应该有的调用情况, 当实际使用镜像的人执行了你没有预料到的可执行命令时, 将会走到脚本的这最后一行, 去执行用户新的可执行命令。</p><p>&nbsp;&nbsp;&nbsp; 参见：<a href="https://www.cnblogs.com/breezey/p/8812197.html">https://www.cnblogs.com/breezey/p/8812197.html</a><br/></p><p>3) entry-point指令的正常执行的最后一句，要前台执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;为什么？因为“docker容器在其主进程完成时退出”，entry-point执行完后，docker容器就退出了。让docker容器一直运行的办法就是，entry-point命令不结束，如果最后一个命令是后台运行，entry-point脚本就结束了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;所以，建议使用 exec 执行最后一个命令。如果最后一句是执行一个脚本，那么这个脚本中的最后一个命令也要后台运行。举个例子entry-point最后一句是 exec start.sh，start.sh里面最后一句是exec run.sh，那么实际上最后执行的是run.sh，务必保证它是前台运行（执行完不会退出的）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果最后那个命令不支持前台运行。那么下面是两种保持脚本不退出的解决方案：</p><pre class="brush:bash;toolbar:false">if [[ $1 == &quot;-d&quot; ]]; then    
    while true; do sleep 1000; done    
fi    

if [[ $1 == &quot;-bash&quot; ]]; then    
    /bin/bash    
fi    </pre><p><br/></p><p>3、WORKDIR</p><p>&nbsp;&nbsp;&nbsp;&nbsp;尽量使用绝对路径；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;切换目录的时候尽量使用 WORKDIR, 而不是使用 RUN cd /data。</p><p><br/></p><p>4、USER</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果容器中的应用程序运行时不需要特殊的权限, 可以通过 USER 指令把应用程序的所有者设置为非 root 用户. 如果该用户不存在, 首先需要使用 RUN 命令在镜像中创建用户。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果在每次编译镜像时, 对用户的 UID/GID 有要求需要保持一致, 应该在新建用户和组的时候指定 UID和 GID。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在镜像中避免使用sudo 命令，因为该命令使用的 TTY 不确定, 对接收信号量也会造成影响。如果确实需要使用 sudo 功能, 则可使用 gosu 命令替代。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;可以用 root 用户初始化一个 daemon, 然后用非 root 用户启动这个 daemon</p><p>&nbsp;&nbsp;&nbsp;&nbsp;为了减少镜像体积, 应该避免不必要的用户切换。</p><p><br/></p><p>5、Label</p><p>添加Label，以帮助按项目组织镜像，记录许可信息，帮助自动化或其他原因。</p><p>Label会增加层数，例如下面的：</p><pre class="brush:plain;toolbar:false"># Set one or more individual labels
LABEL com.example.version=&quot;0.0.1-beta&quot;
LABEL vendor1=&quot;ACME Incorporated&quot;
LABEL vendor2=ZENITH\ Incorporated
LABEL com.example.release-date=&quot;2015-02-12&quot;
LABEL com.example.version.is-production=&quot;&quot;</pre><p>旧版本docker建议将多行Label合并成一行，但是新版本（1.10以后），多行LABEL只会增加1层，不会增加多层。<br/></p><p><br/></p><p>6、Env</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Each ENV line creates a new intermediate layer, just like RUN commands. This means that even if you unset the environment variable in a future layer, it still persists in this layer and its value can be dumped. You can test this by creating a Dockerfile like the following, and then building it.</p><pre class="brush:bash;toolbar:false">FROM alpine
ENV ADMIN_USER=&quot;mark&quot;
RUN echo $ADMIN_USER &gt; ./mark
RUN unset ADMIN_USER</pre><pre class="brush:bash;toolbar:false">$ docker run --rm test sh -c &#39;echo $ADMIN_USER&#39;
mark</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;To prevent this, and really unset the environment variable, use a RUN command with shell commands, to set, use, and unset the variable all in a single layer. You can separate your commands with ; or &amp;&amp;. If you use the second method, and one of the commands fails, the docker build also fails.</p><pre class="brush:bash;toolbar:false">FROM alpine
RUN export ADMIN_USER=&quot;mark&quot; \
    &amp;&amp; echo $ADMIN_USER &gt; ./mark \
    &amp;&amp; unset ADMIN_USER
CMD sh</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;总结：<span style="color: rgb(192, 0, 0);">如果是固化到镜像中的环境变量，使用ENV XXX=xxx，但如果只是临时使用，则使用 RUN export XXX=xxx格式。</span><br/></p><p><br/></p><p>7、RUN</p><p>&nbsp;&nbsp;&nbsp;&nbsp;apt-get指令的话，推荐使用固定格式的“缓存清除”指令，形如：<br/></p><pre class="brush:bash;toolbar:false">RUN apt-get update &amp;&amp; apt-get install -y</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;Docker官方的示例为：<br/></p><pre class="brush:bash;toolbar:false">RUN apt-get update &amp;&amp; apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.* \
 &amp;&amp; rm -rf /var/lib/apt/lists/*</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;注意，官方 Debian and Ubuntu images 会自动 run apt-get clean, 因此不需要显示声明。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;另外，注意bash的管道（ | ）问题：</p><pre class="brush:bash;toolbar:false">RUN wget -O - https://some.site | wc -l &gt; /number</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;Docker executes these commands using the /bin/sh -c interpreter, which only evaluates the exit code of the last operation in the pipe to determine success. 上例中只要 wc -l 命令成功，build就成功了，即使 wget 命令失败了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;If you want the command to fail due to an error at any stage in the pipe, 设置&nbsp;<span style="color: rgb(192, 0, 0);">set -o pipefail &amp;&amp;</span> to ensure that an unexpected error prevents the build from inadvertently succeeding. For example:</p><pre class="brush:bash;toolbar:false">RUN set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;注意：不是所有的 shells 都支持 -o pipefail 选项：</p><p>&nbsp; &nbsp; 比如&nbsp;the dash shell on Debian-based images, 建议使用下面的格式来显式声明/bin/bash 设置 pipefail 选项:<br/></p><pre class="brush:bash;toolbar:false">RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;set -o pipefail &amp;&amp; wget -O - https://some.site |</pre><p><br/></p><p>8、使用最小化Linux镜像时，添加必要常用指令</p><p>&nbsp;&nbsp;&nbsp;&nbsp;例如ping、wget、curl、tar、tail、more、vi、vim、cat、sed、netstat、ps、top、ifconfig、hostname、telnet、lsof、tcpdump、tree、tee、cut、wc、touch、find、head、sort、du、df、ip、nslookup、route、traceroute等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;实际经验：如果没有这些基础命令，需要在容器内排查问题，比如查看端口、tcp连接、线程等，都做不到。</p><p><br/></p><p>9、Dockfile离线安装和使用本地文件、软件包时不使用ADD和COPY</p><p>&nbsp;&nbsp;&nbsp;&nbsp;举个例子，你在Dockerfile中，要安装一个 xxxx.rpm 包，这个包有5GB，如果使用COPY或者ADD指令，将添加一个包含了这个5GB的文件层，简单的解决办法为搭建一个HTTP Server，通过url去下载这个本地文件。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;python3以下，在文件目录执行：</p><pre class="brush:bash;toolbar:false">python -m SimpleHTTPServer 8069</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;python3执行：</p><pre class="brush:bash;toolbar:false">python -m http.server --bind 192.168.178.20 8000</pre><p>然后就可以使用 wget <a href="http://192.168.178.20:8000/xxxx.rpm">http://192.168.178.20:8000/xxxx.rpm</a>&nbsp;下载这个文件了。</p><p><br/></p><h3>实践经验</h3><p>参见：<a href="my-docker-build-note.html" target="_blank">《我的Dockerfile构建笔记》</a></p><p><br/></p>
{% endraw %}
