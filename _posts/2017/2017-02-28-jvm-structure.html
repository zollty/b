---
layout: ue
title: JVM结构
category: JavaEE技术
tags: JVM,Java
keywords: "JVM结构,栈帧"
---

<p><br/></p><p><strong><span style="font-size: 20px;">一、初识JVM</span></strong></p><p><br/></p><p><strong>1、虚拟机（Virtual Machine)概念</strong></p><p><br/></p><p>JRE是由Java API和JVM组成的。JVM的主要作用是通过Class Loader来加载Java程序，并且按照Java API来执行加载的程序。</p><p><br/></p><p>虚拟机是通过软件的方式来模拟实现的机器（比如说计算机），它可以像物理机一样运行程序。设计虚拟机的初衷是让Java能够通过它来实现WORA(Write Once Run Anywhere 一次编译，到处运行），尽管这个目标现在已经被大多数人忽略了。因此，JVM可以在不修改Java代码的情况下，在所有的硬件环境上运行Java字节码。</p><p><br/></p><p>Java虚拟机的特点如下：</p><p><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>基于栈的虚拟机</strong>：Intel x86和ARM这两种最常见的计算机体系的机构都是基于寄存器的。不同的是，JVM是基于栈的。</p></li><li><p><strong>符号引用</strong>：除了基本类型以外的数据（类和接口）都是通过符号来引用，而不是通过显式地使用内存地址来引用。</p></li><li><p><strong>垃圾回收机制</strong>：类的实例都是通过用户代码进行创建，并且自动被垃圾回收机制进行回收。</p></li><li><p>通过对<strong>基本类型</strong>的清晰定义来<strong>保证平台独立性</strong>：传统的编程语言，例如C/C++，int类型的大小取决于不同的平台。JVM通过对基本类型的清晰定义来保证它的兼容性以及平台独立性。</p></li><li><p><strong>网络字节码顺序</strong>：Java class文件用网络字节码顺序来进行存储:为了保证和小端的Intel x86架构以及大端的RISC系列的架构保持无关性，<strong>JVM使用用于网络传输的网络字节顺序，也就是大端</strong>。</p></li></ul><p><br/></p><p>虽然是Sun公司开发了Java，但是所有的开发商都可以开发并且提供遵循Java虚拟机规范的JVM。正是由于这个原因，使得Oracle HotSpot和IBM JVM等不同的JVM能够并存。<span style="text-decoration: underline;">Google的Android系统里的Dalvik VM也是一种JVM，虽然它并不遵循Java虚拟机规范</span><span style="text-decoration: underline;">。和基于栈的Java虚拟机不同，Dalvik VM是基于寄存器的架构</span>，因此它的Java字节码也被转化成基于寄存器的指令集。</p><p><br/></p><p><strong>2、JVM发展历史</strong></p><p><br/></p><p><strong>Java发展史：</strong></p><p>1996年：SUN JDK 1.0 <strong>Classic VM</strong></p><p>　　　　纯解释运行，使用外挂进行JIT</p><p>1997年：JDK1.1 发布</p><p>　　　　AWT、内部类、JDBC、RMI、反射</p><p>1998年：JDK1.2 <strong>Solaris Exact VM</strong></p><p>　　　　JIT 解释器混合 &nbsp; &nbsp;</p><p>　　　　Accurate Memory Management 精确内存管理，数据类型敏感</p><p>　　　　提升了GC性能</p><p>　　　　注：JDK1.2开始，称为Java 2，于是有了J2SE J2EE J2ME 的出现，同时加入Swing Collections。</p><p>2000年：JDK 1.3，<strong>Hotspot 作为默认虚拟机发布</strong></p><p>　　　　加入JavaSound</p><p>2002年：JDK 1.4【Java真正走向成熟的一个版本】，<strong>Classic VM退出历史舞台</strong></p><p>　　　　加入：Assert &nbsp;正则表达式 &nbsp;NIO &nbsp;IPV6 &nbsp;日志API &nbsp;加密类库</p><p><br/></p><p>2004年：JDK 1.5【至关重要的版本】。即 JDK5 、J2SE 5 、Java 5</p><p><span style="line-height: 32.4px;">　　　　</span>泛型、<span style="line-height: 1.8;">注解、</span><span style="line-height: 1.8;">枚举、</span><span style="line-height: 1.8;">自动装箱、</span><span style="line-height: 1.8;">可变长参数、</span><span style="line-height: 1.8;">Foreach循环</span></p><p><br/></p><p>2006年：JDK 1.6发布，JDK6</p><p><span style="line-height: 32.4px;">　　　　</span>脚本语言支持、<span style="line-height: 1.8;">JDBC 4.0、</span><span style="line-height: 1.8;">Java编译器 API</span></p><p><br/></p><p>2011年：JDK7发布</p><p><span style="line-height: 32.4px;">　　　　</span>G1（全新的GC收集器）</p><p><span style="line-height: 1.8;"><span style="line-height: 32.4px;">　　　　</span>动态语言增强</span></p><p><span style="line-height: 32.4px;">　　　　</span>64位系统中的压缩指针</p><p><span style="line-height: 32.4px;">　　　　</span>NIO 2.0</p><p><br/></p><p>2014年：JDK8发布【重要的版本】</p><p><span style="line-height: 32.4px;">　　　　</span>Lambda表达式</p><p><span style="line-height: 32.4px;">　　　　</span>语法增强 &nbsp;Java类型注解</p><p><br/></p><p>2016年：计划发布JDK9</p><p>　　　　模块化</p><p><br/></p><p><strong>重大历史事件：</strong></p><p><br/></p><p>使用最为广泛的JVM为HotSpot</p><p>　　　　HotSpot 为Longview Technologies开发，被SUN收购</p><p><br/></p><p>2006年：Java开源，并建立OpenJDK，</p><p>　　　　<strong>HotSpot &nbsp;成为Sun JDK和OpenJDK中所带的虚拟机</strong>。</p><p><br/></p><p>2008年：Oracle收购BEA</p><p>　　　　得到JRockit VM</p><p><br/></p><p>2009年：Oracle公司正式宣布以74亿美金的价格收购Sun公司。 &nbsp;</p><p><span style="line-height: 32.4px;">　　　　</span>得到Hotspot</p><p><br/></p><p>Oracle宣布在JDK8时整合JRockit和Hotspot，将这两款优秀的虚拟机取长补短，最终合二为一。</p><p>　　　　在Hotspot基础上，移植JRockit优秀特性</p><p><br/></p><p><strong>3、JVM种类</strong></p><p><br/></p><p>1. KVM：</p><p><span style="line-height: 1.8;"><span style="line-height: 32.4px;">　　　　</span>SUN发布</span><br/></p><p><span style="line-height: 1.8;"><span style="line-height: 32.4px;">　　　　</span>IOS Android兴起之前，广泛用于手机系统</span></p><p>2. CDC/CLDC HotSpot：</p><p><span style="line-height: 32.4px;">　　　　<span style="line-height: 32.4px;">J2ME的重要组成部分</span></span></p><p><span style="line-height: 32.4px;">　　　　</span>手机、电子书、PDA等设备上建立统一的Java编程接口</p><p>3. JRockit：</p><p><span style="line-height: 32.4px;">　　　　</span>BEA&nbsp;</p><p>4. IBM J9 VM：</p><p><span style="line-height: 32.4px;">　　　　</span>IBM内部</p><p>5. Apache Harmony：</p><p><span style="line-height: 32.4px;">　　　　</span>兼容于JDK 1.5和JDK 1.6的Java程序运行平台</p><p><span style="line-height: 32.4px;">　　　　</span>与Oracle关系恶劣，退出JCP ，Java社区的分裂</p><p><span style="line-height: 32.4px;">　　　　</span>OpenJDK出现后，受到挑战，2011年退役</p><p><span style="line-height: 32.4px;">　　　　</span>没有大规模商用经历</p><p><span style="line-height: 32.4px;">　　　　</span>对Android的发展有积极作用</p><p><br/></p><p><strong>4、JVM规范</strong></p><p>JVM语言规范主要体现在以下几点：</p><p><span style="line-height: 32.4px;">　　　　</span>Class文件类型</p><p><span style="line-height: 32.4px;">　　　　</span>运行时数据</p><p><span style="line-height: 32.4px;">　　　　</span>帧栈</p><p><span style="line-height: 32.4px;">　　　　</span>虚拟机的启动</p><p><span style="line-height: 32.4px;">　　　　</span>虚拟机的指令集</p><p>此外，JVM需要对Java Library 提供以下支持：（因为这些东西没有办法通过java语言本身来实现）</p><p><span style="line-height: 32.4px;">　　　　</span>反射 java.lang.reflect</p><p><span style="line-height: 32.4px;">　　　　</span>ClassLoader</p><p><span style="line-height: 32.4px;">　　　　</span>初始化class和interface</p><p><span style="line-height: 32.4px;">　　　　</span>安全相关 java.security</p><p><span style="line-height: 32.4px;">　　　　</span>多线程</p><p><span style="line-height: 32.4px;">　　　　</span>弱引用</p><p><br/></p><p><br/></p><p><span style="font-size: 20px;"><strong>二、Java字节码（Java bytecode) 和 Class文件</strong></span></p><p><br/></p><p>为了保证WORA，JVM使用Java字节码这种介于Java和机器语言之间的中间语言。字节码是部署Java代码的最小单位。</p><p>参见：<a href="http://www.importnew.com/1486.html">http://www.importnew.com/1486.html</a></p><p><br/></p><p><br/></p><p><span style="font-size: 20px;"><strong>三、JVM结构</strong></span></p><p><br/></p><p>JVM本身是一个规范，所以可以有多种实现，除了Hotspot外，还有诸如Oracle的JRockit、IBM J9也都是非常有名的JVM。通常我们基于Hotspot虚拟机来讲。</p><p><span style="line-height: 32.4px;">JVM的结构 主要由<strong>类加载器、运行时数据区（也叫做内存区）、执行引擎、本地方法接口</strong>等4部分组成，有点类似于<span style="line-height: 32.4px;">操作系统的结构</span>。如下图所示：</span></p><p><span style="line-height: 32.4px;"><img src="{{site.assets_url}}img/tech/jvm2.png" alt="jvm2.png"/></span></p><p><span style="line-height: 32.4px;"><img src="{{site.assets_url}}img/tech/jvm1.jpg" alt="jvm1.jpg"/>&nbsp;</span></p><p><span style="line-height: 32.4px;"><img src="{{site.assets_url}}img/tech/jvm3.png" alt="jvm3.png"/></span></p><p><span style="line-height: 32.4px;"><br/></span></p><p><span style="line-height: 32.4px;"></span></p><p><strong>1. 类加载器</strong>：在JVM启动时或者在类运行时将需要的class加载到JVM中。</p><p><strong>2. 执行引擎</strong>：负责执行class文件中包含的字节码指令；</p><p><strong><span style="line-height: 32.4px;">3. 本地方法接口</span></strong><span style="line-height: 32.4px;">：主要是调用C或C++实现的本地方法及返回结果。</span></p><p><strong>4. 内存区（也叫运行时数据区）</strong>：是在JVM运行的时候操作所分配的内存区。</p><p><span style="line-height: 1.8;">生动易懂的说明，参见：</span><a href="http://blog.csdn.net/yfqnihao/article/details/8289363" style="line-height: 1.8; background-color: rgb(245, 245, 213);">http://blog.csdn.net/yfqnihao/article/details/8289363</a><br/></p><p><br/></p><p><span style="font-size: 20px;"><strong>四、运行时数据区（Runtime Data Areas）</strong></span></p><p><br/></p><p><span style="line-height: 32.4px;">运行时数据区是在JVM运行的时候操作所分配的内存区。运行时内存区可以划分为5个区域</span>，如图：</p><p><img src="{{site.assets_url}}img/tech/jvm-rda.png" alt="jvm-rda.png"/></p><p><br/></p><p>在这6个区域中，其中3个：PC Register，JVM stack 以及Native Method Statck都是按照线程创建的，另外三个：Heap，Method Area以及Runtime Constant Pool都是被所有线程公用的。</p><p><br/></p><p><strong>&nbsp;PC寄存器(PC register)</strong>：每个线程启动的时候，都会创建一个PC(Program Counter ,程序计数器)寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。</p><p><strong>JVM 堆栈(JVM Stack)</strong>：每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。Java栈以帧为单位保存线程的运行状态。虚拟机只会直接对Java栈执行两种操作：以帧为单位的压栈（push）或出栈（pop）。如果出现了异常，堆栈跟踪信息的每一行都代表一个栈帧的信息，这些信息它是通过类似于printStackTrace()这样的方法来展示的。</p><p><span style="font-size: 20px;"><strong><span style="line-height: 1.8;">JVM堆栈</span></strong></span><span style="line-height: 1.8;">，如下图：</span><br/></p><p><span style="line-height: 1.8;"><img src="{{site.assets_url}}img/tech/jvm-stack.jpg" alt="jvm-stack.jpg"/></span></p><p><strong style="line-height: 1.8;">&nbsp;</strong><strong style="line-height: 1.8;">栈帧(stack frame)</strong><span style="line-height: 1.8;">：每当线程调用一个Java方法时，虚拟机都会在该线程的Java栈中压入一个新帧。而这个新帧自然就成为了当前帧。在执行这个方法时，它使用这个帧来存储参数、局部变量、中间运算结果等等数据。Java方法可以以两种方式完成。一种通过return返回的，称为正常返回；一种是通过抛出异常而异常中止的。不管以哪种方式返回，虚拟机都会将当前帧弹出Java栈然后释放掉，这样上一个方法的帧就成为当前帧了。每个栈帧里都包含有当前正在执行的方法所属类的<strong>局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息</strong>。本地变量数组的和操作数栈的大小都是在编译时确定的。因此，一个方法的栈帧的大小也是固定不变的。参考：<a href="http://denverj.iteye.com/blog/1218111">http://denverj.iteye.com/blog/1218111</a></span></p><p><strong>&nbsp; &nbsp; &nbsp; </strong><span style="text-decoration: none;">-&nbsp;</span><span style="text-decoration: underline;">局部变量数组(Local variable array)</span>：这个数组的索引从0开始。索引为0的变量表示这个方法所属的类的实例（this）。从1开始，首先存放的是传给该方法的参数，在参数后面保存的是方法的局部变量。参见：<a href="http://denverj.iteye.com/blog/1218298">http://denverj.iteye.com/blog/1218298</a></p><p><strong>&nbsp; &nbsp; &nbsp; </strong><span style="text-decoration: none;">- </span><span style="text-decoration: underline;">操作数栈(Operand stack)</span>：方法实际运行的工作空间。每个方法都在操作数栈和局部变量数组之间交换数据，并且压入或者弹出其他方法返回的结果。操作数栈所需的最大空间是在编译期确定的。因此，操作数栈的大小也可以在编译期间确定。</p><p><br/></p><p>&nbsp;<strong>本地方法栈(Native method stack)</strong>：它与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><p><br/></p><p><strong>&nbsp;方法区(Method area)：</strong>方法区是所有线程共享的，它是在JVM启动的时候创建的。JVM的提供者可以通过不同的方式来实现方法区<span style="line-height: 32.4px;">。是否对方法区进行垃圾回是可选的</span>。在Oracle 的HotSpot JVM里<span style="line-height: 32.4px;"></span>，方法区被称为永久代（PermGen），默认最小值为16MB，最大值为64MB<span style="line-height: 32.4px;">（</span><span style="line-height: 32.4px;">JDK 1.8中永久区被移除了，取而代之的是元数据区</span><span style="line-height: 32.4px;">）</span>。方法区<span style="line-height: 32.4px;">保存所有被JVM加载的</span><span style="font-weight: 700; line-height: 32.4px;">类的描述信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的字节码</span><span style="line-height: 32.4px;">。</span>参见：<a href="http://denverj.iteye.com/blog/1209506">http://denverj.iteye.com/blog/1209506</a></p><p><img src="{{site.assets_url}}img/tech/method-area.jpg" alt="method-area.jpg"/></p><p>（注意：此图中第5个写错了，应该是 静态变量）</p><p>&nbsp; &nbsp; &nbsp; 补充：在<strong>Class文件结构</strong>中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><p>&nbsp; &nbsp; 类和接口的全限定名</p><p>&nbsp; &nbsp; 字段名称和描述符</p><p>&nbsp; &nbsp; 方法名称和描述符</p><p>Java中八种基本类型的包装类的大部分都实现了常量池技术，它们是Byte、Short、Integer、Long、Character、Boolean，另外两种浮点数类型的包装类(Float、Double)则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值在-128到127时才可使用对象池。参见：<a href="http://chenzehe.iteye.com/blog/1727062">http://chenzehe.iteye.com/blog/1727062</a></p><p><strong>&nbsp; &nbsp; &nbsp;</strong>- <strong><span style="text-decoration: underline;">运行时常量池(Runtime constant pool)</span></strong>：这个区域是包含在方法区里的，不过，对于JVM的操作而言，它是一个核心的角色。因此在JVM规范里特别提到了它的重要性。存放<strong><span style="line-height: 1.8;">直接常量(基本类型，String)和对其他类型、方法、字段的符号引用</span></strong><span style="line-height: 1.8;">，例如：</span><span style="line-height: 1.8;">类和接口的全限定名、</span><span style="line-height: 1.8;">字段的名称和描述符、</span><span style="line-height: 1.8;">方法和名称和描述符。</span><span style="line-height: 1.8;">池中的数据和数组一样通过索引访问。</span><span style="line-height: 1.8;">简而言之，当一个方法或者变量被引用时，JVM通过运行时常量区来查找方法或者变量在内存里的实际地址。</span></p><p><br/></p><p><strong>堆(Heap)</strong>：用来保存实例或者对象的空间，而且它是垃圾回收的主要目标。JVM提供者可以决定怎么来配置堆空间，以及不对它进行垃圾回收。几乎所有的对象实例都在这里分配内存。 如果从内存回收的角度看，由于现在收集器（比如Hotspot）基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。参见我的另一篇相关的文章《JVM内存管理和垃圾回收》。</p><p><span style="line-height: 32.4px;"><br/></span></p><p><br/></p><p><br/></p>