---
layout: ue
title: JVM运行时数据区
category: Java编程与JVM
tags: JVM
keywords: "JVM,JVM Stack,帧栈"
---

<h2>一、JVM的Run-Time Data Areas（运行时数据区）包含哪些部分？</h2><p>运行时数据区是在JVM运行的时候操作所分配的内存区。运行时内存区可以划分为5个区域，如图：</p><p style="white-space: normal;"><img src="http://localhost:9500{{site.assets_url}}img/20190412/1555049446968043110.jpg" title="1555049446968043110.jpg" alt="rt-data-area.jpg"/></p><p>在上图的区域中，其中3个：PC Register，JVM stack 以及Native Method Statck都是按照线程创建的，另外三个：Heap，Method Area以及Runtime Constant Pool都是被所有线程公用的。</p><p>根据Oracle Java SE8 官方文档：</p><p>（The Java® SE 8 Edition of The Java Virtual Machine Specification）</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5</a></p><p>运行时内存区包含如下 5个部分：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p><span style="color: rgb(192, 0, 0);">The pc Register</span>（程序计数器，Program Counter Register）</p></li><li><p><span style="color: rgb(192, 0, 0);">JVM Stacks</span>（虚拟机栈，包含很多 “栈帧Frame”）</p><p><span style="font-size: 12px;">—— 在JVM Spec v1.0版本中 叫做 “Java Stack”</span></p></li><li><p><span style="color: rgb(192, 0, 0);">Heap</span>（堆）<br/></p></li><li><p><span style="color: rgb(192, 0, 0);">Method Area</span>（方法区）</p><p>方法区包括：<span style="color: rgb(192, 0, 0);">Run-Time Constant Pool</span>（运行时常量池）</p></li><li><div><p><span style="color: rgb(192, 0, 0);">Native Method Stacks</span>（本地方法栈）</p></div></li></ol><p><br/></p><h3>1、Program Counter Register</h3><p>Oracle的官方文档：</p><p>&nbsp; &nbsp; 每个JVM线程都有自己的PC（程序计数器）寄存器。在任何时候，每个JVM线程都在执行一个且仅一个Method的代码，这个Method叫Current Method。如果该Method不是原生的，则PC寄存器包含当前正在执行的JVM指令的地址（Address of the current instruction (or opcode) unless it is native）。如果当前由线程执行的方法是原生的，则JVM的PC寄存器的值是undefined的。JVM的PC寄存器足够大，可以在特定平台上保存返回地址或本地指针。</p><p>&nbsp; &nbsp; All CPUs have a PC, typically the PC is incremented after each instruction and therefore holds the address of the next instruction to be executed. The JVM uses the PC to keep track of where it is executing instructions, the PC will in fact be pointing at a memory address in the Method Area.</p><p>简而言之：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="text-decoration: underline;">每个线程启动的时候，都会创建一个PC(Program Counter ,程序计数器)寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><p><br/></p><h3>2、JVM Stack（又叫Java Stack）</h3><p>Oracle的官方文档：</p><p>&nbsp; &nbsp; 每个线程都有自己的Stack，为在该线程上执行的每个方法保存一个帧（Frame）。Stack是后进先出（LIFO）数据结构，因此当前执行的方法位于Stack的顶部。为每个方法调用创建一个新的Frame并将其添加（推送）到Stack的顶部。当方法正常返回或在方法调用期间引发未捕获的异常时，Frame将被移除（弹出）。除了push和pop帧对象外，Stack不直接被操作，因此帧对象可以在堆中分配，内存不需要是连续的。（英语原文：<a href="http://blog.jamesdbloom.com/JVMInternals.html#stack" target="_blank">Stack</a>）</p><p>&nbsp; &nbsp; JVM Stack的结构为：{JVM Stack [Frame][Frame][Frame]... }<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM Spec规定，Stack可以是动态大小或固定大小。如果线程需要的Stack数量大于允许的Stack，则会引发StackOverflowError。如果一个线程需要一个新的帧，并且没有足够的内存来分配它，那么就会抛出OutOfMemoryError。</p><p>简而言之：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。Java栈以帧为单位保存线程的运行状态。虚拟机只会直接对Java栈执行两种操作：以帧为单位的压栈（push）或出栈（pop）。如果出现了异常，堆栈跟踪信息的每一行都代表一个栈帧的信息，这些信息它是通过类似于printStackTrace()这样的方法来展示的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这里所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;关于栈内存的分配，参考C语言：</p><p>1）栈区（stack）—&nbsp; 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。&nbsp;</p><p>2）堆区（heap） — 一般由程序员分配释放。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;其实Java中，堆内存（Heap）和栈内存（Stack）也是类似的，Java需要的栈内存是由编译器自动分配的，它不占用Heap内存空间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;虚拟机栈的最大总内存大致上等于：</p><pre class="brush:plain;toolbar:false">=&nbsp;JVM进程能占用的最大内存（依赖于具体操作系统和配置）
&nbsp;&nbsp;&nbsp;-&nbsp;最大堆内存
&nbsp;&nbsp;&nbsp;-&nbsp;最大方法区内存
&nbsp;&nbsp;&nbsp;-&nbsp;程序计数器内存（可以忽略不计）&nbsp;-&nbsp;JVM进程本身消耗内存</pre><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;关于 Stack <span style="color: rgb(192, 0, 0);"></span>Frame 栈帧 的详细说明，参见后文“<span style="color: rgb(36, 64, 97);">JVM Stack的Frame</span>”章节。<br/></p><p><br/></p><h3>3、Native Method Stacks（简称native stack）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;它与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。&nbsp;</p><p>详细说明：</p><p>&nbsp; &nbsp; &nbsp;Java线程调用native method（非Java语言编写的程序）时，通常会创建native stack（类似于C语言的stack）来支持。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界 ，本地方法可以通过本地方法接口来访问虚拟机运行时的数据区，但不止于此，他还可以做任何他想做的事情。比如，他甚至可以直接使用本地处理器中的寄存器，或者直接从本地内存的堆中分配任意数量的内存等等。总之，他和虚拟机拥有同样的权限（或者说能力）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当他调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;并且native方法通常（取决于JVM实现）可以返回JVM并调用Java方法。这样的从native到Java的调用将在JVM堆栈上发生，该线程会保存本地方法栈的状态并进入到JVM并在JVM堆栈上创建新的帧。一个线程可能在整个生命周期中都执行Java方法，操作他的Java栈；或者他可能毫无障碍地在Java栈和本地方法栈之间跳转。如下图所示：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="{{site.assets_url}}img/20190416/1555407282267086590.jpg" title="1555407282267086590.jpg" alt="03231458_sjaE1.jpg"/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Native stack的特点和JVM stack是一样的，可以是动态大小或固定大小，都可能导致产生StackOverflowError和OutOfMemoryError。</p><p><br/></p><h3>4、Heap</h3><p>Oracle官方文档：&nbsp;</p><p>&nbsp;&nbsp; 堆是运行时数据区域，从中为所有类实例和数组分配内存。堆内存被所有JVM线程共享。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;The Heap is used to allocate class instances and arrays at runtime. Arrays and objects can never be stored on the stack because a frame is not designed to change in size after it has been created.&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;The frame only stores references that point to objects or arrays on the heap. Unlike primitive variables and references in the local variable array (in each frame), objects are always stored on the heap so they are not removed when a method ends. Instead objects are only removed by the garbage collector.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;To support garbage collection the heap is divided into three sections:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>Young Generation（Often split between Eden and Survivor）</p></li><li><p>Old Generation (also called Tenured Generation)</p></li><li><p>Permanent Generation</p></li></ul><p>简而言之：</p><p>&nbsp; &nbsp; Java堆用来保存实例或者对象的空间，而且它是垃圾回收的主要目标。JVM提供者可以决定怎么来配置堆空间，以及不对它进行垃圾回收。几乎所有的对象实例都在这里分配内存。 如果从内存回收的角度看，由于现在收集器（比如Hotspot）基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p><p>详细描述：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。<span style="text-indent: 0em;">Java堆只要求逻辑上是连续的，在物理空间上可以不连续。</span></p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;堆的分区图如下：</p><p style="white-space: normal;"><img src="http://localhost:9500{{site.assets_url}}img/20181127/1543311151403041208.gif" alt="1543311151403041208.gif"/></p><p>&nbsp; &nbsp; 关于Heap和Non-Heap的内存管理，参见我的另一篇文章《JVM内存管理和垃圾回收》。</p><p><br/></p><h3>5、Method Area</h3><p>Oracle官方文档：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;方法区存储<strong>每个类的结构</strong>，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化及接口初始化中使用的特殊方法(例如&lt;clinit&gt;)。方法区存在OutOfMemoryError。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;The method area stores <span style="color: rgb(192, 0, 0);">per-class information 包括</span>:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>Classloader Reference</strong></p></li><li><p><strong>Run Time Constant Pool</strong></p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="text-decoration: none;">（参见后面的专题说明）</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>Field data</strong></p></li></ul><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;（Per field）</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifiers</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attributes</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>Method data</strong></p></li></ul><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Per method)</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return Type</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter Types (in order)</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modifiers</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attributes</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>Method code</strong></p></li></ul><p><span style="font-size: 12px;">&nbsp; &nbsp;（Per method）</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-size: 12px; text-decoration: underline;">Bytecodes</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operand stack size</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Local variable size</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Local variable table</span></p><p><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exception table</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;方法区中这些类的信息，其实在&nbsp;Class File Structure 中可以找到，具体参见<a href="http://blog.jamesdbloom.com/JVMInternals.html#class_file_structure" target="_blank">Class File Structure</a>。&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;All threads share the same method area, so access to the method area data and the process of dynamic linking <strong>must be thread safe</strong>. If two threads attempt to access a field or method on a class that has not yet been loaded it must only be loaded once.</p><p>简而言之：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;方法区是所有线程共享的，它是在JVM启动的时候创建的。JVM的提供者可以通过不同的方式来实现方法区。是否对方法区进行垃圾回是可选的。在Oracle 的HotSpot JVM里，方法区被称为永久代（PermGen），默认最小值为16MB，最大值为是MaxPermSize，默认是64M。（JDK 1.8中永久区被移除了，取而代之的是元数据区）。方法区保存所有被JVM加载的类的描述信息(包括类的名称、方法信息、字段信息)、运行时常量池，以及编译器编译后的字节码。参见：<a href="http://denverj.iteye.com/blog/1209506" target="_blank">http://denverj.iteye.com/blog/1209506</a></p><p>详细说明：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、JIT编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>补充：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;方法区存放的数据，和Class字节码息息相关。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。<br/></p><p><br/></p><h3>6、关于 运行时常量池（Run Time Constant Pool）</h3><p>为了解释运行时常量池，还得先知道Class文件结构，常量池表（constant_pool table） 和 字符串常量池（String Pool）。参见后面的专题讲解。</p><p style="white-space: normal;">简而言之：</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;运行时数据区是包含在方法区里的，不过，对于JVM的操作而言，它是一个核心的角色，因此在JVM规范里特别提到了它的重要性。它存放字面量和符号引用量，包含了类或接口所有的静态信息。池中的数据通过索引访问，当一个类、方法或者变量被引用时，JVM通过运行时常量区来查找方法或者变量在内存里的实际地址。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;每个运行时常量池都是从JVM的方法区域分配的，它也存在OutOfMemoryError。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;有关运行时常量池的构造信息，可参见 类的<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3" target="_blank">加载、链接和初始化</a>。</p><p><br/></p><h3>7、Non-heap</h3><p>非堆区的定义为：Objects that are logically considered as part of the JVM mechanics are not created on the Heap.</p><p>那么除了heap之外的，栈内存（包括JVM Stack和Native Method Stack）和Method Area应该是属于Non-heap，除此之外，还有如下：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>Permanent Generation</strong> that contains</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the method area</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interned strings</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>Code Cache</strong> used for compilation and storage of methods that have been compiled to native code by the JIT compiler</p></li></ul><p>注意要明白Code Cache，首先要清楚 JIT compiler。</p><p><br/></p><h2>二、JVM Stack的Frame（帧）包含哪些部分？</h2><p>根据Oracle Java SE8 官方文档：</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6</a></p><p>Frame包含如下内容：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>Local Variables Array （局部变量，数组）</p></li><li><p>Operand Stacks（操作数栈，LIFO stack）</p></li><li><p>Dynamic Linking（动态链接）</p><p>a reference to the <span style="text-decoration: none;">run-time constant pool&nbsp;</span>of the class of the current method.<br/></p></li><li><p>Return Address</p><p><span style="font-size: 14px;"><em>Normal Method Invocation Completion（方法返回地址——正常完成出口）</em></span></p><p><span style="font-size: 14px;"><em>Abrupt Method Invocation Completion（方法返回地址——异常完成出口）</em></span></p></li><li><p>Extended information （扩展信息，取决于具体实现，例如debug信息）<br/></p></li></ol><p>其中，一般把（动态链接、方法返回地址、附加信息）统称 “帧栈信息(frame data)”。所以，又可以说Frame由：“局部变量区，操作数栈和帧数据区”，三个部分组成。</p><p>下图反映了 frame的一些信息：</p><p><img src="{{site.assets_url}}img/20190412/1555062886967028223.png" title="1555062886967028223.png" alt="1555062886967028223.png" width="577" height="484"/></p><p>（基于The Java Virtual Machine Specification, Java SE 7 Edition）</p><p>Frame的基本结构为：</p><p>{Frame [ReturnValue] [LocalVariables[][][]...] [OperandStack [][][]...] [ConstPoolRef] }</p><p>详细说明如下：</p><h3>1. Local Variables</h3><p>&nbsp; &nbsp; Each frame contains an array of variables known as its local variables. The <span style="color: rgb(192, 0, 0);">length</span> of the local variable array of a frame is <span style="color: rgb(192, 0, 0);">determined</span> at compile-time.</p><p>&nbsp; &nbsp; A single local variable can hold a value of type <span style="color: rgb(192, 0, 0);">boolean, byte, char, short, int, float, reference, or returnAddress</span>. A pair of local variables can hold a value of type <span style="color: rgb(192, 0, 0);">long or double（占两个连续位置，For example, a value of type double stored in the local variable array at index n actually occupies the local variables with indices n and n+1）</span>. 注意，这并不要求数组长度为偶数，long和double不需要64位对齐，实现方式是自由的）。</p><p>&nbsp; &nbsp;&nbsp;The JVM uses local variables to pass parameters on method invocation.（JVM使用local variables在方法调用时传递参数）。</p><p>&nbsp; &nbsp; 在实例方法被调用时，local variables数组下标0的元素，通常用来存放 this引用，其它参数从位置1开始，在类方法被调用时，则没有this。参见：<a href="http://denverj.iteye.com/blog/1218298" target="_blank">http://denverj.iteye.com/blog/1218298</a></p><p>&nbsp; &nbsp; 在后面的 Operand Stacks章节中，将展示Local variables的一个实际使用场景。</p><h3>2. Operand Stacks</h3><p>&nbsp; &nbsp; Each frame contains a <span style="color: rgb(192, 0, 0);">last-in-first-out (LIFO) stack</span> known as its operand stack. The <span style="color: rgb(192, 0, 0);">maximum depth</span> of the operand stack of a frame is <span style="color: rgb(192, 0, 0);">determined</span> at compile-time.</p><p>&nbsp; &nbsp; The operand stack is empty when the frame that contains it is created（当frame创建的时候stack是空的）. The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack（然后JVM指令加载本地变量或者类属性到 操作数栈中）. Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack（其它JVM指令从 操作数栈中取数据，然后把结果存入 操作数栈中）. The operand stack is also used to prepare parameters to be passed to methods and to receive method results（操作数栈也被用来 存放将要传入方法的参数 和 从方法返回的结果）.</p><p>简而言之：<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;操作数栈(Operand stack) 是 方法实际运行的工作空间。每个方法都在操作数栈和局部变量数组之间交换数据，并且压入或者弹出其他方法返回的结果。操作数栈所需的最大空间是在编译期确定的。因此，操作数栈的大小也可以在编译期间确定。</p><p>&nbsp; &nbsp;&nbsp;例如，iadd指令将两个int值相加。它要求要添加的int值是操作数堆栈的前两个值，由前面的指令推送到这里。两个int值都从操作数堆栈中弹出。相加之后，它们的和被推回到操作数堆栈中。子计算可以嵌套在操作数堆栈上，从而子计算产生的值可以被使用。</p><p>&nbsp; &nbsp;&nbsp;Each entry on the operand stack can hold a value of any Java Virtual Machine type, including a value of type long or type double.（操作数栈 上的条目 可以是任意JVM类型，包括long和double）</p><p>&nbsp; &nbsp; At any point in time, an operand stack has an associated depth（在任何一个确定的时间，可以知道操作数栈的深度）, where a value of type long or double contributes two units to the depth and a value of any other type contributes one unit.（其中long和double栈两个单元，其他类型占一个单元）</p><p>&nbsp; &nbsp; 补充：The sizes of the local variable array and the operand stack are determined at compile-time, Thus the memory for these structures can be allocated simultaneously on method invocation（在方法被调用时分配内存）.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;举个例子，Java代码如下：<br/></p><pre class="brush:java;toolbar:false">int&nbsp;a=1;
int&nbsp;b=2;
int&nbsp;c=a+b;</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;它的执行过程如下：<br/></p><p>0: iconst_1 // Push 1 to the operation of the stack. A value of int greater than 5 will use the bipush &lt;i&gt; instruction.&nbsp;</p><p>1: istore_0 // Pop the top element, stored in the index=0 local variable.&nbsp;</p><p>2: iconst_2 // Push 2 to the operation of the stack</p><p>3: istore_1 // Pop the top element on the stack, stored in the index=1 local variable.&nbsp;</p><p><span style="color: rgb(192, 0, 0);">首先，获得 常量1和2，分别存入local variable中的第1和第2的位置（假设local variable之前是空的）；</span></p><p>4: iload_0&nbsp; // The local variable load index=0 to the top of the stack</p><p>5: iload_1&nbsp; // The local variable load index=1 to the top of the stack</p><p>6: iadd&nbsp; &nbsp; &nbsp;// The top two numbers pop out together, and stores the result to the top of the stack</p><p><span style="color: rgb(192, 0, 0);">然后从local variable中取出第1和第2位置的数据，进行add操作；</span></p><p>7: istore_2 // Store the results to the index=2 local variable</p><p><span style="color: rgb(192, 0, 0);">最后，把上一步的add结果存入 local variable的第3位置。</span></p><p><br/></p><h3>3. Dynamic Linking</h3><p>Each frame contains a reference to the run-time constant pool for the type of the current method to support dynamic linking of the method code（每个帧都包含对运行时常量池的引用，以支持method code的动态链接）. The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references（method code代表的是 将要被调用的方法和通过 符号引用被访问的变量）. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols（动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号）, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables（并将变量访问转换为与这些变量的运行时位置相关联的存储结构中的适当偏移量）.</p><p><br/></p><h2>三、对 运行时常量池 的进一步理解</h2><p style="white-space: normal;">为了解释运行时常量池，还得先知道Class文件结构、常量池表（constant_pool table） 和&nbsp;字符串常量池（String Pool）。</p><p style="white-space: normal;"><br/></p><h3>1、Class File Structure 以及 常量池表（constant_pool table）</h3><p style="white-space: normal;">一个编译后的Class结构如下：</p><pre class="brush:java;toolbar:false">ClassFile&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;u4			magic;
&nbsp;&nbsp;&nbsp;&nbsp;u2			minor_version;
&nbsp;&nbsp;&nbsp;&nbsp;u2			major_version;
&nbsp;&nbsp;&nbsp;&nbsp;u2			constant_pool_count;
&nbsp;&nbsp;&nbsp;&nbsp;cp_info		contant_pool[constant_pool_count&nbsp;–&nbsp;1];
&nbsp;&nbsp;&nbsp;&nbsp;u2			access_flags;
&nbsp;&nbsp;&nbsp;&nbsp;u2			this_class;
&nbsp;&nbsp;&nbsp;&nbsp;u2			super_class;
&nbsp;&nbsp;&nbsp;&nbsp;u2			interfaces_count;
&nbsp;&nbsp;&nbsp;&nbsp;u2			interfaces[interfaces_count];
&nbsp;&nbsp;&nbsp;&nbsp;u2			fields_count;
&nbsp;&nbsp;&nbsp;&nbsp;field_info		fields[fields_count];
&nbsp;&nbsp;&nbsp;&nbsp;u2			methods_count;
&nbsp;&nbsp;&nbsp;&nbsp;method_info		methods[methods_count];
&nbsp;&nbsp;&nbsp;&nbsp;u2			attributes_count;
&nbsp;&nbsp;&nbsp;&nbsp;attribute_info	attributes[attributes_count];
}</pre><p>含义如下：</p><table><tbody><tr class="firstRow"><td width="468" valign="top" style="word-break: break-all;"><p>magic,&nbsp;</p><p>minor_version,&nbsp;</p><p>major_version</p></td><td width="468" valign="top" style="word-break: break-all;">specifies information about the version of the class and the version of the JDK this class was compiled for.</td></tr><tr><td width="468" valign="top" style="word-break: break-all;"><span style="color: rgb(192, 0, 0);">constant_pool</span></td><td width="468" valign="top" style="word-break: break-all;">similar to a symbol table although it contains more data this is described in more detail below.</td></tr><tr><td width="468" valign="top" style="word-break: break-all;">access_flags</td><td width="468" valign="top" style="word-break: break-all;">provides the list of modifiers for this class.</td></tr><tr><td width="468" valign="top" style="word-break: break-all;">this_class</td><td width="468" valign="top" style="word-break: break-all;">index into the <em>constant_pool</em> providing the fully qualified name of this class i.e. org/jamesdbloom/foo/Bar</td></tr><tr><td width="468" valign="top" style="word-break: break-all;">super_class</td><td width="468" valign="top" style="word-break: break-all;">index into the <em>constant_pool</em> providing a symbolic reference to the super class i.e. <em>java/lang/Object</em></td></tr><tr><td width="468" valign="top" style="word-break: break-all;">interfaces</td><td width="468" valign="top" style="word-break: break-all;">array of indexes into the <em>constant_pool</em> providing a symbolic references to all interfaces that have been implemented.</td></tr><tr><td width="468" valign="top" style="word-break: break-all;">fields</td><td width="468" valign="top" style="word-break: break-all;">array of indexes into the <em>constant_pool</em> giving a complete description of each field.</td></tr><tr><td width="468" valign="top" style="word-break: break-all;">methods</td><td width="468" valign="top" style="word-break: break-all;">array of indexes into the <em>constant_pool</em> giving a complete description of each method signature, if the method is not abstract or native then the bytecode is also present.</td></tr><tr><td width="468" valign="top" style="word-break: break-all;">attributes</td><td width="468" valign="top" style="word-break: break-all;">array of different value that provide additional information about the class including any annotations with <em>RetentionPolicy.CLASS</em> or <em>RetentionPolicy.RUNTIME</em></td></tr></tbody></table><p style="white-space: normal;">其中最重要的莫过于 constant_pool了。</p><p style="white-space: normal;">可以用 javap 命令打印出 编译后的class文件的字节码内容，如下这个类：</p><pre class="brush:java;toolbar:false">package&nbsp;org.jvminternals;

public&nbsp;class&nbsp;SimpleClass&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;sayHello()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Hello&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}

}</pre><p>执行：</p><p>javap -v -p -s -sysinfo -constants classes/org/jvminternals/SimpleClass.class</p><p>可见如下字节码内容：</p><pre class="brush:java;toolbar:false;">public&nbsp;class&nbsp;org.jvminternals.SimpleClass
&nbsp;&nbsp;SourceFile:&nbsp;&quot;SimpleClass.java&quot;
&nbsp;&nbsp;minor&nbsp;version:&nbsp;0
&nbsp;&nbsp;major&nbsp;version:&nbsp;51
&nbsp;&nbsp;flags:&nbsp;ACC_PUBLIC,&nbsp;ACC_SUPER
Constant&nbsp;pool:
&nbsp;&nbsp;&nbsp;#1&nbsp;=&nbsp;Methodref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#6.#17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;java/lang/Object.&quot;&lt;init&gt;&quot;:()V
&nbsp;&nbsp;&nbsp;#2&nbsp;=&nbsp;Fieldref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#18.#19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;java/lang/System.out:Ljava/io/PrintStream;
&nbsp;&nbsp;&nbsp;#3&nbsp;=&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&quot;Hello&quot;
&nbsp;&nbsp;&nbsp;#4&nbsp;=&nbsp;Methodref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#21.#22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;java/io/PrintStream.println:(Ljava/lang/String;)V
&nbsp;&nbsp;&nbsp;#5&nbsp;=&nbsp;Class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;org/jvminternals/SimpleClass
&nbsp;&nbsp;&nbsp;#6&nbsp;=&nbsp;Class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;java/lang/Object
&nbsp;&nbsp;&nbsp;#7&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;init&gt;
&nbsp;&nbsp;&nbsp;#8&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()V
&nbsp;&nbsp;&nbsp;#9&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code
&nbsp;&nbsp;#10&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable
&nbsp;&nbsp;#11&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalVariableTable
&nbsp;&nbsp;#12&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this
&nbsp;&nbsp;#13&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lorg/jvminternals/SimpleClass;
&nbsp;&nbsp;#14&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sayHello
&nbsp;&nbsp;#15&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SourceFile
&nbsp;&nbsp;#16&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleClass.java
&nbsp;&nbsp;#17&nbsp;=&nbsp;NameAndType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#7:#8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&quot;&lt;init&gt;&quot;:()V
&nbsp;&nbsp;#18&nbsp;=&nbsp;Class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;java/lang/System
&nbsp;&nbsp;#19&nbsp;=&nbsp;NameAndType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#26:#27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;out:Ljava/io/PrintStream;
&nbsp;&nbsp;#20&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hello
&nbsp;&nbsp;#21&nbsp;=&nbsp;Class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;java/io/PrintStream
&nbsp;&nbsp;#22&nbsp;=&nbsp;NameAndType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#29:#30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;println:(Ljava/lang/String;)V
&nbsp;&nbsp;#23&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org/jvminternals/SimpleClass
&nbsp;&nbsp;#24&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java/lang/Object
&nbsp;&nbsp;#25&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java/lang/System
&nbsp;&nbsp;#26&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out
&nbsp;&nbsp;#27&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ljava/io/PrintStream;
&nbsp;&nbsp;#28&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java/io/PrintStream
&nbsp;&nbsp;#29&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println
&nbsp;&nbsp;#30&nbsp;=&nbsp;Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Ljava/lang/String;)V
{
&nbsp;&nbsp;public&nbsp;org.jvminternals.SimpleClass();
&nbsp;&nbsp;&nbsp;&nbsp;Signature:&nbsp;()V
&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;ACC_PUBLIC
&nbsp;&nbsp;&nbsp;&nbsp;Code:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=1,&nbsp;locals=1,&nbsp;args_size=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;aload_0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;invokespecial&nbsp;#1&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/lang/Object.&quot;&lt;init&gt;&quot;:()V
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;3:&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalVariableTable:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;&nbsp;Length&nbsp;&nbsp;Slot&nbsp;&nbsp;Name&nbsp;&nbsp;&nbsp;Signature
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;&nbsp;&nbsp;Lorg/jvminternals/SimpleClass;

&nbsp;&nbsp;public&nbsp;void&nbsp;sayHello();
&nbsp;&nbsp;&nbsp;&nbsp;Signature:&nbsp;()V
&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;ACC_PUBLIC
&nbsp;&nbsp;&nbsp;&nbsp;Code:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=2,&nbsp;locals=1,&nbsp;args_size=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;getstatic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Field&nbsp;java/lang/System.out:Ljava/io/PrintStream;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#3&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;&quot;Hello&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5:&nbsp;invokevirtual&nbsp;&nbsp;#4&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/io/PrintStream.println:(Ljava/lang/String;)V
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;6:&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;7:&nbsp;8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalVariableTable:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;&nbsp;Length&nbsp;&nbsp;Slot&nbsp;&nbsp;Name&nbsp;&nbsp;&nbsp;Signature
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;&nbsp;&nbsp;Lorg/jvminternals/SimpleClass;
}</pre><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;主要由 三部分构成：the constant pool, the constructor and the sayHello method.</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;注意看 constant pool 里面 #3 为 String，值指向的是 #20 为 Hello。另外，我还做了一个实验，如果把方法名称也改成 Hello，那么constant pool里面只会有一个 Hello。</p><p style="white-space: normal;"><br/></p><h3>2、运行时常量池（Run Time Constant Pool）</h3><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;它是<span style="color: rgb(192, 0, 0);">constant_pool</span>&nbsp;table&nbsp;<span style="color: rgb(192, 0, 0);">in a class file</span>的运行时表现形式。The constant_pool table in the binary representation of a class/interface is used to construct the run-time constant pool upon class/interface creation。（当一个类或接口被JVM创建时，constant_pool信息就会被用来构造运行时常量池）【注：具体是在resolving阶段执行，class加载过程：加载（Loading）、链接（包括：Verifying + Preparing + Resolving）和初始化（Initializing）】。</p><p style="white-space: normal;">附：constant_pool table 和&nbsp;Runtime Constant Pool的区别</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="white-space: normal;">常量池表（constant_pool table）</p></li></ul><p style="white-space: normal;"><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class文件中存储所有常量（包括字符串）的table。</span></p><p style="white-space: normal;"><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是Class&nbsp;</span><span style="font-size: 14px; text-decoration-line: underline;">字节码文件中</span><span style="font-size: 14px;">的一类结构化数据，还不是运行时的内容。</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="white-space: normal;">运行时常量池（Runtime Constant Pool）</p></li></ul><p style="white-space: normal;"><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM&nbsp;</span><span style="font-size: 14px; text-decoration-line: underline;">运行时内存中</span><span style="font-size: 14px;">方法区的一部分，这是运行时的内容。</span></p><p style="white-space: normal;"><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部分数据绝大部分是随着JVM 运行，从常量池表转化而来，</span><span style="font-size: 14px; text-decoration: underline;">每个Class 都对应一个运行时常量池</span><span style="font-size: 14px;">。</span></p><p style="white-space: normal;"><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面说绝大部分是因为：除了Class 中常量池内容，还可能包括动态生成并加入这里的内容。</span></p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池的功能类似于传统编程语言的符号表，尽管它包含的数据范围比典型符号表更广。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;常量池主要用于存放两大类常量：字面量(<span style="color: rgb(192, 0, 0);">Literal</span>) 和 符号引用量(Symbolic&nbsp;<span style="color: rgb(192, 0, 0);">References</span>)。主要类型如下（都是封装成结构体）：</p><p style="text-align: left;"><span style="color: rgb(227, 108, 9);"><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;1. The CONSTANT_Class_info Structure</span></span></p><p style="text-align: left;"><span style="font-size: 12px; color: rgb(227, 108, 9);">&nbsp;&nbsp;&nbsp;&nbsp;2. The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures</span></p><p style="text-align: left;"><span style="font-size: 12px; color: rgb(0, 112, 192);">&nbsp;&nbsp;&nbsp;&nbsp;3. The CONSTANT_String_info Structure</span></p><p style="text-align: left;"><span style="font-size: 12px; color: rgb(192, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;4. The CONSTANT_Integer_info and CONSTANT_Float_info Structures</span></p><p style="text-align: left;"><span style="font-size: 12px; color: rgb(192, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;5. The CONSTANT_Long_info and CONSTANT_Double_info Structures</span></p><p style="text-align: left;"><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;6. The CONSTANT_NameAndType_info Structure</span></p><p style="text-align: left;"><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;7. The CONSTANT_Utf8_info Structure</span></p><p style="text-align: left;"><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;8. The CONSTANT_MethodHandle_info Structure</span></p><p style="text-align: left;"><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;9. The CONSTANT_MethodType_info Structure</span></p><p style="text-align: left;"><span style="font-size: 12px;">&nbsp;&nbsp;&nbsp;&nbsp;10. The CONSTANT_InvokeDynamic_info</span></p><p style="white-space: normal;">具体说明参见JVM官方文档<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.1" target="_blank" style="background-color: rgb(245, 245, 213); white-space: normal;">The Run-Time Constant Pool</a>和<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" style="background-color: rgb(245, 245, 213); white-space: normal;">The Constant Pool</a>。</p><p style="white-space: normal;">字面量包括两种大类：<br/></p><ul class=" list-paddingleft-2" style="width: 929.094px; white-space: normal;"><li><p>numeric literals（对应上面的第4、5项）</p></li><li><p>string literals（对应上面的第3项）</p></li></ul><p>剩下的全都是 符号引用。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(192, 0, 0);">数字字面量(numeric literals) </span>包括IEEE 754标准的：int, long, float, 和double。Java语言中的各种基本类型都属于numeric literals。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;另外，Java中八种<span style="text-decoration-line: underline;">基本类型的包装类</span>（比如Integer、Long等）的大部分都实现了常量池技术，它们是Byte、Short、Integer、Long、Character、Boolean，另外两种浮点数类型的包装类(Float、Double)则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值在-128到127时才可使用对象池。参见：<a href="http://chenzehe.iteye.com/blog/1727062" target="_blank">http://chenzehe.iteye.com/blog/1727062</a></p><p style="white-space: normal;">&nbsp; &nbsp;<span style="color: rgb(192, 0, 0);"> 字符串字面量(string literals)</span> 是String类的引用。例如：</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;private String str = &quot;hello&quot;;&nbsp;</p><p style="white-space: normal;">&nbsp; &nbsp; 编译成字节码文件后，这个&quot;hello&quot;会存在于 constant_pool表中，最终 转换成 运行时常量池时，是这样做的：<br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>If the method String.intern has previously been called on an instance of class String containing a sequence of Unicode code points identical to that given by the CONSTANT_String_info structure, then the result of string literal derivation is a reference to that same instance of class String.（翻译一下就是，如果 包含该字符串的 Unicode序列的String类的intern方法已经被调用过了，那就直接用这个String的实例）</p></li><li><p>Otherwise, a new instance of class String is created containing the sequence of Unicode code points given by the CONSTANT_String_info structure; a reference to that class instance is the result of string literal derivation. Finally, the intern method of the new String instance is invoked.（否则，新new一个String类的实例来存放该 Unicode字符串序列，最后调用一次 该String实例的intern方法一次）</p></li></ul><p style="white-space: normal;">&nbsp; &nbsp; 但是，这里还没有说清楚，这个unicode字符序列，到底是存放在哪里的。后面会讲String Table，然后继续讨论这个问题。</p><p><br/></p><h3>3、字符串常量池（String Pool，或者String Table）</h3><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;JVM规范要求进入这里的String 实例叫“被驻留的字符串 - interned string”，各个JVM 可以有不同的实现，HotSpot 是设置了一个哈希表 - StringTable 来<strong>引用</strong>堆中的字符串实例，被引用就是被驻留（注意是引用，而不是存放，存放是在堆中Java1.7+）。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet&lt;String&gt;。这是个纯运行时的结构，而且是惰性（lazy）维护的。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。 注意，它只存了引用，根据这个引用可以得到具体的String对象。一般我们说一个字符串进入了全局的字符串常量池其实是说在这个StringTable中保存了对它的引用，反之，如果说没有在其中就是说StringTable中没有对它的引用。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;字符串常量池与运行时常量池不是一个概念：</p><ul class=" list-paddingleft-2" style="width: 929.094px; white-space: normal;"><li><p>&nbsp;&nbsp;&nbsp;&nbsp;String Pool 是JVM 实例全局共享的全局只有一个，而Runtime Constant Pool 每个类都有一个。<br/></p></li><li><p>&nbsp;&nbsp;&nbsp;&nbsp;String Pool 只记录字符串对象，而Runtime Constant Pool 记录各种对象。</p></li></ul><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;字符串池在JDK 1.7 之后存在于Heap 堆中，旧版存在于方法区中。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 - - - &gt; 共享元素模式。</p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;也就是说：一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。<br/></p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”。<br/></p><p style="white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt; 追踪OpenJDK 关于String pool实现方式，可略知一二：<br/></p><p style="white-space: normal;">String的native String intern()方法源码&nbsp;</p><p style="white-space: normal;">openjdk\jdk\src\share\native\java\lang\String.c</p><pre class="brush:cpp;toolbar:false;" style="line-height: 1.42857;">#include&nbsp;&quot;jvm.h&quot;
#include&nbsp;&quot;java_lang_String.h&quot;
JNIEXPORT&nbsp;jobject&nbsp;JNICALL
Java_java_lang_String_intern(JNIEnv&nbsp;*env,&nbsp;jobject&nbsp;this)
{
&nbsp;return&nbsp;JVM_InternString(env,&nbsp;this);
}</pre><p style="white-space: normal;">在jvm头文件中&nbsp;</p><p style="white-space: normal;">openjdk\jdk\src\share\javavm\export\jvm.h</p><pre class="brush:cpp;toolbar:false;" style="line-height: 1.42857;">/*
*&nbsp;java.lang.String
*/
JNIEXPORT&nbsp;jstring&nbsp;JNICALL
JVM_InternString(JNIEnv&nbsp;*env,&nbsp;jstring&nbsp;str);</pre><p style="white-space: normal;">在jvm.cpp文件中&nbsp;</p><p style="white-space: normal;">openjdk\hotspot\src\share\vm\prims\jvm.cpp</p><pre class="brush:cpp;toolbar:false" style="line-height: 1.42857;">//&nbsp;String&nbsp;support&nbsp;///////////////////////////////////////////////////////////////////////////
JVM_ENTRY(jstring,&nbsp;JVM_InternString(JNIEnv&nbsp;*env,&nbsp;jstring&nbsp;str))
JVMWrapper(&quot;JVM_InternString&quot;);
JvmtiVMObjectAllocEventCollector&nbsp;oam;
if&nbsp;(str&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NULL;
oop&nbsp;string&nbsp;=&nbsp;JNIHandles::resolve_non_null(str);
oop&nbsp;result&nbsp;=&nbsp;StringTable::intern(string,&nbsp;CHECK_NULL);
return&nbsp;(jstring)&nbsp;JNIHandles::make_local(env,&nbsp;result);
JVM_END</pre><p style="white-space: normal;">可见，里面有个 StringTable是核心。</p><p style="white-space: normal;"><strong>延伸阅读：字面量进入字符串常量池的时机（关于lazy resolve）</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;上面所说，在resolve阶段，字符串常量会被创建出来，并在字符串常量池中驻留其引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这里说的比较笼统，没错，是resolve阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 JVM规范里明确指定resolve阶段可以是lazy的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM规范里Class文件的常量池项的类型，有两种东西：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>CONSTANT_Utf8</p></li><li><p>CONSTANT_String</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;后者是String常量的类型，但它并不直接持有String常量的内容，而是只持有一个index，这个index所指定的另一个常量池项必须是一个CONSTANT_Utf8类型的常量，这里才真正持有字符串的内容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在HotSpot VM中，运行时常量池里，</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>CONSTANT_Utf8 -&gt; Symbol*（一个指针，指向一个Symbol类型的C++对象，内容是跟Class文件同样格式的UTF-8编码的字符串）</p></li><li><p>CONSTANT_String -&gt; java.lang.String（一个实际的Java对象的引用，C++类型是oop）&nbsp;</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;CONSTANT_Utf8会在类加载的过程中就全部创建出来，而CONSTANT_String则是lazy resolve的，例如说在第一次引用该项的<span style="color: rgb(192, 0, 0);">ldc指令</span>被第一次执行到的时候才会resolve。那么在尚未resolve的时候，HotSpot VM把它的类型叫做JVM_CONSTANT_UnresolvedString，内容跟Class文件里一样只是一个index；等到resolve过后这个项的常量类型就会变成最终的JVM_CONSTANT_String，而内容则变成实际的那个oop。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;看到这里想必也就明白了， 就HotSpot VM的实现来说，加载类的时候，<span style="text-decoration: underline;">那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生）。</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Idc指令是什么？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;简单地说，它用于将int、float或String型常量值从常量池中推送至栈顶</p><p>&nbsp;&nbsp;&nbsp;&nbsp;执行ldc指令就是触发这个lazy resolution动作的条件 ldc字节码在这里的执行语义是：到当前类的运行时常量池（runtime constant pool，HotSpot VM里是ConstantPool + ConstantPoolCache）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在遇到String类型常量时，resolve的过程如果发现StringTable已经有了内容匹配的java.lang.String的引用，则直接返回这个引用，反之，如果StringTable里尚未有内容匹配的String实例的引用，则会在Java堆里创建一个对应内容的String对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p><p><br/></p><h3>4、下面以一个例子来理清 运行时常量池 和 字符串常量池 的关系</h3><p>在*.java文件中有如下代码：</p><pre class="brush:java;toolbar:false">int&nbsp;a&nbsp;=&nbsp;17;
String&nbsp;b&nbsp;=&nbsp;&quot;hello&quot;;</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，17和&quot;hello&quot;会在经过javac（或者其他编译器）编译过后变为Class文件中constant_pool table的内容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们的程序运行时，也就是说JVM运行时，每个Class字节码 constant_pool table中的内容会被加载到JVM 内存中的方法区中各自Class对象的Runtime Constant Pool中。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是&quot;hello&quot;）会被加入到String Pool中（HosSpot 使用hashtable 引用方式），步骤如下：<br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>在Java Heap (Java 1.7+) 中根据&quot;hello&quot;字面量创建一个字符串对象。<br/></p></li><li><p>将字面量&quot;hello&quot;与字符串对象的引用在 hashtable 中关联起来，键 - 值 形式是：&quot;hello&quot; = 对象的引用地址。<br/></p></li></ul><p>另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？<br/></p><p>策略是这样：<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用。<br/></p><p>如此，就实现了享元模式，提高的内存利用效率。<br/></p><p><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;再举个例子深入理解，下面的代码执行结果是什么？<br/></p><pre class="brush:java;toolbar:false">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s&nbsp;=&nbsp;new&nbsp;String(&quot;1&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s2&nbsp;=&nbsp;&quot;1&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;s.intern();
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s&nbsp;==&nbsp;s2);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s3&nbsp;=&nbsp;new&nbsp;String(&quot;1&quot;)&nbsp;+&nbsp;new&nbsp;String(&quot;1&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s4&nbsp;=&nbsp;&quot;11&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;s3.intern();
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s3&nbsp;==&nbsp;s4);
}</pre><p>调换一下行序，如下，输出结果又是什么？<br/></p><pre class="brush:java;toolbar:false">public&nbsp;static&nbsp;void&nbsp;main2(String[]&nbsp;args)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;s为new出来的，同时常量池中放入&nbsp;&quot;1&quot;
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s&nbsp;=&nbsp;new&nbsp;String(&quot;1&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将s放入常量池，但是由于常量池中已经存在&quot;1&quot;，故这个方法没实际效果
&nbsp;&nbsp;&nbsp;&nbsp;s.intern();
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;s2从常量池中取出
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s2&nbsp;=&nbsp;&quot;1&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s&nbsp;==&nbsp;s2);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;s3为new出来的
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s3&nbsp;=&nbsp;new&nbsp;String(&quot;1&quot;)&nbsp;+&nbsp;new&nbsp;String(&quot;1&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将s3放入常量池
&nbsp;&nbsp;&nbsp;&nbsp;s3.intern();
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;s4从常量池中取出
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s4&nbsp;=&nbsp;&quot;11&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s3&nbsp;==&nbsp;s4);
}</pre><p>备注：针对Java 1.7和1.8</p><p>分析：<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先说两点知识：<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;1. new String(&quot;1&quot;)中的&quot;1&quot;是字面量，在class加载后【注：具体是在resolve阶段执行】就已经进入了运行时常量池；<br/></p><p>&nbsp; &nbsp; 2.&nbsp;new String(&quot;1&quot;) + new String(&quot;1&quot;) 实际上调用的是StringBuilder的append添加到一个char[]中，最后toString是调用new String(char value[], int offset, int count)返回的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;见第二个的注释：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1）s == s2输出始终为 false，因为 s2=&quot;1&quot;始终是取的 new String(&quot;1&quot;)里面的那个&quot;1&quot;，而s始终指向的不是那个&quot;1&quot;。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2）第一个 s3==s4为false，因为s3是new出来的，s4是从常量池中取的，两者不同。第二个 s3 == s4为true，因为常量池中本没有&quot;11&quot;，是调用s3.intern() 后，把&quot;11&quot;放入了常量池，此时常量池中的&quot;11&quot;和s3是同一个，再取s4=&quot;11&quot;，实际上取的是常量池里面的&quot;11&quot;，就等于s3。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;参考资料：<a href="https://www.zhihu.com/question/55994121">https://www.zhihu.com/question/55994121</a> </p><p><br/></p>