---
layout: ue
title: Java内存模型与延迟实例化-关于DCL
category: Java编程与JVM
tags: Java,延迟实例化
keywords: "Java内存模型 延迟实例化 DCL"
---

<p>（本篇文章部分翻译，最后总结）<br/></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-weight:bold;font-size:16px">What&nbsp;is&nbsp;DCL?</span></p><p><span style=";font-size:16px">什么是<span style="font-family:Times New Roman">DCL</span>？</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">The&nbsp;DCL&nbsp;idiom&nbsp;was&nbsp;designed&nbsp;to&nbsp;support&nbsp;lazy&nbsp;initialization</span><span style=";font-size:16px">（<span style="font-family:Times New Roman">DCL</span>是一种延迟实例化的编程技巧）</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;which&nbsp;occurs&nbsp;when&nbsp;a&nbsp;class&nbsp;defers&nbsp;initialization&nbsp;of&nbsp;an&nbsp;owned&nbsp;object&nbsp;until&nbsp;it&nbsp;is&nbsp;actually&nbsp;needed:</span><span style=";font-size:16px">（也就是说当一个类中的对象被用到时才会被实例化），比如<span style="font-family:Times New Roman">SomeClass</span>这个类：</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">class&nbsp;SomeClass&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;private&nbsp;Resource&nbsp;resource&nbsp;=&nbsp;null;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;public&nbsp;Resource&nbsp;getResource()&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(resource&nbsp;==&nbsp;null)</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resource&nbsp;=&nbsp;new&nbsp;Resource();</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;resource;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;}</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">}</span></p><p><span class="Apple-style-span" style="font-family: &#39;Times New Roman&#39;; font-size: 16px; line-height: 28px; ">&nbsp;</span></p><p><strong><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Why&nbsp;would&nbsp;you&nbsp;want&nbsp;to&nbsp;defer&nbsp;initialization?&nbsp;</span><span style=";font-size:16px">（为什么你想要推迟实例化？）</span></strong></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Perhaps&nbsp;creating&nbsp;a&nbsp;Resource&nbsp;is&nbsp;an&nbsp;expensive&nbsp;operation</span><span style=";font-size:16px">（也许是因为创建这个<span style="font-family:Times New Roman">Resource</span>实例是很昂贵的操作，比如内存消耗大或者费时很长等）</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;and&nbsp;users&nbsp;of&nbsp;SomeClass&nbsp;might&nbsp;not&nbsp;actually&nbsp;call&nbsp;getResource()&nbsp;in&nbsp;any&nbsp;given&nbsp;run.</span><span style=";font-size:16px">（并且，这个实例不一定会被用到）</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;In&nbsp;that&nbsp;case,&nbsp;you&nbsp;can&nbsp;avoid&nbsp;creating&nbsp;the&nbsp;Resource&nbsp;entirely.</span><span style=";font-size:16px">（所以，你没必要提前创建这个实例）</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;Regardless,&nbsp;the&nbsp;SomeClass&nbsp;object&nbsp;can&nbsp;be&nbsp;created&nbsp;faster&nbsp;if&nbsp;it&nbsp;doesn&#39;t&nbsp;have&nbsp;to&nbsp;also&nbsp;create&nbsp;a&nbsp;Resource&nbsp;at&nbsp;construction&nbsp;time</span><span style=";font-size:16px">（总之，如果你不用在<span style="font-family:Times New Roman">SomeClass</span>类构造时初始化一个<span style="font-family:Times New Roman">Resource</span>实例的话，那肯定会快一点）</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">.&nbsp;Delaying&nbsp;some&nbsp;initialization&nbsp;operations&nbsp;until&nbsp;a&nbsp;user&nbsp;actually&nbsp;needs&nbsp;their&nbsp;results&nbsp;can&nbsp;help&nbsp;programs&nbsp;start&nbsp;up&nbsp;faster</span><span style=";font-size:16px">（延迟初始化某些操作，能让程序跑得更快一些）</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">.</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">What&nbsp;if&nbsp;you&nbsp;try&nbsp;to&nbsp;use&nbsp;SomeClass&nbsp;in&nbsp;a&nbsp;multithreaded&nbsp;application?&nbsp;Then&nbsp;a&nbsp;race&nbsp;condition&nbsp;results:&nbsp;two&nbsp;threads&nbsp;could&nbsp;simultaneously&nbsp;execute&nbsp;the&nbsp;test&nbsp;to&nbsp;see&nbsp;if&nbsp;resource&nbsp;is&nbsp;null&nbsp;and,&nbsp;as&nbsp;a&nbsp;result,&nbsp;initialize&nbsp;resource&nbsp;twice.&nbsp;In&nbsp;a&nbsp;multithreaded&nbsp;environment,&nbsp;you&nbsp;should&nbsp;declare&nbsp;getResource()&nbsp;to&nbsp;be&nbsp;synchronized.</span></p><p><span style=";font-size:16px">当你在多线程环境下使用这个<span style="font-family:Times New Roman">SomeClass</span>时会怎样呢？有小概率会有两个线程在同一时间执行<span style="font-family:Times New Roman">getResource</span>方法，都去判断<span style="font-family:Times New Roman">resource</span>是否为<span style="font-family:Times New Roman">null</span>，结果实例化了两次<span style="font-family:Times New Roman">resource</span>。因此，你需要用&nbsp;<span style="font-family:Times New Roman">synchronized&nbsp;</span>关键字什么&nbsp;<span style="font-family:Times New Roman">getResource()</span>方法。</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Unfortunately,&nbsp;synchronized&nbsp;methods&nbsp;run&nbsp;much&nbsp;slower&nbsp;--&nbsp;as&nbsp;much&nbsp;as&nbsp;100&nbsp;times&nbsp;slower&nbsp;--&nbsp;than&nbsp;ordinary&nbsp;unsynchronized&nbsp;methods.&nbsp;One&nbsp;of&nbsp;the&nbsp;motivations&nbsp;for&nbsp;lazy&nbsp;initialization&nbsp;is&nbsp;efficiency,&nbsp;but&nbsp;it&nbsp;appears&nbsp;that&nbsp;in&nbsp;order&nbsp;to&nbsp;achieve&nbsp;faster&nbsp;program&nbsp;startup,&nbsp;you&nbsp;have&nbsp;to&nbsp;accept&nbsp;slower&nbsp;execution&nbsp;time&nbsp;once&nbsp;the&nbsp;program&nbsp;starts.&nbsp;That&nbsp;doesn&#39;t&nbsp;sound&nbsp;like&nbsp;a&nbsp;great&nbsp;trade-off.</span></p><p><span style=";font-size:16px">不幸的是，用<span style="font-family:Times New Roman">synchronized</span>同步过的方法比普通方法要慢至少<span style="font-family:Times New Roman">100</span>倍。因此“延迟实例化”似乎是一个更有效的方法。</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">DCL&nbsp;purports&nbsp;to&nbsp;give&nbsp;us&nbsp;the&nbsp;best&nbsp;of&nbsp;both&nbsp;worlds.&nbsp;Using&nbsp;DCL,&nbsp;the&nbsp;getResource()&nbsp;method&nbsp;would&nbsp;look&nbsp;like&nbsp;this:</span><strong><span style=";font-size:16px">（<span style="font-family:Times New Roman">DCL</span>的写法如下）</span></strong></p><p><span style=";color:rgb(0,32,96);font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">class&nbsp;SomeClass&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;private&nbsp;Resource&nbsp;resource&nbsp;=&nbsp;null;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;public&nbsp;Resource&nbsp;getResource()&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(resource&nbsp;==&nbsp;null)&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(resource&nbsp;==&nbsp;null)&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resource&nbsp;=&nbsp;new&nbsp;Resource();</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;resource;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">&nbsp;&nbsp;}</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">}</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">After&nbsp;the&nbsp;first&nbsp;call&nbsp;to&nbsp;getResource(),&nbsp;resource&nbsp;is&nbsp;already&nbsp;initialized,&nbsp;which&nbsp;avoids&nbsp;the&nbsp;synchronization&nbsp;hit&nbsp;in&nbsp;the&nbsp;most&nbsp;common&nbsp;code&nbsp;path.&nbsp;DCL&nbsp;also&nbsp;averts&nbsp;the&nbsp;race&nbsp;condition&nbsp;by&nbsp;checking&nbsp;resource&nbsp;a&nbsp;second&nbsp;time&nbsp;inside&nbsp;the&nbsp;synchronized&nbsp;block;&nbsp;that&nbsp;ensures&nbsp;that&nbsp;only&nbsp;one&nbsp;thread&nbsp;will&nbsp;try&nbsp;to&nbsp;initialize&nbsp;resource.&nbsp;DCL&nbsp;seems&nbsp;like&nbsp;a&nbsp;clever&nbsp;optimization&nbsp;--&nbsp;but&nbsp;it&nbsp;doesn&#39;t&nbsp;work.</span><span style=";font-size:16px">（只要在第一次调用</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">getResource()</span><span style=";font-size:16px">方法时，<span style="font-family:Times New Roman">resource</span>就被初始化了，以后再调用就不会再执行里面的<span style="font-family:Times New Roman">synchronized</span>语句，因此，这貌似是一种很聪明的做法，但是实际上，这种写法并没有达到效果！）</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">-------------导读结束，以下部分翻译，关键之处我有注释<span style="font-family:Times New Roman">-----------</span></span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style="font-family: &#39;Times New Roman&#39;; font-weight: bold; font-size: 18px; ">Meet&nbsp;the&nbsp;Java&nbsp;Memory&nbsp;Model</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">More&nbsp;accurately,&nbsp;DCL&nbsp;is&nbsp;not&nbsp;guaranteed&nbsp;to&nbsp;work.&nbsp;To&nbsp;understand&nbsp;why,&nbsp;we&nbsp;need&nbsp;to&nbsp;look&nbsp;at&nbsp;the&nbsp;relationship&nbsp;between&nbsp;the&nbsp;JVM&nbsp;and&nbsp;the&nbsp;computer&nbsp;environment&nbsp;on&nbsp;which&nbsp;it&nbsp;runs.&nbsp;In&nbsp;particular,&nbsp;we&nbsp;need&nbsp;to&nbsp;look&nbsp;at&nbsp;the&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">Java&nbsp;Memory&nbsp;Model&nbsp;(JMM),&nbsp;defined&nbsp;in&nbsp;Chapter&nbsp;17&nbsp;of&nbsp;the&nbsp;Java&nbsp;Language&nbsp;Specification</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;by&nbsp;Bill&nbsp;Joy,&nbsp;Guy&nbsp;Steele,&nbsp;James&nbsp;Gosling,&nbsp;and&nbsp;Gilad&nbsp;Bracha&nbsp;(Addison-Wesley,&nbsp;2000),&nbsp;which&nbsp;details&nbsp;how&nbsp;Java&nbsp;handles&nbsp;the&nbsp;interaction&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">between&nbsp;threads&nbsp;and&nbsp;memory</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">.</span></p><p><span style=";font-size:16px">为了明白<span style="font-family:Times New Roman">DCL</span>方法为什么有问题，我们来看看<span style="font-family:Times New Roman">JVM</span>和运行环境的关系，来看看<span style="font-family:Times New Roman">Java</span>内存模型。</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Unlike&nbsp;most&nbsp;other&nbsp;languages,&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">Java&nbsp;defines&nbsp;its&nbsp;relationship&nbsp;to&nbsp;the&nbsp;underlying&nbsp;hardware</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;through&nbsp;a&nbsp;formal&nbsp;memory&nbsp;model&nbsp;that&nbsp;is&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">expected&nbsp;to&nbsp;hold&nbsp;on&nbsp;all&nbsp;Java&nbsp;platforms</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;</span><span style=";font-size:16px">【不像其他大多数语言，<span style="font-family:Times New Roman">Java</span>平台定义了针对底层硬件的内存模型以支持跨平台特性】</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">enabling&nbsp;Java&#39;s&nbsp;promise&nbsp;of&nbsp;&quot;Write&nbsp;Once,&nbsp;Run&nbsp;Anywhere.&quot;&nbsp;By&nbsp;comparison,&nbsp;other&nbsp;languages&nbsp;like&nbsp;C&nbsp;and&nbsp;C++&nbsp;lack&nbsp;a&nbsp;formal&nbsp;memory&nbsp;model;&nbsp;in&nbsp;such&nbsp;languages,&nbsp;programs&nbsp;inherit&nbsp;the&nbsp;memory&nbsp;model&nbsp;of&nbsp;the&nbsp;hardware&nbsp;platform&nbsp;on&nbsp;which&nbsp;the&nbsp;program&nbsp;runs.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">When&nbsp;running&nbsp;in&nbsp;a&nbsp;synchronous&nbsp;(single-threaded)&nbsp;environment,&nbsp;a&nbsp;program&#39;s&nbsp;interaction&nbsp;with&nbsp;memory&nbsp;is&nbsp;quite&nbsp;simple,&nbsp;or&nbsp;at&nbsp;least&nbsp;it&nbsp;appears&nbsp;so.&nbsp;Programs&nbsp;store&nbsp;items&nbsp;into&nbsp;memory&nbsp;locations&nbsp;and&nbsp;expect&nbsp;that&nbsp;they&nbsp;will&nbsp;still&nbsp;be&nbsp;there&nbsp;the&nbsp;next&nbsp;time&nbsp;those&nbsp;memory&nbsp;locations&nbsp;are&nbsp;examined.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Actually,&nbsp;the&nbsp;truth&nbsp;is&nbsp;quite&nbsp;different,&nbsp;but&nbsp;a&nbsp;complicated&nbsp;illusion&nbsp;maintained&nbsp;by&nbsp;the&nbsp;compiler,&nbsp;the&nbsp;JVM,&nbsp;and&nbsp;the&nbsp;hardware&nbsp;hides&nbsp;it&nbsp;from&nbsp;us.&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">Though&nbsp;we&nbsp;think&nbsp;of&nbsp;programs&nbsp;as&nbsp;executing&nbsp;sequentially&nbsp;--&nbsp;in&nbsp;the&nbsp;order&nbsp;specified&nbsp;by&nbsp;the&nbsp;program&nbsp;code&nbsp;--&nbsp;that&nbsp;doesn&#39;t&nbsp;always&nbsp;happen.&nbsp;Compilers,&nbsp;processors,&nbsp;and&nbsp;caches&nbsp;are&nbsp;free&nbsp;to&nbsp;take&nbsp;all&nbsp;sorts&nbsp;of&nbsp;liberties&nbsp;with&nbsp;our&nbsp;programs&nbsp;and&nbsp;data,&nbsp;as&nbsp;long&nbsp;as&nbsp;they&nbsp;don&#39;t&nbsp;affect&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;computation</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">.</span><span style=";font-size:16px">【我们程序的执行顺序，与编译器、处理器、缓存的内部处理顺序，很可能是不一致的】</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;For&nbsp;example,&nbsp;compilers&nbsp;can&nbsp;generate&nbsp;instructions&nbsp;in&nbsp;a&nbsp;different&nbsp;order&nbsp;from&nbsp;the&nbsp;obvious&nbsp;interpretation&nbsp;the&nbsp;program&nbsp;suggests&nbsp;and&nbsp;store&nbsp;variables&nbsp;in&nbsp;registers&nbsp;instead&nbsp;of&nbsp;memory;&nbsp;processors&nbsp;may&nbsp;execute&nbsp;instructions&nbsp;in&nbsp;parallel&nbsp;or&nbsp;out&nbsp;of&nbsp;order;&nbsp;and&nbsp;caches&nbsp;may&nbsp;vary&nbsp;the&nbsp;order&nbsp;in&nbsp;which&nbsp;writes&nbsp;commit&nbsp;to&nbsp;main&nbsp;memory.&nbsp;The&nbsp;JMM&nbsp;says&nbsp;that&nbsp;all&nbsp;of&nbsp;these&nbsp;various&nbsp;reorderings&nbsp;and&nbsp;optimizations&nbsp;are&nbsp;acceptable,&nbsp;so&nbsp;long&nbsp;as&nbsp;the&nbsp;environment&nbsp;maintains&nbsp;as-if-serial&nbsp;semantics&nbsp;--&nbsp;that&nbsp;is,&nbsp;so&nbsp;long&nbsp;as&nbsp;you&nbsp;achieve&nbsp;the&nbsp;same&nbsp;result&nbsp;as&nbsp;you&nbsp;would&nbsp;have&nbsp;if&nbsp;the&nbsp;instructions&nbsp;were&nbsp;executed&nbsp;in&nbsp;a&nbsp;strictly&nbsp;sequential&nbsp;environment.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Compilers,&nbsp;processors,&nbsp;and&nbsp;caches&nbsp;rearrange&nbsp;the&nbsp;sequence&nbsp;of&nbsp;program&nbsp;operations&nbsp;in&nbsp;order&nbsp;to&nbsp;achieve&nbsp;higher&nbsp;performance.&nbsp;In&nbsp;recent&nbsp;years,&nbsp;we&#39;ve&nbsp;seen&nbsp;tremendous&nbsp;improvements&nbsp;in&nbsp;computing&nbsp;performance.&nbsp;While&nbsp;increased&nbsp;processor&nbsp;clock&nbsp;rates&nbsp;have&nbsp;contributed&nbsp;substantially&nbsp;to&nbsp;higher&nbsp;performance,&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">increased&nbsp;parallelism</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;(in&nbsp;the&nbsp;form&nbsp;of&nbsp;pipelined&nbsp;and&nbsp;superscalar&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">execution&nbsp;units</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">,&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">dynamic&nbsp;instruction&nbsp;scheduling&nbsp;and&nbsp;speculative&nbsp;execution,</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;and&nbsp;sophisticated&nbsp;multilevel&nbsp;memory&nbsp;caches)&nbsp;has&nbsp;also&nbsp;been&nbsp;a&nbsp;major&nbsp;contributor.&nbsp;At&nbsp;the&nbsp;same&nbsp;time,&nbsp;the&nbsp;task&nbsp;of&nbsp;writing&nbsp;compilers&nbsp;has&nbsp;grown&nbsp;much&nbsp;more&nbsp;complicated,&nbsp;as&nbsp;the&nbsp;compiler&nbsp;must&nbsp;shield&nbsp;the&nbsp;programmer&nbsp;from&nbsp;these&nbsp;complexities.</span><span style=";font-size:16px">【随着<span style="font-family:Times New Roman">CPU</span>并行处理、多内存缓存等技术出现，使得编译器也更为复杂，因为编译器要屏蔽底层硬件的复杂性】</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">When&nbsp;writing&nbsp;single-threaded&nbsp;programs,&nbsp;you&nbsp;cannot&nbsp;see&nbsp;the&nbsp;effects&nbsp;of&nbsp;these&nbsp;various&nbsp;instruction&nbsp;or&nbsp;memory&nbsp;operation&nbsp;reorderings.</span><span style=";font-size:16px">【在单线程下面，你是看不出来指令和内存操作的变化所带来的影响的，但是在多线程下面情况就不同了】</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;However,&nbsp;with&nbsp;multithreaded&nbsp;programs,&nbsp;the&nbsp;situation&nbsp;is&nbsp;quite&nbsp;different&nbsp;--&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">one&nbsp;thread&nbsp;can&nbsp;read&nbsp;memory&nbsp;locations&nbsp;that&nbsp;another&nbsp;thread&nbsp;has&nbsp;written.&nbsp;If&nbsp;thread&nbsp;A&nbsp;modifies&nbsp;some&nbsp;variables&nbsp;in&nbsp;a&nbsp;certain&nbsp;order,&nbsp;in&nbsp;the&nbsp;absence&nbsp;of&nbsp;synchronization,&nbsp;thread&nbsp;B&nbsp;may&nbsp;not&nbsp;see&nbsp;them&nbsp;in&nbsp;the&nbsp;same&nbsp;order&nbsp;--&nbsp;or&nbsp;may&nbsp;not&nbsp;see&nbsp;them&nbsp;at&nbsp;all,&nbsp;for&nbsp;that&nbsp;matter.&nbsp;That&nbsp;could&nbsp;result&nbsp;because&nbsp;the&nbsp;compiler&nbsp;reordered&nbsp;the&nbsp;instructions&nbsp;or&nbsp;temporarily&nbsp;stored&nbsp;a&nbsp;variable&nbsp;in&nbsp;a&nbsp;register&nbsp;and&nbsp;wrote&nbsp;it&nbsp;out&nbsp;to&nbsp;memory&nbsp;later;&nbsp;or&nbsp;because&nbsp;the&nbsp;processor&nbsp;executed&nbsp;the&nbsp;instructions&nbsp;in&nbsp;parallel&nbsp;or&nbsp;in&nbsp;a&nbsp;different&nbsp;order&nbsp;than&nbsp;the&nbsp;compiler&nbsp;specified;&nbsp;or&nbsp;because&nbsp;the&nbsp;instructions&nbsp;were&nbsp;in&nbsp;different&nbsp;regions&nbsp;of&nbsp;memory,&nbsp;and&nbsp;the&nbsp;cache&nbsp;updated&nbsp;the&nbsp;corresponding&nbsp;main&nbsp;memory&nbsp;locations&nbsp;in&nbsp;a&nbsp;different&nbsp;order&nbsp;than&nbsp;the&nbsp;one&nbsp;in&nbsp;which&nbsp;they&nbsp;were&nbsp;written.&nbsp;Whatever&nbsp;the&nbsp;circumstances,&nbsp;multithreaded&nbsp;programs&nbsp;are&nbsp;inherently&nbsp;less&nbsp;predictable,&nbsp;unless&nbsp;you&nbsp;explicitly&nbsp;ensure&nbsp;that&nbsp;threads&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;memory&nbsp;by&nbsp;using&nbsp;synchronization.</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style="font-family: &#39;Times New Roman&#39;; font-weight: bold; font-size: 20px; ">What&nbsp;does&nbsp;synchronized&nbsp;really&nbsp;mean?</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Java&nbsp;treats&nbsp;each&nbsp;thread&nbsp;as&nbsp;if&nbsp;it&nbsp;runs&nbsp;on&nbsp;its&nbsp;own&nbsp;processor&nbsp;with&nbsp;its&nbsp;own&nbsp;local&nbsp;memory,&nbsp;each&nbsp;talking&nbsp;to&nbsp;and&nbsp;synchronizing&nbsp;with&nbsp;a&nbsp;shared&nbsp;main&nbsp;memory.&nbsp;Even&nbsp;on&nbsp;a&nbsp;single-processor&nbsp;system,&nbsp;that&nbsp;model&nbsp;makes&nbsp;sense&nbsp;because&nbsp;of&nbsp;the&nbsp;effects&nbsp;of&nbsp;memory&nbsp;caches&nbsp;and&nbsp;the&nbsp;use&nbsp;of&nbsp;processor&nbsp;registers&nbsp;to&nbsp;store&nbsp;variables.&nbsp;When&nbsp;a&nbsp;thread&nbsp;modifies&nbsp;a&nbsp;location&nbsp;in&nbsp;its&nbsp;local&nbsp;memory,&nbsp;that&nbsp;modification&nbsp;should&nbsp;eventually&nbsp;show&nbsp;up&nbsp;in&nbsp;the&nbsp;main&nbsp;memory&nbsp;as&nbsp;well,&nbsp;and&nbsp;the&nbsp;JMM&nbsp;defines&nbsp;the&nbsp;rules&nbsp;for&nbsp;when&nbsp;the&nbsp;JVM&nbsp;must&nbsp;transfer&nbsp;data&nbsp;between&nbsp;local&nbsp;and&nbsp;main&nbsp;memory.&nbsp;The&nbsp;Java&nbsp;architects&nbsp;realized&nbsp;that&nbsp;an&nbsp;overly&nbsp;restrictive&nbsp;memory&nbsp;model&nbsp;would&nbsp;seriously&nbsp;undermine&nbsp;program&nbsp;performance.&nbsp;They&nbsp;attempted&nbsp;to&nbsp;craft&nbsp;a&nbsp;memory&nbsp;model&nbsp;that&nbsp;would&nbsp;allow&nbsp;programs&nbsp;to&nbsp;perform&nbsp;well&nbsp;on&nbsp;modern&nbsp;computer&nbsp;hardware&nbsp;while&nbsp;still&nbsp;providing&nbsp;guarantees&nbsp;that&nbsp;would&nbsp;allow&nbsp;threads&nbsp;to&nbsp;interact&nbsp;in&nbsp;predictable&nbsp;ways.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Java&#39;s&nbsp;primary&nbsp;tool&nbsp;for&nbsp;rendering&nbsp;interactions&nbsp;between&nbsp;threads&nbsp;predictably&nbsp;is&nbsp;the&nbsp;synchronized&nbsp;keyword.&nbsp;Many&nbsp;programmers&nbsp;think&nbsp;of&nbsp;synchronized&nbsp;strictly&nbsp;in&nbsp;terms&nbsp;of&nbsp;enforcing&nbsp;a&nbsp;mutual&nbsp;exclusion&nbsp;semaphore&nbsp;(mutex)&nbsp;to&nbsp;prevent&nbsp;execution&nbsp;of&nbsp;critical&nbsp;sections&nbsp;by&nbsp;more&nbsp;than&nbsp;one&nbsp;thread&nbsp;at&nbsp;a&nbsp;time.&nbsp;Unfortunately,&nbsp;that&nbsp;intuition&nbsp;does&nbsp;not&nbsp;fully&nbsp;describe&nbsp;what&nbsp;synchronized&nbsp;means.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">The&nbsp;semantics&nbsp;of&nbsp;synchronized&nbsp;do&nbsp;indeed&nbsp;include&nbsp;mutual&nbsp;exclusion&nbsp;of&nbsp;execution&nbsp;based&nbsp;on&nbsp;the&nbsp;status&nbsp;of&nbsp;a&nbsp;semaphore,&nbsp;but&nbsp;they&nbsp;also&nbsp;include&nbsp;rules&nbsp;about&nbsp;the&nbsp;synchronizing&nbsp;thread&#39;s&nbsp;interaction&nbsp;with&nbsp;main&nbsp;memory.&nbsp;In&nbsp;particular,&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">the&nbsp;acquisition&nbsp;or&nbsp;release&nbsp;of&nbsp;a&nbsp;lock&nbsp;triggers&nbsp;a&nbsp;memory&nbsp;barrier&nbsp;--&nbsp;a&nbsp;forced&nbsp;synchronization&nbsp;between&nbsp;the&nbsp;thread&#39;s&nbsp;local&nbsp;memory&nbsp;and&nbsp;main&nbsp;memory.&nbsp;(Some&nbsp;processors&nbsp;--&nbsp;like&nbsp;the&nbsp;Alpha&nbsp;--&nbsp;have&nbsp;explicit&nbsp;machine&nbsp;instructions&nbsp;for&nbsp;performing&nbsp;memory&nbsp;barriers.)&nbsp;When&nbsp;a&nbsp;thread&nbsp;exits&nbsp;a&nbsp;synchronized&nbsp;block,&nbsp;it&nbsp;performs&nbsp;a&nbsp;write&nbsp;barrier&nbsp;--&nbsp;it&nbsp;must&nbsp;flush&nbsp;out&nbsp;any&nbsp;variables&nbsp;modified&nbsp;in&nbsp;that&nbsp;block&nbsp;to&nbsp;main&nbsp;memory&nbsp;before&nbsp;releasing&nbsp;the&nbsp;lock</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">.&nbsp;Similarly,&nbsp;when&nbsp;entering&nbsp;a&nbsp;synchronized&nbsp;block,&nbsp;it&nbsp;performs&nbsp;a&nbsp;read&nbsp;barrier&nbsp;--&nbsp;it&nbsp;is&nbsp;as&nbsp;if&nbsp;the&nbsp;local&nbsp;memory&nbsp;has&nbsp;been&nbsp;invalidated,&nbsp;and&nbsp;it&nbsp;must&nbsp;fetch&nbsp;any&nbsp;variables&nbsp;that&nbsp;will&nbsp;be&nbsp;referenced&nbsp;in&nbsp;the&nbsp;block&nbsp;from&nbsp;main&nbsp;memory.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">The&nbsp;proper&nbsp;use&nbsp;of&nbsp;synchronization&nbsp;guarantees&nbsp;that&nbsp;one&nbsp;thread&nbsp;will&nbsp;see&nbsp;the&nbsp;effects&nbsp;of&nbsp;another&nbsp;in&nbsp;a&nbsp;predictable&nbsp;manner.&nbsp;Only&nbsp;when&nbsp;threads&nbsp;A&nbsp;and&nbsp;B&nbsp;synchronize&nbsp;on&nbsp;the&nbsp;same&nbsp;object&nbsp;will&nbsp;the&nbsp;JMM&nbsp;guarantee&nbsp;that&nbsp;thread&nbsp;B&nbsp;sees&nbsp;the&nbsp;changes&nbsp;made&nbsp;by&nbsp;thread&nbsp;A,&nbsp;and&nbsp;that&nbsp;changes&nbsp;made&nbsp;by&nbsp;thread&nbsp;A&nbsp;inside&nbsp;the&nbsp;synchronized&nbsp;block&nbsp;appear&nbsp;atomically&nbsp;to&nbsp;thread&nbsp;B&nbsp;(either&nbsp;the&nbsp;whole&nbsp;block&nbsp;executes&nbsp;or&nbsp;none&nbsp;of&nbsp;it&nbsp;does.)&nbsp;Furthermore,&nbsp;the&nbsp;JMM&nbsp;ensures&nbsp;that&nbsp;synchronized&nbsp;blocks&nbsp;that&nbsp;synchronize&nbsp;on&nbsp;the&nbsp;same&nbsp;object&nbsp;will&nbsp;appear&nbsp;to&nbsp;execute&nbsp;in&nbsp;the&nbsp;same&nbsp;order&nbsp;as&nbsp;they&nbsp;do&nbsp;in&nbsp;the&nbsp;program.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style="font-family: &#39;Times New Roman&#39;; font-weight: bold; font-size: 20px; ">So&nbsp;what&#39;s&nbsp;broken&nbsp;about&nbsp;DCL?</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">DCL&nbsp;relies&nbsp;on&nbsp;an&nbsp;unsynchronized&nbsp;use&nbsp;of&nbsp;the&nbsp;resource&nbsp;field.&nbsp;That&nbsp;appears&nbsp;to&nbsp;be&nbsp;harmless,&nbsp;but&nbsp;it&nbsp;is&nbsp;not.&nbsp;To&nbsp;see&nbsp;why,&nbsp;imagine&nbsp;that&nbsp;thread&nbsp;A&nbsp;is&nbsp;inside&nbsp;the&nbsp;synchronized&nbsp;block,&nbsp;executing&nbsp;the&nbsp;statement&nbsp;resource&nbsp;=&nbsp;new&nbsp;Resource();&nbsp;while&nbsp;thread&nbsp;B&nbsp;is&nbsp;just&nbsp;entering&nbsp;getResource().&nbsp;Consider&nbsp;the&nbsp;effect&nbsp;on&nbsp;memory&nbsp;of&nbsp;this&nbsp;initialization.&nbsp;Memory&nbsp;for&nbsp;the&nbsp;new&nbsp;Resource&nbsp;object&nbsp;will&nbsp;be&nbsp;allocated;&nbsp;the&nbsp;constructor&nbsp;for&nbsp;Resource&nbsp;will&nbsp;be&nbsp;called,&nbsp;initializing&nbsp;the&nbsp;member&nbsp;fields&nbsp;of&nbsp;the&nbsp;new&nbsp;object;&nbsp;and&nbsp;the&nbsp;field&nbsp;resource&nbsp;of&nbsp;SomeClass&nbsp;will&nbsp;be&nbsp;assigned&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;newly&nbsp;created&nbsp;object.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">However,&nbsp;since&nbsp;thread&nbsp;B&nbsp;is&nbsp;not&nbsp;executing&nbsp;inside&nbsp;a&nbsp;synchronized&nbsp;block,&nbsp;it&nbsp;may&nbsp;see&nbsp;these&nbsp;memory&nbsp;operations&nbsp;in&nbsp;a&nbsp;different&nbsp;order&nbsp;than&nbsp;the&nbsp;one&nbsp;thread&nbsp;A&nbsp;executes.&nbsp;It&nbsp;could&nbsp;be&nbsp;the&nbsp;case&nbsp;that&nbsp;B&nbsp;sees&nbsp;these&nbsp;events&nbsp;in&nbsp;the&nbsp;following&nbsp;order&nbsp;(and&nbsp;the&nbsp;compiler&nbsp;is&nbsp;also&nbsp;free&nbsp;to&nbsp;reorder&nbsp;the&nbsp;instructions&nbsp;like&nbsp;this):&nbsp;allocate&nbsp;memory,&nbsp;assign&nbsp;reference&nbsp;to&nbsp;resource,&nbsp;call&nbsp;constructor.&nbsp;Suppose&nbsp;thread&nbsp;B&nbsp;comes&nbsp;along&nbsp;after&nbsp;the&nbsp;memory&nbsp;has&nbsp;been&nbsp;allocated&nbsp;and&nbsp;the&nbsp;resource&nbsp;field&nbsp;is&nbsp;set,&nbsp;but&nbsp;before&nbsp;the&nbsp;constructor&nbsp;is&nbsp;called.&nbsp;It&nbsp;sees&nbsp;that&nbsp;resource&nbsp;is&nbsp;not&nbsp;null,&nbsp;skips&nbsp;the&nbsp;synchronized&nbsp;block,&nbsp;and&nbsp;returns&nbsp;a&nbsp;reference&nbsp;to&nbsp;a&nbsp;partially&nbsp;constructed&nbsp;Resource!&nbsp;Needless&nbsp;to&nbsp;say,&nbsp;the&nbsp;result&nbsp;is&nbsp;neither&nbsp;expected&nbsp;nor&nbsp;desired.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">When&nbsp;presented&nbsp;with&nbsp;this&nbsp;example,&nbsp;many&nbsp;people&nbsp;are&nbsp;skeptical&nbsp;at&nbsp;first.&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">Many&nbsp;highly&nbsp;intelligent&nbsp;programmers&nbsp;have&nbsp;tried&nbsp;to&nbsp;fix&nbsp;DCL&nbsp;so&nbsp;that&nbsp;it&nbsp;does&nbsp;work,&nbsp;but&nbsp;none&nbsp;of&nbsp;these&nbsp;supposedly&nbsp;fixed&nbsp;versions&nbsp;work&nbsp;either.&nbsp;It&nbsp;should&nbsp;be&nbsp;noted&nbsp;that&nbsp;DCL&nbsp;might,&nbsp;in&nbsp;fact,&nbsp;work&nbsp;on&nbsp;some&nbsp;versions&nbsp;of&nbsp;some&nbsp;JVMs&nbsp;--&nbsp;as&nbsp;few&nbsp;JVMs&nbsp;actually&nbsp;implement&nbsp;the&nbsp;JMM&nbsp;properly.</span><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;However,&nbsp;you&nbsp;don&#39;t&nbsp;want&nbsp;the&nbsp;correctness&nbsp;of&nbsp;your&nbsp;programs&nbsp;to&nbsp;rely&nbsp;on&nbsp;implementation&nbsp;details&nbsp;--&nbsp;especially&nbsp;errors&nbsp;--&nbsp;specific&nbsp;to&nbsp;the&nbsp;particular&nbsp;version&nbsp;of&nbsp;the&nbsp;particular&nbsp;JVM&nbsp;you&nbsp;use.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Other&nbsp;concurrency&nbsp;hazards&nbsp;are&nbsp;embedded&nbsp;in&nbsp;DCL&nbsp;--&nbsp;and&nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;color:rgb(0,32,96);font-size:16px">in&nbsp;any&nbsp;unsynchronized&nbsp;reference&nbsp;to&nbsp;memory&nbsp;written&nbsp;by&nbsp;another&nbsp;thread,&nbsp;even&nbsp;harmless-looking&nbsp;reads.&nbsp;Suppose&nbsp;thread&nbsp;A&nbsp;has&nbsp;completed&nbsp;initializing&nbsp;the&nbsp;Resource&nbsp;and&nbsp;exits&nbsp;the&nbsp;synchronized&nbsp;block&nbsp;as&nbsp;thread&nbsp;B&nbsp;enters&nbsp;getResource().&nbsp;Now&nbsp;the&nbsp;Resource&nbsp;is&nbsp;fully&nbsp;initialized,&nbsp;and&nbsp;thread&nbsp;A&nbsp;flushes&nbsp;its&nbsp;local&nbsp;memory&nbsp;out&nbsp;to&nbsp;main&nbsp;memory.&nbsp;The&nbsp;resource&#39;s&nbsp;fields&nbsp;may&nbsp;reference&nbsp;other&nbsp;objects&nbsp;stored&nbsp;in&nbsp;memory&nbsp;through&nbsp;its&nbsp;member&nbsp;fields,&nbsp;which&nbsp;will&nbsp;also&nbsp;be&nbsp;flushed&nbsp;out.&nbsp;While&nbsp;thread&nbsp;B&nbsp;may&nbsp;see&nbsp;a&nbsp;valid&nbsp;reference&nbsp;to&nbsp;the&nbsp;newly&nbsp;created&nbsp;Resource,&nbsp;because&nbsp;it&nbsp;didn&#39;t&nbsp;perform&nbsp;a&nbsp;read&nbsp;barrier,&nbsp;it&nbsp;could&nbsp;still&nbsp;see&nbsp;stale&nbsp;values&nbsp;of&nbsp;resource&#39;s&nbsp;member&nbsp;fields.</span><span style=";color:rgb(0,32,96);font-size:16px">【在<span style="font-family:Times New Roman">Java</span>内存中，<span style="font-family:Times New Roman">resource</span>对象并没有实时同步，多线程操作的时间差会影响到程序的结果】</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style="font-family: &#39;Times New Roman&#39;; font-weight: bold; font-size: 20px; ">Volatile&nbsp;doesn&#39;t&nbsp;mean&nbsp;what&nbsp;you&nbsp;think,&nbsp;either</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">A&nbsp;commonly&nbsp;suggested&nbsp;nonfix&nbsp;is&nbsp;to&nbsp;declare&nbsp;the&nbsp;resource&nbsp;field&nbsp;of&nbsp;SomeClass&nbsp;as&nbsp;volatile.&nbsp;However,&nbsp;while&nbsp;the&nbsp;JMM&nbsp;prevents&nbsp;writes&nbsp;to&nbsp;volatile&nbsp;variables&nbsp;from&nbsp;being&nbsp;reordered&nbsp;with&nbsp;respect&nbsp;to&nbsp;one&nbsp;another&nbsp;and&nbsp;ensures&nbsp;that&nbsp;they&nbsp;are&nbsp;flushed&nbsp;to&nbsp;main&nbsp;memory&nbsp;immediately,&nbsp;it&nbsp;still&nbsp;permits&nbsp;reads&nbsp;and&nbsp;writes&nbsp;of&nbsp;volatile&nbsp;variables&nbsp;to&nbsp;be&nbsp;reordered&nbsp;with&nbsp;respect&nbsp;to&nbsp;nonvolatile&nbsp;reads&nbsp;and&nbsp;writes.&nbsp;That&nbsp;means&nbsp;--&nbsp;unless&nbsp;all&nbsp;Resource&nbsp;fields&nbsp;are&nbsp;volatile&nbsp;as&nbsp;well&nbsp;--&nbsp;thread&nbsp;B&nbsp;can&nbsp;still&nbsp;perceive&nbsp;the&nbsp;constructor&#39;s&nbsp;effect&nbsp;as&nbsp;happening&nbsp;after&nbsp;resource&nbsp;is&nbsp;set&nbsp;to&nbsp;reference&nbsp;the&nbsp;newly&nbsp;created&nbsp;Resource.</span><span style=";font-size:16px">【注：在<span style="font-family:Times New Roman">JDK4</span>和更早以前，<span style="font-family:Times New Roman">volatile</span>仍然是无效的，直到<span style="font-family:Times New Roman">JDK5</span>以后，使用<span style="font-family:Times New Roman">volatile</span>可以解决该问题】</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style="font-family: &#39;Times New Roman&#39;; font-weight: bold; font-size: 20px; ">Alternatives&nbsp;to&nbsp;DCL</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">The&nbsp;most&nbsp;effective&nbsp;way&nbsp;to&nbsp;fix&nbsp;the&nbsp;DCL&nbsp;idiom&nbsp;is&nbsp;to&nbsp;avoid&nbsp;it.&nbsp;The&nbsp;simplest&nbsp;way&nbsp;to&nbsp;avoid&nbsp;it,&nbsp;of&nbsp;course,&nbsp;is&nbsp;to&nbsp;use&nbsp;synchronization.&nbsp;Whenever&nbsp;a&nbsp;variable&nbsp;written&nbsp;by&nbsp;one&nbsp;thread&nbsp;is&nbsp;being&nbsp;read&nbsp;by&nbsp;another,&nbsp;you&nbsp;should&nbsp;use&nbsp;synchronization&nbsp;to&nbsp;guarantee&nbsp;that&nbsp;modifications&nbsp;are&nbsp;visible&nbsp;to&nbsp;other&nbsp;threads&nbsp;in&nbsp;a&nbsp;predictable&nbsp;manner.</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">Another&nbsp;option&nbsp;for&nbsp;avoiding&nbsp;the&nbsp;problems&nbsp;with&nbsp;DCL&nbsp;is&nbsp;to&nbsp;drop&nbsp;lazy&nbsp;initialization&nbsp;and&nbsp;instead&nbsp;use&nbsp;eager&nbsp;initialization.&nbsp;Rather&nbsp;than&nbsp;delay&nbsp;initialization&nbsp;of&nbsp;resource&nbsp;until&nbsp;it&nbsp;is&nbsp;first&nbsp;used,&nbsp;initialize&nbsp;it&nbsp;at&nbsp;construction.&nbsp;The&nbsp;class&nbsp;loader,&nbsp;which&nbsp;synchronizes&nbsp;on&nbsp;the&nbsp;classes&#39;&nbsp;Class&nbsp;object,&nbsp;executes&nbsp;static&nbsp;initializer&nbsp;blocks&nbsp;at&nbsp;class&nbsp;initialization&nbsp;time.&nbsp;That&nbsp;means&nbsp;that&nbsp;the&nbsp;effect&nbsp;of&nbsp;static&nbsp;initializers&nbsp;is&nbsp;automatically&nbsp;visible&nbsp;to&nbsp;all&nbsp;threads&nbsp;as&nbsp;soon&nbsp;as&nbsp;the&nbsp;class&nbsp;loads.</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">One&nbsp;special&nbsp;case&nbsp;of&nbsp;lazy&nbsp;initialization&nbsp;that&nbsp;does&nbsp;work&nbsp;as&nbsp;expected&nbsp;without&nbsp;synchronization&nbsp;is&nbsp;the&nbsp;static&nbsp;singleton.&nbsp;When&nbsp;the&nbsp;initialized&nbsp;object&nbsp;is&nbsp;a&nbsp;static&nbsp;field&nbsp;of&nbsp;a&nbsp;class&nbsp;with&nbsp;no&nbsp;other&nbsp;methods&nbsp;or&nbsp;fields,&nbsp;the&nbsp;JVM&nbsp;effectively&nbsp;performs&nbsp;lazy&nbsp;initialization&nbsp;automatically.&nbsp;In&nbsp;the&nbsp;following&nbsp;example,&nbsp;the&nbsp;Resource&nbsp;will&nbsp;not&nbsp;be&nbsp;constructed&nbsp;until&nbsp;the&nbsp;field&nbsp;resource&nbsp;is&nbsp;first&nbsp;referenced&nbsp;by&nbsp;another&nbsp;class,&nbsp;and&nbsp;any&nbsp;memory&nbsp;writes&nbsp;that&nbsp;result&nbsp;from&nbsp;resource&#39;s&nbsp;initialization&nbsp;are&nbsp;automatically&nbsp;visible&nbsp;to&nbsp;all&nbsp;threads:</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">class&nbsp;MySingleton&nbsp;{</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;&nbsp;public&nbsp;static&nbsp;Resource&nbsp;resource&nbsp;=&nbsp;new&nbsp;Resource();</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">}</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">The&nbsp;initialization&nbsp;will&nbsp;be&nbsp;performed&nbsp;when&nbsp;the&nbsp;JVM&nbsp;initializes&nbsp;the&nbsp;class.&nbsp;Since&nbsp;MySingleton&nbsp;has&nbsp;no&nbsp;other&nbsp;fields&nbsp;or&nbsp;methods,&nbsp;class&nbsp;initialization&nbsp;occurs&nbsp;when&nbsp;the&nbsp;resource&nbsp;field&nbsp;is&nbsp;first&nbsp;referenced.</span><span style=";font-size:16px">【使用“内部类”可以达到目的，<span style="font-family:Times New Roman">JVM</span>的机制保障它能有效避免多线程环境下不正确的初始化问题】</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;</span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">DCL&nbsp;also&nbsp;works&nbsp;with&nbsp;32-bit&nbsp;primitive&nbsp;values.&nbsp;If&nbsp;the&nbsp;resource&nbsp;field&nbsp;in&nbsp;SomeClass&nbsp;were&nbsp;an&nbsp;integer&nbsp;(but&nbsp;not&nbsp;a&nbsp;long&nbsp;or&nbsp;a&nbsp;double),&nbsp;then&nbsp;SomeClass&nbsp;would&nbsp;behave&nbsp;as&nbsp;expected.&nbsp;However,&nbsp;you&nbsp;cannot&nbsp;use&nbsp;this&nbsp;behavior&nbsp;to&nbsp;fix&nbsp;the&nbsp;problems&nbsp;with&nbsp;DCL&nbsp;when&nbsp;you&nbsp;want&nbsp;to&nbsp;lazily&nbsp;initialize&nbsp;an&nbsp;object&nbsp;reference&nbsp;or&nbsp;more&nbsp;than&nbsp;one&nbsp;primitive&nbsp;value.</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style="font-family: &#39;Times New Roman&#39;; font-weight: bold; font-size: 20px; ">Conclusion</span></p><p><span style="font-weight: bold; font-size: 20px; ">总结</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-size:16px">对于延迟实例化，有三种写法是可取的：</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-weight:bold;font-size:16px">第一种：利用<span style="font-family:Times New Roman">volatile</span></span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px"></span></p><pre class="brush:java;toolbar:false">class&nbsp;Foo&nbsp;{&nbsp;
&nbsp;&nbsp;private&nbsp;volatile&nbsp;Helper&nbsp;helper&nbsp;=&nbsp;null;
&nbsp;&nbsp;public&nbsp;Helper&nbsp;getHelper()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(helper&nbsp;==&nbsp;null)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized(this)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(helper&nbsp;==&nbsp;null)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;helper&nbsp;=&nbsp;new&nbsp;Helper();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;helper;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}</pre><p><span class="Apple-style-span" style="font-size: 16px; font-weight: bold; line-height: 28px; ">要求</span><span style="font-size: 16px; font-weight: bold; line-height: 28px; font-family: &#39;Times New Roman&#39;; ">JDK&nbsp;1.5+</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-weight:bold;font-size:16px">第二种：利用<span style="font-family:Times New Roman">ThreadLocal</span></span></p><p><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px"></span></p><pre class="brush:java;toolbar:false">class&nbsp;Foo&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;ThreadLocal&nbsp;perThreadInstance&nbsp;=&nbsp;new&nbsp;ThreadLocal();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Helper&nbsp;helper&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Helper&nbsp;getHelper()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(perThreadInstance.get()&nbsp;==&nbsp;null)&nbsp;createHelper();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;helper;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;void&nbsp;createHelper()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized(this)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(helper&nbsp;==&nbsp;null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;helper&nbsp;=&nbsp;new&nbsp;Helper();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Any&nbsp;non-null&nbsp;value&nbsp;would&nbsp;do&nbsp;as&nbsp;the&nbsp;argument&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perThreadInstance.set(perThreadInstance);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p><span class="Apple-style-span" style="font-size: 16px; font-weight: bold; line-height: 28px; ">要求&nbsp;</span><span style="font-size: 16px; font-weight: bold; line-height: 28px; font-family: &#39;Times New Roman&#39;; ">JDK&nbsp;1.4+</span><span class="Apple-style-span" style="font-size: 16px; font-weight: bold; line-height: 28px; ">，否则</span><span style="font-size: 16px; font-weight: bold; line-height: 28px; font-family: &#39;Times New Roman&#39;; ">ThreadLocal</span><span class="Apple-style-span" style="font-size: 16px; font-weight: bold; line-height: 28px; ">效率不高</span></p><p><span style=";font-size:16px">&nbsp;</span></p><p><span style=";font-weight:bold;font-size:16px">&nbsp;</span><span class="Apple-style-span" style="font-size: 16px; font-weight: bold; line-height: 28px; ">第三种：内部类</span></p><p style="line-height: normal; "><span style=";font-size:16px">&nbsp;</span><span class="Apple-style-span" style="font-family: &#39;Times New Roman&#39;; font-size: 16px; ">private&nbsp;static&nbsp;class&nbsp;LazySomethingHolder&nbsp;{</span></p><p style="line-height: normal; "><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp; &nbsp;public&nbsp;static&nbsp;Something&nbsp;something&nbsp;=&nbsp;new&nbsp;Something();</span></p><p style="line-height: normal; "><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">}</span></p><p style="line-height: normal; "><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp;public&nbsp;static&nbsp;Something&nbsp;getInstance()&nbsp;{</span></p><p style="line-height: normal; "><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">&nbsp; &nbsp;</span><span style=";font-family:&#39;Times New Roman&#39;;font-weight:bold;font-size:16px">return&nbsp;LazySomethingHolder.something;</span></p><p style="line-height: normal; "><span style=";font-family:&#39;Times New Roman&#39;;font-size:16px">}</span></p><p><span style="font-size:16px"><span class="Apple-style-span" style="line-height: 28px;"><br/></span></span></p><p><span style=";font-size:16px">我的建议是用<strong>第一种</strong>，加<span style="font-family:Times New Roman">volatile</span>，比较简洁。</span></p><p><span style=";font-size:16px">当然，<strong>第三种</strong>在单例模式里面也常见，安全性有保障。</span></p><p><br/></p>